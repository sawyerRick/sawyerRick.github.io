{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/images/dota2Img.jpeg","path":"images/dota2Img.jpeg","modified":1,"renderable":0},{"_id":"source/images/morty.jpg","path":"images/morty.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/.DS_Store","hash":"86e39b22606c7be2f244933ec3435554ad8b1cfa","modified":1641627998109},{"_id":"source/CNAME","hash":"bdec4c8a5f3df6ac85ef1b7b1538f6171ea3838c","modified":1641190075132},{"_id":"source/.DS_Store","hash":"fb7a855d3f3cd77029ee57687e76c7228332aff4","modified":1641300346555},{"_id":"source/_posts/Docker-Compose.md","hash":"64236aa797a431265a6d37157e4098ceb14ef096","modified":1641627475255},{"_id":"source/_posts/Docker-Command.md","hash":"0e3a46c81bbae29d01aee05d095394559a7b5cf3","modified":1641624567550},{"_id":"source/_posts/Java-JVM.md","hash":"0d893ab64cc1c33b990d658b36b797a8b954129c","modified":1641628551451},{"_id":"source/_posts/Docker-Network.md","hash":"60c86688807af5c024718f1d6f0999e2a3b99c6c","modified":1641624479857},{"_id":"source/_posts/Docker-Mount.md","hash":"11c1558d402320e55fa5f1e839fd9225377aac1a","modified":1641622757484},{"_id":"source/_posts/打造高效写作环境.md","hash":"51fc0301ea9f641bfebda0beb92793a3b45af158","modified":1641628274325},{"_id":"source/_posts/Docker-Images.md","hash":"8af39291cb669437c487d445fcb021c1a1217743","modified":1641626382882},{"_id":"source/_posts/Java-Concurrent.md","hash":"db9ee729f69e2947de19014c26876a13ec9766dd","modified":1641627977256},{"_id":"source/_posts/init-commit.md","hash":"ae742f3934203837601c673391dabd05e92eade7","modified":1641292693312},{"_id":"source/categories/index.md","hash":"a5b8fe47fe20d0617e48b0cc2f2ab532d3c44795","modified":1641291726927},{"_id":"source/tags/index.md","hash":"518eb6e0df7555cdb9047061de480fa6990ca2ab","modified":1641291788727},{"_id":"source/images/.DS_Store","hash":"37a2e604cca08fa26d2a85f7268061343157c05e","modified":1641197433802},{"_id":"source/about/index.md","hash":"c5ac2008fc451ef50a1ae4bf7bd70db436a1b81c","modified":1641300364587},{"_id":"source/images/morty.jpg","hash":"de994a8233ef59481973084b7458228b11481228","modified":1600699872780},{"_id":"node_modules/hexo-theme-butterfly/README.md","hash":"cedd13fcd8c75a68742265dd8eced4087e940ffd","modified":1641300091978},{"_id":"node_modules/hexo-theme-butterfly/README_CN.md","hash":"459d6f3200863021bee1fe72a719aef236fb4090","modified":1641300091978},{"_id":"node_modules/hexo-theme-butterfly/package.json","hash":"648133dc95e1990682930b02e6b6074def034db7","modified":1641300091977},{"_id":"node_modules/hexo-theme-butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1641300091969},{"_id":"node_modules/hexo-theme-butterfly/languages/default.yml","hash":"7ca673fb629ea74f5ba5e75b4f0f95248cfb5090","modified":1641300092074},{"_id":"node_modules/hexo-theme-butterfly/.github/stale.yml","hash":"05a55a87fa7f122c59683e41c8b2e37e79f688f0","modified":1641300092076},{"_id":"node_modules/hexo-theme-butterfly/_config.yml","hash":"63d1a594969b7b5b97e1babebc7b85ef07c02e4f","modified":1641300092074},{"_id":"node_modules/hexo-theme-butterfly/languages/en.yml","hash":"cd333235ff1648a6bf58dfafc81f2c57672a15a5","modified":1641300092075},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-CN.yml","hash":"741e522b2387f94764a73844e7b084cc7e927c54","modified":1641300092076},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-TW.yml","hash":"79a50c40d9f5463f1fa42aa870ac6b8b84540412","modified":1641300092076},{"_id":"node_modules/hexo-theme-butterfly/layout/archive.pug","hash":"bd62286afb64a51c97e800c5945620d51605d5fa","modified":1641300091980},{"_id":"node_modules/hexo-theme-butterfly/layout/category.pug","hash":"60c1b795b6e227b5dd81963b51d29d1b81d0bf49","modified":1641300091984},{"_id":"node_modules/hexo-theme-butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1641300091991},{"_id":"node_modules/hexo-theme-butterfly/layout/page.pug","hash":"82aa988527a11835e7ac86ce4f23b8cd20014dfa","modified":1641300091993},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"476802922b774b679225102ac30a9d9183394701","modified":1641300091977},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"eff495eb1584cf4586e33c76e8b2fa6a469a179b","modified":1641300091977},{"_id":"node_modules/hexo-theme-butterfly/layout/post.pug","hash":"8d398c8925182699d9f2b9f1b727f06228488312","modified":1641300091995},{"_id":"node_modules/hexo-theme-butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1641300091997},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"f6867a2f0417fe89a0f2008730ee19dd38422021","modified":1641300091977},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1641300092075},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/404.pug","hash":"7d378e328a53cc99d5acc9682dce53f5eb61537d","modified":1641300091978},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/additional-js.pug","hash":"4156224c47bfc2482281ac4e4df701c30476ff00","modified":1641300091979},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head.pug","hash":"1377952022ee0a9eaa7a2fd1098f1571efc468d9","modified":1641300091989},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1641300091988},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/layout.pug","hash":"6f2608c4d93d3d10ae6b2cd7f8918f303f024321","modified":1641300091991},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/pagination.pug","hash":"0b80f04950bd0fe5e6c4e7b7559adf4d0ce28436","modified":1641300091994},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/rightside.pug","hash":"2d0453adf92a3fd3466cf0793f14685d17b8b51d","modified":1641300091996},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/post_lazyload.js","hash":"4cc2d517195c8779471d326ada09f9371cbad4dd","modified":1641300091976},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/sidebar.pug","hash":"8dafc2dcd8c33f70a546fee443f0b6d80b3cd243","modified":1641300091996},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/random_cover.js","hash":"9821872007cf57efae4b728dc575ef9d004547bb","modified":1641300091976},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1641300091971},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/init.js","hash":"018aa446265fe627301b1d53d7cba4f4ff1960ac","modified":1641300091973},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/welcome.js","hash":"d575137c8779e50422c2416f4d0832fdea346ee6","modified":1641300091977},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1641300091972},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1641300091972},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/inject_head_js.js","hash":"65f2442e04c4defd16e7c1e67701d3bb41d9577a","modified":1641300091974},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/page.js","hash":"c6611d97087c51845cb1ab4821696a62fa33daeb","modified":1641300091975},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/related_post.js","hash":"21556f9cb412ddc500ad12ecfd419f3ea6c9f663","modified":1641300091976},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/button.js","hash":"b816ded1451f28c7c54151ffe6c259b110253ae3","modified":1641300091973},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/gallery.js","hash":"94826ea6bcc4d2304199adae12c4e2b272caf529","modified":1641300091973},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/hide.js","hash":"f33858ffb9e88191e644796e11d2f901eb332308","modified":1641300091973},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1641300091974},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1641300091974},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/mermaid.js","hash":"35f073021db93699fcac9ef351e26c59c31aadf7","modified":1641300091975},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/note.js","hash":"c16c6eb058af2b36bcd583b2591076c7ebdd51ad","modified":1641300091975},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1641300091976},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","hash":"40c3f64422205a24e68ce1ad8fe8163f24fdd525","modified":1641300092073},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","hash":"b244f28124a46d7f1e8ef76ba6e925289691f93b","modified":1641300091975},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","hash":"8319b59c26ce8cd2b0ae7d030c4912215148fa92","modified":1641300091976},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1641300091976},{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","hash":"861998e4ac67a59529a8245a9130d68f826c9c12","modified":1641300092061},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1641300091971},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1641300091978},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/Open_Graph.pug","hash":"6c41f49a3e682067533dd9384e6e4511fc3a1349","modified":1641300091993},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/analytics.pug","hash":"90d01b88d0f406d00184960b1afe9230aec2ebe6","modified":1641300091980},{"_id":"node_modules/hexo-theme-butterfly/source/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1641300092073},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config.pug","hash":"4def0aab9e2172ad1f29abd1535d8e08ff23aa0b","modified":1641300091985},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config_site.pug","hash":"889ef16fa34a39e5533bc170e62f20f3450cc522","modified":1641300091985},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1641300091989},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1641300091970},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1641300091993},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/preconnect.pug","hash":"e55f8bdb876d5429a908498db1307b94094c0d06","modified":1641300091995},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1641300091996},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1641300091996},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/index.pug","hash":"65fa23680af0daf64930a399c2f2ca37809a8149","modified":1641300091989},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/menu_item.pug","hash":"24370508ee87f14418e8f06e9d79ad8c52a342c4","modified":1641300091992},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/nav.pug","hash":"c205b9fd72b2fe19e6d15c5b5ab0fb38c653032e","modified":1641300091993},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/post-info.pug","hash":"92f81a437c9db49f7ebcf608bc09488ecdb55a21","modified":1641300091995},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/social.pug","hash":"0d953e51d04a9294a64153c89c20f491a9ec42d4","modified":1641300091997},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/loading.pug","hash":"5276937fbcceb9d62879dc47be880cd469a27349","modified":1641300091992},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/loading-js.pug","hash":"4cfcf0100e37ce91864703cd44f1cb99cb5493ea","modified":1641300091992},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/article-sort.pug","hash":"2fb74d0b0e4b98749427c5a1a1b0acb6c85fadc4","modified":1641300091981},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/post-ui.pug","hash":"4c3c5cb69b3aead8c232cb0fbc251929f28aad75","modified":1641300091995},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/categories.pug","hash":"1f30952fed73dec21b42e2e30b7fe2e84618d2e4","modified":1641300091984},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/default-page.pug","hash":"dbec869c62135695495703a29ad7655e9965d461","modified":1641300091985},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/flink.pug","hash":"b53a2d4f9c37b375a4446d2273dcfb7712d91b3e","modified":1641300091987},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/tags.pug","hash":"93d4ebc7dc8228c7a10ddeb5a553d0dcdabbe145","modified":1641300091997},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/post-copyright.pug","hash":"88e3b611b03149665e4113cfa39595c1a3fca7e5","modified":1641300091995},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/aplayer.pug","hash":"292646dfab135973b09f0fa9e3931e83da2ed30e","modified":1641300091980},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/reward.pug","hash":"5b404356f311d2ee36478291ca3553210867b738","modified":1641300091996},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/effect.pug","hash":"b9d54a01d7c2a7a183cb7209e99430ce7fea1fe3","modified":1641300091987},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pjax.pug","hash":"933cb710d2dbcea25c6426a57c6f49d2f48b792c","modified":1641300091994},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pangu.pug","hash":"d5fec7dedc52ab23865fb4db002755e9bdaadc9f","modified":1641300091994},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1641300091981},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/prismjs.pug","hash":"1fbecfd299068f90d727f0c8c65e2a792fa6e3e2","modified":1641300091995},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_announcement.pug","hash":"3d8e3706a056389176f55dd21956aabc78046761","modified":1641300091981},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1641300091982},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_author.pug","hash":"0366c658cdcff839aa1df2e2d252a03a53fd427e","modified":1641300091982},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1641300091982},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/subtitle.pug","hash":"d50e5c22cd6bc3c378bc581918136746cfa3447f","modified":1641300091997},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1641300091982},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_newest_comment.pug","hash":"27afd2274bd5f2cbbf1bad9f0afe2b2b72c213ca","modified":1641300091982},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_post_toc.pug","hash":"ae9336bf31cdad08ff586ead4295912a96563c76","modified":1641300091983},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_recent_post.pug","hash":"9c1229af6ab48961021886882c473514101fba21","modified":1641300091983},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_tags.pug","hash":"438aea3e713ed16b7559b9a80a9c5ec0221263df","modified":1641300091983},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1641300091983},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_webinfo.pug","hash":"0612aaee878f33ea8d3da0293c7dc3b6cd871466","modified":1641300091983},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/index.pug","hash":"b5525891f6affd02c1ea3b2327c026882efe428b","modified":1641300091991},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/function.styl","hash":"eda47f3e807a466ba8275627ea936c5100c43818","modified":1641300092040},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/index.styl","hash":"e211efbd1952d4b1b881287aa43423133c1d166e","modified":1641300092043},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight.styl","hash":"85e72c70a0cef29e40be1968f5d23b06c6f8e3aa","modified":1641300092042},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/theme.styl","hash":"fa4b87e7b29bdd1f09eb1a30e06ba74b224f0ba2","modified":1641300092072},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/aside.styl","hash":"7feb755ca7c22da36bbad11e74ecd95fdcf3b879","modified":1641300092002},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/chat.styl","hash":"29f48f9370f245e6e575b5836bccf47eb5688d8b","modified":1641300092003},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/footer.styl","hash":"dd8cdf639ba2b726437c77fa7aa8d5edbabe8f9b","modified":1641300092039},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/comments.styl","hash":"f1b63892baafa48ab872bc79671d57aafd511f6c","modified":1641300092003},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/head.styl","hash":"98235fcda3b87ad6f7e91eafbed94d0d6ae847ca","modified":1641300092041},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/loading.styl","hash":"7d18a7be9cfea65091de3ef00014063d2d649912","modified":1641300092069},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/pagination.styl","hash":"90fe01c968696a9f791cb2b84fca621cbbb56f47","modified":1641300092070},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/post.styl","hash":"d748951d9fbcd04dda839085af78b01b8fa04cba","modified":1641300092070},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/relatedposts.styl","hash":"0551c5893d1589a3d17ce161e50ecb1d724cc6e8","modified":1641300092071},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/reward.styl","hash":"ea1ba40dd5954c2ed718a126336fb7f94da4e66f","modified":1641300092071},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/rightside.styl","hash":"7a072589e6097dbe942783131964f2372fdf1eb6","modified":1641300092072},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/sidebar.styl","hash":"2c5fb77c448ce0a734040c8ce532b28fed688899","modified":1641300092072},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/third-party.styl","hash":"978c397d0966eaf9e6e2afd13866f8f4900b509f","modified":1641300092073},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/404.styl","hash":"b0488ceacde74af139d66c8db5cb36cc21737b9b","modified":1641300092000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/archives.styl","hash":"6874adc2e276443f354bbe50d0072e9bec37243c","modified":1641300092001},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/categories.styl","hash":"e554549f0a0ae85362f0b0e8687981741f486f6b","modified":1641300092003},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/common.styl","hash":"97fec1e814f88237862f4d800a35362b802f6625","modified":1641300092003},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/flink.styl","hash":"2cc49d3f6a6beb9f7bff93e292f88aa5681da1d0","modified":1641300092039},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/homepage.styl","hash":"7c4152162a03aa8331a783df5695e4ebbb816a8c","modified":1641300092042},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/tags.styl","hash":"9a881c031f463c486bd25248c2814fd09f97892b","modified":1641300092072},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/algolia.styl","hash":"917e0e399e117217184ca63d3eb5c4843bcccf7b","modified":1641300092001},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/index.styl","hash":"f168f5c669978f633abe118cdcc4a12cfc883c01","modified":1641300092049},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/local-search.styl","hash":"6befe4c51b86d0c1de130beeecad9e28d6442713","modified":1641300092070},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/darkmode.styl","hash":"4e629f510b73f998ab208b739c5bd7dcd168d1a7","modified":1641300092004},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/readmode.styl","hash":"f59a9a0059d5261251bdd6de45aa97dd2d11e633","modified":1641300092071},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/button.styl","hash":"1c3f9d7efc3b9dfcfa8926a1132d0c44ffc7d4b2","modified":1641300092002},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/gallery.styl","hash":"53ecae272e16223a436c497abbf25dd5f0fc4aaa","modified":1641300092040},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hexo.styl","hash":"d0386ba6d8d63afc72b9673e8f3e89df6446ffc2","modified":1641300092041},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hide.styl","hash":"21964fdd6d74ffbea519418bab65024aee5f3736","modified":1641300092041},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1641300092064},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/label.styl","hash":"f741e85295ce15c70a6027ec15a542636dd5dcca","modified":1641300092065},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/note.styl","hash":"86fee274a62f7f034547342930f445c47378eb55","modified":1641300092070},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/tabs.styl","hash":"1756791581c0ec51cb03353a09dac4778d944349","modified":1641300092072},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1641300091972},{"_id":"node_modules/hexo-theme-butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1641300091970},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1641300091986},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","hash":"b1429e9f80ef6b9a77434819ffb87d90bdad25e8","modified":1641300091974},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"7848ec58c6ec03243abf80a3b22b4dc10f3edf53","modified":1641300091987},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"e3bf847553515174f6085df982f0623e9783db7a","modified":1641300091989},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"ef1b2b5b980d6aeaa5d06b97d1afc9644b155a16","modified":1641300091998},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"bba9871f446c10ffcc8fa9023f5a2eb701a86bae","modified":1641300091999},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"400ce038548d6f9ddb486150c724c87b6923a88b","modified":1641300092000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/chatra.pug","hash":"481cd5053bafb1a19f623554a27d3aa077ea59c3","modified":1641300091984},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/crisp.pug","hash":"76634112c64023177260d1317ae39cef2a68e35f","modified":1641300091985},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"cfe63e7d26a6665df6aa32ca90868ad48e05ec04","modified":1641300091985},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/gitter.pug","hash":"d1d2474420bf4edc2e43ccdff6f92b8b082143df","modified":1641300091988},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/index.pug","hash":"3f05f8311ae559d768ee3d0925e84ed767c314d3","modified":1641300091989},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/tidio.pug","hash":"24a926756c2300b9c561aaab6bd3a71fdd16e16d","modified":1641300091997},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqus.pug","hash":"a111407fdcafcf1099e26ffa69786f8822c5d9fb","modified":1641300091986},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"2e52c64e89f16267596a8465841dd46f51820982","modified":1641300091987},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"c46a932257212f82e4a9974fbbc5de8878c8b383","modified":1641300091987},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"0b7571919e8ad51285deda56a1868fccf8c563d7","modified":1641300091988},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/index.pug","hash":"da9813f8dc0d388869c15413cf056012cfb69e1a","modified":1641300091990},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/js.pug","hash":"bafb3d5710824caa59a56017afb058fd2b4eac65","modified":1641300091991},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1641300091992},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"16378d8646ea3f4ac99c18f0296dd85b13f9d775","modified":1641300091998},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/utterances.pug","hash":"b871ea208e36398b4d668db9a9a0b61c79415381","modified":1641300091999},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/valine.pug","hash":"2b45fe09d5b591dca156b76dae99981f8d8e1c61","modified":1641300091999},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/waline.pug","hash":"36f3c603d2a2ecddaa6d2675a89d76ad94968f72","modified":1641300092000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1641300091990},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/katex.pug","hash":"f9b00ead54573ba6e6eb33481588af144aab648d","modified":1641300091991},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mathjax.pug","hash":"a47d8f9f593091cc91192c0c49deaa2c0d2317fd","modified":1641300091992},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mermaid.pug","hash":"3f3a3cd8bea2103dedd754f767aca5cb84d5f586","modified":1641300091993},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"b443d6b16baf3ea250041342cc0361a42a412b7f","modified":1641300091986},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"34088a15655704d12e9b1807b47b3f6a860c9eec","modified":1641300091988},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f6506ccfd1ce994b9e53aa95588d0b6dbad11411","modified":1641300091990},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"cb38ffe911023092a90a28f2ba8317a92b22cd0c","modified":1641300091998},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"59b4c26a827ace5a54855881d199977103ff6f50","modified":1641300091999},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"a2bc2601b7e0ae5caf1fc51a07390562d928620a","modified":1641300092000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/index.pug","hash":"da3b9437d061ee68dbc383057db5c73034c49605","modified":1641300091990},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/algolia.pug","hash":"d8f59e94eafc669c49349561dc5bbea3915aecb7","modified":1641300091979},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/local-search.pug","hash":"613280d61b8ab9612014ec016ae3d3698d36fd1a","modified":1641300091992},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1641300091979},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/addtoany.pug","hash":"309f51bc5302e72fc469d54c577fbcfe57fb07a8","modified":1641300091979},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1641300091991},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/share-js.pug","hash":"006acc91ce25fc7c7d778ca043e970f57dc46b83","modified":1641300091996},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/diff.styl","hash":"8c0726fb8d9a497d2f900b0be2845efaa68e3d87","modified":1641300092037},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/index.styl","hash":"89cbcc8e087788ecec18b5fa58710afacdb7d080","modified":1641300092043},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1641300092038},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/index.styl","hash":"e0e7065124ef0d99f8322a47bc47838982e04ad0","modified":1641300092044},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1641300092068},{"_id":"source/images/dota2Img.jpeg","hash":"3e7206ed1894364dcf7627b2dc5d161c855333f7","modified":1625904020108},{"_id":"public/categories/index.html","hash":"b04822b023c76469add08ecd6aae5f2ef613e65a","modified":1641628561706},{"_id":"public/about/index.html","hash":"028a5c3832493bb0e7c848ada47ee031f393d634","modified":1641628561706},{"_id":"public/tags/index.html","hash":"47f5ca0ee71088f4f36ec4a6cac36d9b5f22e55d","modified":1641628561706},{"_id":"public/2022/01/08/Java-JVM/index.html","hash":"550e9f1e2db86926d332fe51b6e55263fbf2ab79","modified":1641628561706},{"_id":"public/2022/01/08/Java-Concurrent/index.html","hash":"9b106ae6609f52703477792e90dbf92599ee74d3","modified":1641628561706},{"_id":"public/2022/01/08/Docker-Compose/index.html","hash":"7e5efd12bbf8ec41fc21f82dbe17b82e7c92bf33","modified":1641628561706},{"_id":"public/2022/01/08/Docker-Network/index.html","hash":"c7a439cf400a48c0edeaf0cf1d0982e2254f510f","modified":1641628561706},{"_id":"public/2022/01/08/Docker-Images/index.html","hash":"94e0821cb7b709cc6dc0386049c3baa2bceeebb4","modified":1641628561706},{"_id":"public/2022/01/08/Docker-Command/index.html","hash":"829d3107250f3f08a66c2b55613efb23a29c8c31","modified":1641628561706},{"_id":"public/2022/01/07/Docker-Mount/index.html","hash":"58eba2d04991e15d69970f012276791cf63484a6","modified":1641628561706},{"_id":"public/2022/01/04/打造高效写作环境/index.html","hash":"ff183e418702538b2dde82f74563f2de1b4b3410","modified":1641628561706},{"_id":"public/2022/01/04/init-commit/index.html","hash":"8116b1654fdf51f0e4d54f3d2c6dc525d17e1cd5","modified":1641628561706},{"_id":"public/archives/index.html","hash":"204d6001841b9ae6092d3907ce0be5fcf2b6c815","modified":1641628561706},{"_id":"public/archives/2022/index.html","hash":"f3237cb79f5a0bd38b6241687b36cf587502eebc","modified":1641628561706},{"_id":"public/archives/2022/01/index.html","hash":"9e9c6a3174cfe8a24fa166db866655588f42da20","modified":1641628561706},{"_id":"public/categories/init-commit/index.html","hash":"3ef307701fcf87827586eae521e3c6ecb6b33b87","modified":1641628561706},{"_id":"public/index.html","hash":"29d25723c3067f021479db997359605b8fc13c8f","modified":1641628561706},{"_id":"public/tags/Docker/index.html","hash":"d793d34f74e85ff1d9fc41a8b296c77c919933fa","modified":1641628561706},{"_id":"public/tags/Java/index.html","hash":"c68b460e17e90805c695112f029fec42030bd6eb","modified":1641628561706},{"_id":"public/tags/init-commit/index.html","hash":"fc479fca4170bad9c9e25cdb1bb59207c15c36b5","modified":1641628561706},{"_id":"public/tags/tutorial/index.html","hash":"16b78c4244c68eb67e7d8debaa3d7dd3658fee3d","modified":1641628561706},{"_id":"public/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1641628561706},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1641628561706},{"_id":"public/CNAME","hash":"bdec4c8a5f3df6ac85ef1b7b1538f6171ea3838c","modified":1641628561706},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1641628561706},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1641628561706},{"_id":"public/images/morty.jpg","hash":"de994a8233ef59481973084b7458228b11481228","modified":1641628561706},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641628561706},{"_id":"public/js/utils.js","hash":"8319b59c26ce8cd2b0ae7d030c4912215148fa92","modified":1641628561706},{"_id":"public/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1641628561706},{"_id":"public/js/search/local-search.js","hash":"b1429e9f80ef6b9a77434819ffb87d90bdad25e8","modified":1641628561706},{"_id":"public/css/index.css","hash":"2e399ff7f57ed93bcdb4aaceffd343c0609baa20","modified":1641628561706},{"_id":"public/js/main.js","hash":"b244f28124a46d7f1e8ef76ba6e925289691f93b","modified":1641628561706},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1641628561706},{"_id":"public/images/dota2Img.jpeg","hash":"3e7206ed1894364dcf7627b2dc5d161c855333f7","modified":1641628561706}],"Category":[{"name":"init_commit","_id":"cky5j9fdx000kw3xw10ql4m3m"}],"Data":[],"Page":[{"title":"categories","date":"2022-01-03T09:11:09.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2022-01-03 17:11:09\ntype: categories\n---\n","updated":"2022-01-04T10:22:06.927Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cky5j9fdd0000w3xwa85adga1","content":"","site":{"data":{}},"cover":"/images/dota2Img.jpeg","excerpt":"","more":""},{"title":"about","date":"2022-01-04T12:45:33.000Z","_content":"\n\n\nSerial's land.\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2022-01-04 20:45:33\n---\n\n\n\nSerial's land.\n","updated":"2022-01-04T12:46:04.587Z","path":"about/index.html","comments":1,"layout":"page","_id":"cky5j9fdi0002w3xwenppcnjc","content":"<p>Serial’s land.</p>\n","site":{"data":{}},"cover":"/images/dota2Img.jpeg","excerpt":"","more":"<p>Serial’s land.</p>\n"},{"title":"tags","date":"2022-01-03T09:10:53.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2022-01-03 17:10:53\ntype: tags\n---\n","updated":"2022-01-04T10:23:08.727Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cky5j9fdn0005w3xw6czh431d","content":"","site":{"data":{}},"cover":"/images/dota2Img.jpeg","excerpt":"","more":""}],"Post":[{"title":"Docker-Images","date":"2022-01-08T06:30:08.000Z","_content":"\n# Docker-Images 制作镜像\n\nImages镜像是一个描述了应用运行所需环境/依赖的只读文件。\n\n所以构建镜像需要描述应用的运行环境/依赖，这个描述文件是Dockerfile。\n\n有了Docker Images，我们可以面向Images编程，无需关心操作系统的差异性。\n\n## Dockerfile\n\n- FROM，基础镜像\n- ADD，复制代码 or 其他文件\n\n- RUN，构建镜像时运行\n- CMD，容器运行时运行\n\n**例子**\n\n```Dockerfile\nFROM node:11 # 基础镜像\n\nMAINTAINER serialrick.top # 维护者\n\n# 把宿主机的.复制到/app（通常用于复制代码）\nADD . /app\n\n# 容器运行后进入此目录\nWORKDIR /app\n\n# 构建镜像时需要运行的命令，可以有多个\nRUN npm install\n\n# 运行容器时执行的命令，只能有一个\nCMD node app.js\n```\n\n## build images\n\n**制作镜像命令**\n\n指定了Dockerfile在.路径\n\n`docker build -t myimage .`\n\n## 镜像仓库\n\nhttps://hub.docker.com/\n\n# Reference\n\n[制作自己的镜像](https://docker.easydoc.net/doc/81170005/cCewZWoN/N9VtYIIi)\n\n[Dockerfile](https://docs.docker.com/engine/reference/builder/#run)\n\n","source":"_posts/Docker-Images.md","raw":"---\ntitle: Docker-Images\ndate: 2022-01-08 14:30:08\ntags: Docker\n---\n\n# Docker-Images 制作镜像\n\nImages镜像是一个描述了应用运行所需环境/依赖的只读文件。\n\n所以构建镜像需要描述应用的运行环境/依赖，这个描述文件是Dockerfile。\n\n有了Docker Images，我们可以面向Images编程，无需关心操作系统的差异性。\n\n## Dockerfile\n\n- FROM，基础镜像\n- ADD，复制代码 or 其他文件\n\n- RUN，构建镜像时运行\n- CMD，容器运行时运行\n\n**例子**\n\n```Dockerfile\nFROM node:11 # 基础镜像\n\nMAINTAINER serialrick.top # 维护者\n\n# 把宿主机的.复制到/app（通常用于复制代码）\nADD . /app\n\n# 容器运行后进入此目录\nWORKDIR /app\n\n# 构建镜像时需要运行的命令，可以有多个\nRUN npm install\n\n# 运行容器时执行的命令，只能有一个\nCMD node app.js\n```\n\n## build images\n\n**制作镜像命令**\n\n指定了Dockerfile在.路径\n\n`docker build -t myimage .`\n\n## 镜像仓库\n\nhttps://hub.docker.com/\n\n# Reference\n\n[制作自己的镜像](https://docker.easydoc.net/doc/81170005/cCewZWoN/N9VtYIIi)\n\n[Dockerfile](https://docs.docker.com/engine/reference/builder/#run)\n\n","slug":"Docker-Images","published":1,"updated":"2022-01-08T07:19:42.882Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky5j9fdg0001w3xwgzun2zsv","content":"<h1 id=\"Docker-Images-制作镜像\"><a href=\"#Docker-Images-制作镜像\" class=\"headerlink\" title=\"Docker-Images 制作镜像\"></a>Docker-Images 制作镜像</h1><p>Images镜像是一个描述了应用运行所需环境/依赖的只读文件。</p>\n<p>所以构建镜像需要描述应用的运行环境/依赖，这个描述文件是Dockerfile。</p>\n<p>有了Docker Images，我们可以面向Images编程，无需关心操作系统的差异性。</p>\n<h2 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a>Dockerfile</h2><ul>\n<li><p>FROM，基础镜像</p>\n</li>\n<li><p>ADD，复制代码 or 其他文件</p>\n</li>\n<li><p>RUN，构建镜像时运行</p>\n</li>\n<li><p>CMD，容器运行时运行</p>\n</li>\n</ul>\n<p><strong>例子</strong></p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">11</span> <span class=\"comment\"># 基础镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">MAINTAINER</span> serialrick.top <span class=\"comment\"># 维护者</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 把宿主机的.复制到/app（通常用于复制代码）</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 容器运行后进入此目录</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建镜像时需要运行的命令，可以有多个</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行容器时执行的命令，只能有一个</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> node app.js</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"build-images\"><a href=\"#build-images\" class=\"headerlink\" title=\"build images\"></a>build images</h2><p><strong>制作镜像命令</strong></p>\n<p>指定了Dockerfile在.路径</p>\n<p><code>docker build -t myimage .</code></p>\n<h2 id=\"镜像仓库\"><a href=\"#镜像仓库\" class=\"headerlink\" title=\"镜像仓库\"></a>镜像仓库</h2><p><a href=\"https://hub.docker.com/\">https://hub.docker.com/</a></p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p><a href=\"https://docker.easydoc.net/doc/81170005/cCewZWoN/N9VtYIIi\">制作自己的镜像</a></p>\n<p><a href=\"https://docs.docker.com/engine/reference/builder/#run\">Dockerfile</a></p>\n","site":{"data":{}},"cover":"/images/dota2Img.jpeg","excerpt":"","more":"<h1 id=\"Docker-Images-制作镜像\"><a href=\"#Docker-Images-制作镜像\" class=\"headerlink\" title=\"Docker-Images 制作镜像\"></a>Docker-Images 制作镜像</h1><p>Images镜像是一个描述了应用运行所需环境/依赖的只读文件。</p>\n<p>所以构建镜像需要描述应用的运行环境/依赖，这个描述文件是Dockerfile。</p>\n<p>有了Docker Images，我们可以面向Images编程，无需关心操作系统的差异性。</p>\n<h2 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a>Dockerfile</h2><ul>\n<li><p>FROM，基础镜像</p>\n</li>\n<li><p>ADD，复制代码 or 其他文件</p>\n</li>\n<li><p>RUN，构建镜像时运行</p>\n</li>\n<li><p>CMD，容器运行时运行</p>\n</li>\n</ul>\n<p><strong>例子</strong></p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">11</span> <span class=\"comment\"># 基础镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">MAINTAINER</span> serialrick.top <span class=\"comment\"># 维护者</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 把宿主机的.复制到/app（通常用于复制代码）</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 容器运行后进入此目录</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建镜像时需要运行的命令，可以有多个</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行容器时执行的命令，只能有一个</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> node app.js</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"build-images\"><a href=\"#build-images\" class=\"headerlink\" title=\"build images\"></a>build images</h2><p><strong>制作镜像命令</strong></p>\n<p>指定了Dockerfile在.路径</p>\n<p><code>docker build -t myimage .</code></p>\n<h2 id=\"镜像仓库\"><a href=\"#镜像仓库\" class=\"headerlink\" title=\"镜像仓库\"></a>镜像仓库</h2><p><a href=\"https://hub.docker.com/\">https://hub.docker.com/</a></p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p><a href=\"https://docker.easydoc.net/doc/81170005/cCewZWoN/N9VtYIIi\">制作自己的镜像</a></p>\n<p><a href=\"https://docs.docker.com/engine/reference/builder/#run\">Dockerfile</a></p>\n"},{"title":"Docker-Compose","date":"2022-01-08T07:31:28.000Z","_content":"\n# Docker-Compose\n\n> Compose is a tool for defining and running multi-container Docker applications.\n\nDocker Compose可以组合多个容器，使多容器应用可以做到一键构建运行（COOL ! ）。\n\n使用`docker-compose.yml`文件描述多容器应用。\n\n## docker-compose.yml\n\n一个简单的包括一个webapp和redis的例子，其中有用到不同的挂载方式(bind mount&volume)和不同的启动方式（build/images)。\n\n> Notes: 根据Docker Compose启动的应用，内部所有应用默认都在同一个虚拟网络中\n\n```yml\nversion: \"3.7\"\n\nservices:\n  app: # 应用1\n    build: ./ # 在此目录构建运行\n    ports:\n      - 80:8080\n    volumes: # 使用bind mount\n      - ./:/app\n    environment:\n      - TZ=Asia/Shanghai\n  redis: # 应用2\n    image: redis:5.0.13 # 使用镜像运行\n    volumes: # 使用volume\n      - redis:/data\n    environment:\n      - TZ=Asia/Shanghai\n\nvolumes:\n  redis:\n```\n\n## Command\n\n**启动**\n\n`docker compose up`\n\n# Reference\n\n[Docker](https://docs.docker.com/compose/)\n\n[Docker教程](https://docker.easydoc.net/doc/81170005/cCewZWoN/IJJcUk5J)\n","source":"_posts/Docker-Compose.md","raw":"---\ntitle: Docker-Compose\ndate: 2022-01-08 15:31:28\ntags: Docker\n---\n\n# Docker-Compose\n\n> Compose is a tool for defining and running multi-container Docker applications.\n\nDocker Compose可以组合多个容器，使多容器应用可以做到一键构建运行（COOL ! ）。\n\n使用`docker-compose.yml`文件描述多容器应用。\n\n## docker-compose.yml\n\n一个简单的包括一个webapp和redis的例子，其中有用到不同的挂载方式(bind mount&volume)和不同的启动方式（build/images)。\n\n> Notes: 根据Docker Compose启动的应用，内部所有应用默认都在同一个虚拟网络中\n\n```yml\nversion: \"3.7\"\n\nservices:\n  app: # 应用1\n    build: ./ # 在此目录构建运行\n    ports:\n      - 80:8080\n    volumes: # 使用bind mount\n      - ./:/app\n    environment:\n      - TZ=Asia/Shanghai\n  redis: # 应用2\n    image: redis:5.0.13 # 使用镜像运行\n    volumes: # 使用volume\n      - redis:/data\n    environment:\n      - TZ=Asia/Shanghai\n\nvolumes:\n  redis:\n```\n\n## Command\n\n**启动**\n\n`docker compose up`\n\n# Reference\n\n[Docker](https://docs.docker.com/compose/)\n\n[Docker教程](https://docker.easydoc.net/doc/81170005/cCewZWoN/IJJcUk5J)\n","slug":"Docker-Compose","published":1,"updated":"2022-01-08T07:37:55.255Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky5j9fdj0003w3xwhfa3b2xg","content":"<h1 id=\"Docker-Compose\"><a href=\"#Docker-Compose\" class=\"headerlink\" title=\"Docker-Compose\"></a>Docker-Compose</h1><blockquote>\n<p>Compose is a tool for defining and running multi-container Docker applications.</p>\n</blockquote>\n<p>Docker Compose可以组合多个容器，使多容器应用可以做到一键构建运行（COOL ! ）。</p>\n<p>使用<code>docker-compose.yml</code>文件描述多容器应用。</p>\n<h2 id=\"docker-compose-yml\"><a href=\"#docker-compose-yml\" class=\"headerlink\" title=\"docker-compose.yml\"></a>docker-compose.yml</h2><p>一个简单的包括一个webapp和redis的例子，其中有用到不同的挂载方式(bind mount&amp;volume)和不同的启动方式（build/images)。</p>\n<blockquote>\n<p>Notes: 根据Docker Compose启动的应用，内部所有应用默认都在同一个虚拟网络中</p>\n</blockquote>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&quot;3.7&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span> <span class=\"comment\"># 应用1</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span> <span class=\"string\">./</span> <span class=\"comment\"># 在此目录构建运行</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">80</span><span class=\"string\">:8080</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span> <span class=\"comment\"># 使用bind mount</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./:/app</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">TZ=Asia/Shanghai</span></span><br><span class=\"line\">  <span class=\"attr\">redis:</span> <span class=\"comment\"># 应用2</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis:5.0.13</span> <span class=\"comment\"># 使用镜像运行</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span> <span class=\"comment\"># 使用volume</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">redis:/data</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">TZ=Asia/Shanghai</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">redis:</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Command\"><a href=\"#Command\" class=\"headerlink\" title=\"Command\"></a>Command</h2><p><strong>启动</strong></p>\n<p><code>docker compose up</code></p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p><a href=\"https://docs.docker.com/compose/\">Docker</a></p>\n<p><a href=\"https://docker.easydoc.net/doc/81170005/cCewZWoN/IJJcUk5J\">Docker教程</a></p>\n","site":{"data":{}},"cover":"/images/dota2Img.jpeg","excerpt":"","more":"<h1 id=\"Docker-Compose\"><a href=\"#Docker-Compose\" class=\"headerlink\" title=\"Docker-Compose\"></a>Docker-Compose</h1><blockquote>\n<p>Compose is a tool for defining and running multi-container Docker applications.</p>\n</blockquote>\n<p>Docker Compose可以组合多个容器，使多容器应用可以做到一键构建运行（COOL ! ）。</p>\n<p>使用<code>docker-compose.yml</code>文件描述多容器应用。</p>\n<h2 id=\"docker-compose-yml\"><a href=\"#docker-compose-yml\" class=\"headerlink\" title=\"docker-compose.yml\"></a>docker-compose.yml</h2><p>一个简单的包括一个webapp和redis的例子，其中有用到不同的挂载方式(bind mount&amp;volume)和不同的启动方式（build/images)。</p>\n<blockquote>\n<p>Notes: 根据Docker Compose启动的应用，内部所有应用默认都在同一个虚拟网络中</p>\n</blockquote>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&quot;3.7&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span> <span class=\"comment\"># 应用1</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span> <span class=\"string\">./</span> <span class=\"comment\"># 在此目录构建运行</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">80</span><span class=\"string\">:8080</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span> <span class=\"comment\"># 使用bind mount</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./:/app</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">TZ=Asia/Shanghai</span></span><br><span class=\"line\">  <span class=\"attr\">redis:</span> <span class=\"comment\"># 应用2</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis:5.0.13</span> <span class=\"comment\"># 使用镜像运行</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span> <span class=\"comment\"># 使用volume</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">redis:/data</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">TZ=Asia/Shanghai</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">redis:</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Command\"><a href=\"#Command\" class=\"headerlink\" title=\"Command\"></a>Command</h2><p><strong>启动</strong></p>\n<p><code>docker compose up</code></p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p><a href=\"https://docs.docker.com/compose/\">Docker</a></p>\n<p><a href=\"https://docker.easydoc.net/doc/81170005/cCewZWoN/IJJcUk5J\">Docker教程</a></p>\n"},{"title":"Docker-Command","date":"2022-01-08T06:14:59.000Z","_content":"\n# Docker-Command\n\n总结我常用的Docker命令\n\n- 进入容器的shell：docker exec -it containerId /bin/bash\n- 查看所有正在运行的容器：docker ps\n- 查看所有容器：docker ps -a\n\n\n\n有着挂载、网络、stdin交互功能地运行容器\n\n`docker run -it -p 8080:8080 --mount type=bind,src=\"$(pwd)\",target=/app --network=test-net webapp`\n\n","source":"_posts/Docker-Command.md","raw":"---\ntitle: Docker-Command\ndate: 2022-01-08 14:14:59\ntags: Docker\n---\n\n# Docker-Command\n\n总结我常用的Docker命令\n\n- 进入容器的shell：docker exec -it containerId /bin/bash\n- 查看所有正在运行的容器：docker ps\n- 查看所有容器：docker ps -a\n\n\n\n有着挂载、网络、stdin交互功能地运行容器\n\n`docker run -it -p 8080:8080 --mount type=bind,src=\"$(pwd)\",target=/app --network=test-net webapp`\n\n","slug":"Docker-Command","published":1,"updated":"2022-01-08T06:49:27.550Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky5j9fdn0006w3xweu9b1mur","content":"<h1 id=\"Docker-Command\"><a href=\"#Docker-Command\" class=\"headerlink\" title=\"Docker-Command\"></a>Docker-Command</h1><p>总结我常用的Docker命令</p>\n<ul>\n<li>进入容器的shell：docker exec -it containerId /bin/bash</li>\n<li>查看所有正在运行的容器：docker ps</li>\n<li>查看所有容器：docker ps -a</li>\n</ul>\n<p>有着挂载、网络、stdin交互功能地运行容器</p>\n<p><code>docker run -it -p 8080:8080 --mount type=bind,src=&quot;$(pwd)&quot;,target=/app --network=test-net webapp</code></p>\n","site":{"data":{}},"cover":"/images/dota2Img.jpeg","excerpt":"","more":"<h1 id=\"Docker-Command\"><a href=\"#Docker-Command\" class=\"headerlink\" title=\"Docker-Command\"></a>Docker-Command</h1><p>总结我常用的Docker命令</p>\n<ul>\n<li>进入容器的shell：docker exec -it containerId /bin/bash</li>\n<li>查看所有正在运行的容器：docker ps</li>\n<li>查看所有容器：docker ps -a</li>\n</ul>\n<p>有着挂载、网络、stdin交互功能地运行容器</p>\n<p><code>docker run -it -p 8080:8080 --mount type=bind,src=&quot;$(pwd)&quot;,target=/app --network=test-net webapp</code></p>\n"},{"title":"Docker-Mount","date":"2022-01-07T14:20:02.000Z","_content":"\n# Docker Mount\n\nDocker 提供三种挂载技术：\n\n1. bind mount\n2. volume，\n3. tmpfs\n\n使用`--mount`或`-v`参数进行mount，`--mount`和`-v`唯一不同的地方在于：\n\n- 如果src不存在，`-v`会自动创建，而`--mount`则不会自动创建并抛出错误\n\n## 1. Bind mount\n\nbind mount通常用于本地更新代码\n\n\n\n### Example\n\n以下命令把宿主机的pwd/target挂载到容器的/app目录\n\n```shell\ndocker run -d \\\n  -it \\\n  --name devtest \\\n  --mount type=bind,source=\"$(pwd)\"/target,target=/app \\\n  nginx:latest\n```\n\n\n\n## 2. Volume（recommend）\n\nDocker Volume是一种持久化和数据共享技术，由Docker在host宿主机管理，可以把Volume 挂载（mount）到容器的文件夹上实现持久化功能。\n\n1. 有了Volume，容器停止后文件数据也可以保存。\n2. 不同容器可以共享同一个Volume\n\n#### Commands\n\n--mount和-v命令相同作用，但在service命令中只能用--mount。\n\n1. docker volume ls，查看所有volume\n2. docker volume create [volume-name]，创建volume\n3. docker inspect volume-name，查看volume\n4. --mount source=myvol2,target=/app，挂载volume到某个容器文件路径\n\n#### Example\n\n创建一个Volume myvol，挂载到容器的/app上\n\n```shell\ndocker run -d \\\n  --name devtest0 \\\n  --mount source=myvol,target=/app \\\n  nginx:latest\n```\n\n验证Volume持久化和共享功能：\n\n进入devtest0的/app，创建一些文件\n\n新开一个容器devtest1，执行相同命令，发现/app仍然有数据，验证了Volume的持久化功能。\n\n\n\n","source":"_posts/Docker-Mount.md","raw":"---\ntitle: Docker-Mount\ndate: 2022-01-07 22:20:02\ntags: Docker\n---\n\n# Docker Mount\n\nDocker 提供三种挂载技术：\n\n1. bind mount\n2. volume，\n3. tmpfs\n\n使用`--mount`或`-v`参数进行mount，`--mount`和`-v`唯一不同的地方在于：\n\n- 如果src不存在，`-v`会自动创建，而`--mount`则不会自动创建并抛出错误\n\n## 1. Bind mount\n\nbind mount通常用于本地更新代码\n\n\n\n### Example\n\n以下命令把宿主机的pwd/target挂载到容器的/app目录\n\n```shell\ndocker run -d \\\n  -it \\\n  --name devtest \\\n  --mount type=bind,source=\"$(pwd)\"/target,target=/app \\\n  nginx:latest\n```\n\n\n\n## 2. Volume（recommend）\n\nDocker Volume是一种持久化和数据共享技术，由Docker在host宿主机管理，可以把Volume 挂载（mount）到容器的文件夹上实现持久化功能。\n\n1. 有了Volume，容器停止后文件数据也可以保存。\n2. 不同容器可以共享同一个Volume\n\n#### Commands\n\n--mount和-v命令相同作用，但在service命令中只能用--mount。\n\n1. docker volume ls，查看所有volume\n2. docker volume create [volume-name]，创建volume\n3. docker inspect volume-name，查看volume\n4. --mount source=myvol2,target=/app，挂载volume到某个容器文件路径\n\n#### Example\n\n创建一个Volume myvol，挂载到容器的/app上\n\n```shell\ndocker run -d \\\n  --name devtest0 \\\n  --mount source=myvol,target=/app \\\n  nginx:latest\n```\n\n验证Volume持久化和共享功能：\n\n进入devtest0的/app，创建一些文件\n\n新开一个容器devtest1，执行相同命令，发现/app仍然有数据，验证了Volume的持久化功能。\n\n\n\n","slug":"Docker-Mount","published":1,"updated":"2022-01-08T06:19:17.484Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky5j9fdt000cw3xw6i876lqu","content":"<h1 id=\"Docker-Mount\"><a href=\"#Docker-Mount\" class=\"headerlink\" title=\"Docker Mount\"></a>Docker Mount</h1><p>Docker 提供三种挂载技术：</p>\n<ol>\n<li>bind mount</li>\n<li>volume，</li>\n<li>tmpfs</li>\n</ol>\n<p>使用<code>--mount</code>或<code>-v</code>参数进行mount，<code>--mount</code>和<code>-v</code>唯一不同的地方在于：</p>\n<ul>\n<li>如果src不存在，<code>-v</code>会自动创建，而<code>--mount</code>则不会自动创建并抛出错误</li>\n</ul>\n<h2 id=\"1-Bind-mount\"><a href=\"#1-Bind-mount\" class=\"headerlink\" title=\"1. Bind mount\"></a>1. Bind mount</h2><p>bind mount通常用于本地更新代码</p>\n<h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>以下命令把宿主机的pwd/target挂载到容器的/app目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d \\</span><br><span class=\"line\">  -it \\</span><br><span class=\"line\">  --name devtest \\</span><br><span class=\"line\">  --mount type=bind,source=&quot;$(pwd)&quot;/target,target=/app \\</span><br><span class=\"line\">  nginx:latest</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"2-Volume（recommend）\"><a href=\"#2-Volume（recommend）\" class=\"headerlink\" title=\"2. Volume（recommend）\"></a>2. Volume（recommend）</h2><p>Docker Volume是一种持久化和数据共享技术，由Docker在host宿主机管理，可以把Volume 挂载（mount）到容器的文件夹上实现持久化功能。</p>\n<ol>\n<li>有了Volume，容器停止后文件数据也可以保存。</li>\n<li>不同容器可以共享同一个Volume</li>\n</ol>\n<h4 id=\"Commands\"><a href=\"#Commands\" class=\"headerlink\" title=\"Commands\"></a>Commands</h4><p>–mount和-v命令相同作用，但在service命令中只能用–mount。</p>\n<ol>\n<li>docker volume ls，查看所有volume</li>\n<li>docker volume create [volume-name]，创建volume</li>\n<li>docker inspect volume-name，查看volume</li>\n<li>–mount source=myvol2,target=/app，挂载volume到某个容器文件路径</li>\n</ol>\n<h4 id=\"Example-1\"><a href=\"#Example-1\" class=\"headerlink\" title=\"Example\"></a>Example</h4><p>创建一个Volume myvol，挂载到容器的/app上</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d \\</span><br><span class=\"line\">  --name devtest0 \\</span><br><span class=\"line\">  --mount source=myvol,target=/app \\</span><br><span class=\"line\">  nginx:latest</span><br></pre></td></tr></table></figure>\n\n<p>验证Volume持久化和共享功能：</p>\n<p>进入devtest0的/app，创建一些文件</p>\n<p>新开一个容器devtest1，执行相同命令，发现/app仍然有数据，验证了Volume的持久化功能。</p>\n","site":{"data":{}},"cover":"/images/dota2Img.jpeg","excerpt":"","more":"<h1 id=\"Docker-Mount\"><a href=\"#Docker-Mount\" class=\"headerlink\" title=\"Docker Mount\"></a>Docker Mount</h1><p>Docker 提供三种挂载技术：</p>\n<ol>\n<li>bind mount</li>\n<li>volume，</li>\n<li>tmpfs</li>\n</ol>\n<p>使用<code>--mount</code>或<code>-v</code>参数进行mount，<code>--mount</code>和<code>-v</code>唯一不同的地方在于：</p>\n<ul>\n<li>如果src不存在，<code>-v</code>会自动创建，而<code>--mount</code>则不会自动创建并抛出错误</li>\n</ul>\n<h2 id=\"1-Bind-mount\"><a href=\"#1-Bind-mount\" class=\"headerlink\" title=\"1. Bind mount\"></a>1. Bind mount</h2><p>bind mount通常用于本地更新代码</p>\n<h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>以下命令把宿主机的pwd/target挂载到容器的/app目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d \\</span><br><span class=\"line\">  -it \\</span><br><span class=\"line\">  --name devtest \\</span><br><span class=\"line\">  --mount type=bind,source=&quot;$(pwd)&quot;/target,target=/app \\</span><br><span class=\"line\">  nginx:latest</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"2-Volume（recommend）\"><a href=\"#2-Volume（recommend）\" class=\"headerlink\" title=\"2. Volume（recommend）\"></a>2. Volume（recommend）</h2><p>Docker Volume是一种持久化和数据共享技术，由Docker在host宿主机管理，可以把Volume 挂载（mount）到容器的文件夹上实现持久化功能。</p>\n<ol>\n<li>有了Volume，容器停止后文件数据也可以保存。</li>\n<li>不同容器可以共享同一个Volume</li>\n</ol>\n<h4 id=\"Commands\"><a href=\"#Commands\" class=\"headerlink\" title=\"Commands\"></a>Commands</h4><p>–mount和-v命令相同作用，但在service命令中只能用–mount。</p>\n<ol>\n<li>docker volume ls，查看所有volume</li>\n<li>docker volume create [volume-name]，创建volume</li>\n<li>docker inspect volume-name，查看volume</li>\n<li>–mount source=myvol2,target=/app，挂载volume到某个容器文件路径</li>\n</ol>\n<h4 id=\"Example-1\"><a href=\"#Example-1\" class=\"headerlink\" title=\"Example\"></a>Example</h4><p>创建一个Volume myvol，挂载到容器的/app上</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d \\</span><br><span class=\"line\">  --name devtest0 \\</span><br><span class=\"line\">  --mount source=myvol,target=/app \\</span><br><span class=\"line\">  nginx:latest</span><br></pre></td></tr></table></figure>\n\n<p>验证Volume持久化和共享功能：</p>\n<p>进入devtest0的/app，创建一些文件</p>\n<p>新开一个容器devtest1，执行相同命令，发现/app仍然有数据，验证了Volume的持久化功能。</p>\n"},{"title":"Docker-Network","date":"2022-01-08T06:43:11.000Z","_content":"\n# Docker-Network\n\n构建一个Docker网络，不同容器之间就可以通过某个网络互相访问。\n\n## Command\n\n创建一个网络\n\n`docker network create my-network`\n\n使Redis容器运行在网络中（并给自己IP取别名）\n\n`docker run -d --network --network-alias redis redis:latest`\n\n使web项目运行在网络中（代码中可以通过alias当成ip访问）\n\n`docker run -it -p 8080:8080 --network=test-net webapp`\n\n","source":"_posts/Docker-Network.md","raw":"---\ntitle: Docker-Network\ndate: 2022-01-08 14:43:11\ntags: Docker\n---\n\n# Docker-Network\n\n构建一个Docker网络，不同容器之间就可以通过某个网络互相访问。\n\n## Command\n\n创建一个网络\n\n`docker network create my-network`\n\n使Redis容器运行在网络中（并给自己IP取别名）\n\n`docker run -d --network --network-alias redis redis:latest`\n\n使web项目运行在网络中（代码中可以通过alias当成ip访问）\n\n`docker run -it -p 8080:8080 --network=test-net webapp`\n\n","slug":"Docker-Network","published":1,"updated":"2022-01-08T06:47:59.857Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky5j9fdu000dw3xwe6f50h4j","content":"<h1 id=\"Docker-Network\"><a href=\"#Docker-Network\" class=\"headerlink\" title=\"Docker-Network\"></a>Docker-Network</h1><p>构建一个Docker网络，不同容器之间就可以通过某个网络互相访问。</p>\n<h2 id=\"Command\"><a href=\"#Command\" class=\"headerlink\" title=\"Command\"></a>Command</h2><p>创建一个网络</p>\n<p><code>docker network create my-network</code></p>\n<p>使Redis容器运行在网络中（并给自己IP取别名）</p>\n<p><code>docker run -d --network --network-alias redis redis:latest</code></p>\n<p>使web项目运行在网络中（代码中可以通过alias当成ip访问）</p>\n<p><code>docker run -it -p 8080:8080 --network=test-net webapp</code></p>\n","site":{"data":{}},"cover":"/images/dota2Img.jpeg","excerpt":"","more":"<h1 id=\"Docker-Network\"><a href=\"#Docker-Network\" class=\"headerlink\" title=\"Docker-Network\"></a>Docker-Network</h1><p>构建一个Docker网络，不同容器之间就可以通过某个网络互相访问。</p>\n<h2 id=\"Command\"><a href=\"#Command\" class=\"headerlink\" title=\"Command\"></a>Command</h2><p>创建一个网络</p>\n<p><code>docker network create my-network</code></p>\n<p>使Redis容器运行在网络中（并给自己IP取别名）</p>\n<p><code>docker run -d --network --network-alias redis redis:latest</code></p>\n<p>使web项目运行在网络中（代码中可以通过alias当成ip访问）</p>\n<p><code>docker run -it -p 8080:8080 --network=test-net webapp</code></p>\n"},{"title":"Java-Concurrent","date":"2022-01-08T07:45:18.000Z","_content":"\n# Java高并发学习\n\n[TOC]\n\n## 基本概念\n\n并发：多个任务交替执行\n\n并行：同时执行\n\n临界区：一种公共资源，但是同一时间只能被一个线程访问。\n\n饥饿：线程缺少资源，一直无法执行。\n\n活锁：互相谦让，但还是不能满足执行条件。\n\n### 并发级别\n\n阻塞：得到锁之前，无法执行。\n\n无饥饿：\n\n1. 公平锁\n\n   不会出现饥饿。\n\n2. 非公平锁\n\n   可能出现饥饿。\n\n3. 无障碍\n\n   乐观，并发程度低\n\n   线程之间不会因为临界区的问题被挂起，但检测到冲突就回滚。\n\n4. 无锁\n\n   所有的线程都能访问临界区。cas\n\n### JMM Java内存模型\n\n并发三大特性：\n\n1. 原子性\n\n   一个最小的操作，不会被其他线程干扰。\n\n2. 可见性\n\n   当一个线程修改了共享变量的值，其他线程立即可见。如果不使用volatile，变量则暂存在Java工作内存中，不会立即刷新主存。\n\n3. 有序性\n\n   总结为：在本线程内观察，所有的操作都是有序的；但在一个线程中观察另一个线程，所有的操作都是无序的。\n\n   无序主要体现在**指令重排序**和**工作内存和主存同步延迟**现象。\n\nvolatile关键字保证了有序性，可见性。\n\nsynchronized保证了全部特性。\n\n## 线程的基本操作\n\n1. 新建\n2. 终止 stop\n3. 中断 interrupt\n4. 等待 wait 和通知 notify\n5. （废弃）挂起 suspend和继续执行 resume\n6. 等待线程结束 join 和让出cpu yeild\n\n### 线程的状态\n\n1. 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。\n2. 运行(RUNNABLE)：可运行的，由CPU进行调度运行。\n3. 阻塞(BLOCKED)：synchronized请求锁monitor阻塞。\n4. 等待(WAITING)：object.wati()阻塞等待，需要object.notify()来唤醒。IO。\n5. 超时等待(TIMED_WAITING)：Thread.Sleep()睡眠，超时唤醒，或中断唤醒。\n6. 终止(TERMINATED)：表示该线程已经执行完毕。\n\n## 驻守后台-守护线程Deamon\n\n线程有两种：守护线程，用户线程\n\n正如名字一样，是系统的守护者，在后台守护用户线程。\n\n如果所有用户线程都结束了，那么守护线程会默默退出。\n\n默认创建的是用户线程，不会因main线程的结束而退出。\n\n```java\npublic class TestDeamonThread {\n    public static void main(String[] args) {\n        Thread t = new Thread(new MyRunnable());\n        t.setDaemon(true); // 设置守护线程后，主线程结束，守护线程默默退出\n        t.start();\n    }\n}\n```\n\n## Java并发工具\n\n### Synchronized\n\n- 同步类\n- 同步对象\n- 同步方法\n- 同步静态方法/相当于同步类\n- 同步静态变量/相当于同步类\n\n### Object / 属于管程的实现\n\n只能与Synchronized配合使用\n\n- obj.wait(); 释放锁monitor，阻塞等待notify和获得锁。\n- obj.notify(); 唤醒随机一个因wait()阻塞的对象。\n- obj.notifyAll(); 唤醒所有因wait()阻塞的对象。\n\n## JUT 同步工具\n\n### 可重入锁ReentrantLock\n\n可以反复进入的锁\n\n```Java\nlock.lock();\nlock.lock();\nlock.unlock();\nlock.unlock();\n```\n\n#### 方法：\n\n1. lock(); 锁\n2. tryLock(); 请求锁，失败返回false\n3. tryLock(time, unit) 请求锁，time unit后超时，返回false\n4. lockInterruptibly(); 可中断锁，请求锁时优先响应中断，中断后会放弃请求，并释放已有的锁。\n5. unlock() ; 释放锁\n\n### 可重入锁的好搭档Condition/管程实现\n\n#### 方法\n\n与Object的类似。\n\n- await();\n- signal();\n- signalAll();\n\n### 倒计数器CountDownLatch\n\n倒数计数器latch，数到0释放。\n\n#### 方法\n\n- await();阻塞等待count为0\n- countDown()，count--;\n\n### 循环屏障CyclicBarrier\n\n把线程阻止到屏障外。\n\n#### 方法\n\n- await(); 当n个线程都达到屏障后，各个线程才会继续运行。\n\n### 信号量Semaphore\n\n表示可进入临界区/可获得资源的线程数量。\n\n达到0时，阻塞请求的线程。\n\n#### 方法\n\n- acquire(): 获取，数量-1\n- release(): 释放，数量+1\n\n## 线程池\n\n为了避免系统频繁的创建和销毁线程浪费资源，让创建的线程复用。用空间换时间。\n\n创建线程==》从线程池中获取活跃线程，销毁线程==》把线程还回去。\n\n#### 线程池如何重用？\n\n```java\n// 线程池核心代码：\nstatic final class RunnableAdapter<T> implements Callable<T> {\n  final Runnable task;\n  final T result;\n  RunnableAdapter(Runnable task, T result) {\n    this.task = task;\n    this.result = result;\n  }\n  public T call() {\n    task.run(); // *调用run()方法\n    return result;\n  }\n}\n```\n\n\n\n#### 创建多少线程？\n\n不需要太精确，但是不能过大或过小。需要考虑CPU数量，内存大小等因素。\n\n一般来说，公式：threads = Ncpu * Ucpu * (1 + W / C)\n\n**公式解读：** 重点在于区分任务是IO密集型（W）还是计算密集型（C）：如果是IO密集型，则W很大，所以应该开更多线程；如果是计算密集型，则C很大，所以开更多的线程也没用。\n\n- Ncpu：Cpu数量\n- Ucpu：期望的Cpu使用率\n- W / C： 等待时间与计算时间的比值\n\n### JDK的Executor框架\n\nExecutors是一个线程工厂。通过Executors可以取得一个拥有特定功能的线程池。\n\n#### 工厂方法\n\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads)\npublic static ExecutorService newSingleThreadExecutor()\npublic static ExecutorService newCachedThreadPool()\npublic static ScheduledExecutorService newSingleThreadScheduledExecutor()\npublic static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)\n```\n\n- newFixedThreadPool() ：返回一个固定数量的线程池。有任务提交时，若线程池有空闲线程，立即执行。若无，任务放在队列中，空闲时执行。\n- newSingleThreadExecutor()：只有一个线程的线程池。也有任务队列。\n- newCachedThreadPool()：一个可根据实际情况调整线程数量的线程池。如果全部线程都在工作，有新任务提交时，就创建新线程处理任务。\n- newSingleThreadScheduledExecutor()：线程池大小为1，扩展了延时任务功能。\n- newScheduledThreadPool()：同上，但是可以指定线程池数量\n\n#### 常用方法\n\n- execute()：无返回值的提交\n- submit()：有返回值的提交（异步的概念）\n- shutdown()：不允许提交任务，会立即返回。可以用awaitTermination等待全部任务执行完毕。\n- shutdownNow()：会调用每个线程的interrupt。\n- isTeminated()：是否执行完毕\n\n#### 计划任务\n\n```java\n// 这两类属于计划任务\npublic static ScheduledExecutorService newSingleThreadScheduledExecutor()\npublic static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)\n  // 测试\nScheduledExecutorService executor = Executors.newScheduledThreadPool(10);\n```\n\n计划任务的三个方法：\n\n```java\n// 在给定时间对任务进行调度\npublic ScheduledFuture<?> schedule(Runnable command,\n                                       long delay, TimeUnit unit);\n// 周期性调度，以开始时间为起点，固定频率。\npublic ScheduledFuture<?> scheduleAtFixedRate(Runnable command,\n                                                  long initialDelay,\n                                                  long period,\n                                                  TimeUnit unit);\n// 周期性调度，以上一个任务结束时间为起点，固定频率。\npublic ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,\n                                                     long initialDelay,\n                                                     long delay,\n                                                     TimeUnit unit);\n```\n\n#### 计划任务特例\n\n执行时间超过调度时间会发生什么？\n\n- scheduleAtFixedRate(): 立即执行\n- scheduleWithFixedDelay()：等待调度时间才执行\n\n### 线程池内部实现 ThreadPoolExecutor\n\n```Java\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue) {\n    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n         Executors.defaultThreadFactory(), defaultHandler);\n}\n```\n\n参数解析：\n\n1. corePoolSize 线程数量\n2. maximumPoolSize 最大线程数量\n3. keepAliveTime 当**线程数量**超过**corePoolSize数量**，在多长时间后会被摧毁\n4. unit **keepAliveTime**的时间单位\n5. **workQueue** 任务队列，被提交但尚未执行的任务，使用**BlockingQueue**接口对象\n6. threadFactory 用于创建线程的工厂\n7. **handler** 拒绝策略。任务太多来不及处理，如何拒绝任务\n\n#### 核心参数之间的关系\n\n添加线程：\n\n​\t小于corePoolSize：分配执行\n\n​\t大于corePoolSize：加入任务队列，等待执行\n\n加入任务队列：\n\n​\t看具体任务队列处理办法。\n\n任务队列满了，提交线程池：\n\n​\t创建新线程执行，如果线程总数大于Max，执行拒绝策略。\n\n#### 线程池何时创建线程？\n\n- 线程池创建后，无任何线程，此时每提交一个任务，就会根据线程工厂创建一个线程，直到线程数量等于核心线程数量，提交任务队列处理。\n- 任务队列提交失败后，会创建线程或执行拒绝策略。\n\n#### 任务队列 workQueue\n\n- 直接提交的队列：使用**SynchronousQueue**，新的任务直接提交给线程池。\n- 有界的任务队列：使用**ArrayBlockingQueue**，如果超过队列大小，提交线程池。\n- 无界的任务队列：使用**LinkedBlockingQueue**，除非系统资源耗尽，否则无限入队。\n- 优先任务队列：使用**PriorityBlockingQueue**，可以控制任务的先后执行顺序，是一个特殊的无界队列。\n\n#### 任务队列对应实现\n\n- newFixedThreadPool(int nThreads)\n\n  使用**无界任务队列LinkedBlockingQueue**，corePoolSize可以和maximumPoolSize相等。当线程数到达max时且任务提交非常频繁，任务队列迅速膨胀耗尽资源。\n\n- newSingleThreadExecutor()\n\n  同上，不过max大小为1。\n\n- newCachedThreadPool()\n\n  使用**直接提交队列SynchronousQueue**，corePoolSize为0，为了能直接提交到任务队列，put任务后会立即被take去创建新线程执行。60秒内回收新线程。\n\n  同样，也可能因为大量任务耗尽资源。\n\n#### 拒绝策略 handler\n\n应对超负载。拒绝策略如下：\n\n- **AbortPolicy策略**：直接抛异常，阻止系统正常工作。\n- **CallerRunsPolicy**：在调用者栈中运行当前被丢弃的任务。\n- **DiscardOldestPolicy策略**：丢弃最老的一个任务，并再次提交该任务。\n- **DiscardPolicy**：默默丢弃无法处理的任务。\n\n#### 自定义线程创建：ThreadFactory\n\n线程池是为了线程复用，那么开始的线程从哪来？ThreadFactory\n\n主要用处：设置线程名字、组、优先级、守护线程等信息。\n\n## JDK并发容器\n\njdk提供了一系列线程安全的并发容器。\n\n#### 高并发容器\n\n- ConcurrentHashMap : 线程安全的HashMap\n- CopyOnWriteArrayList: 线程安全的ArrayList，适合读多写少。\n- ConcurrentLinkedListQueue：线程安全的LinkedList\n- BlockingQueue：ArrayBlockingQueue阻塞队列。\n- ConcurrentSkipListMap: 线程安全跳表。\n\n#### 普通线程安全容器\n\n- HashTable\n\n- Vector\n\n- Collections.synchronizedXXX(List/Map)包装的容器\n\n  此方法与HashTable、Vector的线程安全原理相似，都是一律使用Synchronized关键字来实现。\n\n### 阻塞队列 BlockingQueue\n\n阻塞队列接口有许多不同的实现。\n\n- **ArrayBlockingQueue**\n\n  数组实现的阻塞队列。不能扩容。\n\n- **SynchronousQueue**\n\n  一个特殊的阻塞队列，其实并不存放任何数据。put操作要等待take操作，take操作要等待put操作。\n\n- **LinkedBlockingQueue**\n\n  链表实现的阻塞队列。\n\n- **PriorityBlockingQueue**\n\n  带优先级的阻塞队列\n\n## 锁的优化\n\n1. 减少锁持有时间\n\n   只有在必要时进行同步。\n\n2. 减少锁粒度\n\n   分段锁，如ConcurrentHashMap被分为16个段\n\n   运气好的情况下，可以并发16个线程。\n\n   缺点，系统需要全局锁时，消耗增大。如需要取得size()，就要取得所有是分段锁。\n\n3. 用读写分离锁来替换独占锁\n\n   写的时候不能写，读的时候可以读写。如CopyOnWriteArrayList\n\n4. 锁分离\n\n   如LinkedBlockingQueue中，take()操作和put()操作可以并发。只有take()和take()/put()和put()之间存在竞争，所以可以把take()和put()分离。\n\n5. 锁粗化\n\n   如果对同一个锁不停地请求，同步和释放。会浪费宝贵的资源，不利于性能优化。\n\n   ```java\n   for (int i = 0; i < n; i++) {\n     synchronized(lock) {\n       // do sth.\n     }\n   }\n   ```\n\n   应该改成\n\n   ```java\n   synchronized(lock) {  for (int i = 0; i < n; i++) {      // do sth.  } }\n   ```\n\n   把synchronized，锁粗化。\n\n### Java虚拟机锁优化\n\n#### 偏向锁\n\n核心思想：如果一个线程获得一个锁，那么再次请求时，如果锁没有被其他线程获取，就不需要任何同步操作。\n\n- 原理：尝试使用CAS把获取到这个锁的线程ID记录到**锁对象头的标记字段**中，如果锁没有被其他线程获取，那么获取过的线程再次请求锁时，不需要进行任何同步操作。\n- 锁对象头的标记字段：偏向线程ID，偏向时间戳，GC年龄--01\n\n#### 轻量级锁\n\n如果偏向锁失败，虚拟机不会立即挂起线程，会尝试轻量级锁。\n\n- 原理：尝试用CAS将**锁对象头的标记字段**指向一个线程栈中的**锁记录空间**\n\n  如果操作成功，那么该线程获得了锁。\n\n- 锁对象头的标记字段：指向锁记录的指针--00\n\n如果有，顺利进入临界区，否则说明其他线程获得了锁。膨胀为重量级锁。\n\n#### 自旋锁\n\n锁膨胀后，为了避免线程真实地挂起，虚拟机还会做一次努力-自旋。\n\n虚拟会会让当前线程做几个空循环（默认10），循环后如果可以得到锁，那么就进入临界区，否则挂起。\n\n#### 重量级锁\n\nsynchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。\n\nMutex Lock也是通过CAS和挂起等待的操作来实现的，不过这部分由内核处理，Java的锁大部分在用户态实现。\n\n#### 锁消除\n\nJava虚拟机在JIT编译时，会除去不可能存在共享资源竞争的锁。\n\n根据`逃逸分析`技术，判断一个变量是否会逃出某一个作用域。\n\n如果不会，那就不必要加锁。\n\n#### ThreadLocal\n\nThreadLocal:针对某一个线程的全局变量\n\nstacic:全部线程的全局变量\n\n#### 最佳实践\n\n多线程环境中。有一个处理流程，每个流程都需要操作同一个上下文。\n\n最简单的做法是:doSth1(x,x,x,ctx),doSth2(x,x,x,ctx),doSth3(x,x,x,ctx)... 使用参数传递上下文。\n\n错误的做法是：使用static ctx来使ctx变成全局变量。\n\n正确的做法：使用LocalMap使ctx线程隔离。\n\n#### 引用分析\n\n![截屏2020-03-10下午4.52.01](../../../Notes/Java/assets/%25E6%2588%25AA%25E5%25B1%258F2020-03-10%25E4%25B8%258B%25E5%258D%25884.52.01.png)\n\n#### Thread原理\n\n`ThreadLocal`的实现是这样的：每个`Thread` 维护一个 `ThreadLocalMap` ，这个map的 `key` 是 `ThreadLocal`实例本身，`value` 是真正需要存储的对象。\n\n也就是说 `ThreadLocal` 本身并不存储值，它只是作为一个 `key` 来让线程从 `ThreadLocalMap` 获取 `value`。值得注意的是图中的虚线，表示 `ThreadLocalMap` 是使用 `ThreadLocal` 的弱引用作为 `Key` 的，弱引用的对象在 GC 时会被回收。\n\n#### Thread内存泄漏\n\n`ThreadLocalMap`使用`ThreadLocal`的弱引用作为`key`，如果一个`ThreadLocal`没有外部强引用来引用它，那么系统 GC 的时候，这个`ThreadLocal`势必会被回收，这样一来，`ThreadLocalMap`中就会出现`key`为`null`的`Entry`，就没有办法访问这些`key`为`null`的`Entry`的`value`，如果当前线程再迟迟不结束的话，这些`key`为`null`的`Entry`的`value`就会一直存在一条强引用链：`Thread Ref -> Thread -> ThreaLocalMap -> Entry -> value`永远无法回收，造成内存泄漏。\n\n其实，`ThreadLocalMap`的设计中已经考虑到这种情况，也加上了一些防护措施：在`ThreadLocal`的`get()`,`set()`,`remove()`的时候都会清除线程`ThreadLocalMap`里所有`key`为`null`的`value`。\n\n#### 源码分析\n\nset方法：\n\n```java\n// threadLocal的set方法public void set(T value) {  Thread t = Thread.currentThread(); // 获取当前线程  ThreadLocalMap map = getMap(t); // 从当前线程里获取map(这个map是线程私有的)  if (map != null)    map.set(this, value); // 关键点，调用线程私有的map的set方法  else    createMap(t, value);}// 线程私有的map的set方法的关键步骤int i = key.threadLocalHashCode & (len-1); // 除留余数法// 发生hash冲突（原因：一个线程中的ThreadLocal变量太多）// 开地址法，和HashMap相比，HashMap采用的是链地址法for (Entry e = tab[i];     e != null;     e = tab[i = nextIndex(i, len)]) {  ThreadLocal<?> k = e.get();  if (k == key) {    e.value = value;    return;  }  if (k == null) {    replaceStaleEntry(key, value, i);    return;  }}// 最关键的赋值步骤：tab[i] = new Entry(key, value); // key为threadLocal，value是自定义值\n```\n\n#### 常见使用\n\n```java\nThreadLocal<SimpleDateFormat> t = new ThreadLocal<>();\n```\n\n因为SimpleDateFormat.parse()方法不是线程安全的。\n\n因为SimpleDateFormat中的Calendar是线程不安全的。\n\n多个线程之间共享变量calendar，并修改calendar。因此在多线程环境下，当多个线程同时使用相同的SimpleDateFormat对象（如static修饰）的话，如调用format方法时，多个线程会同时调用calender.setTime方法，导致time被别的线程修改，因此线程是不安全的。\n\n#### ThreadLocal原理与实现\n\n每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。\n\n当调用一个 ThreadLocal 的set方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal->value 键值对插入到该 Map 中。\n\n#### ThreadLocal 业务\n\n...\n\n## 无锁\n\n### CAS Compare And Set\n\n原子操作。\n\n比较然后设置。\n\n三个参数:\n\n- 变量V\n- 预期值E\n- 新值N\n\n仅当V等于E时，把V更新为N。否则失败。\n\n这样就保证了只有一个线程可以操作成功。\n\n### 无锁的线程安全整数: AtomicInteger\n\n核心字段：value，valueOffset\n\n- value 保存值\n- valueOffset 保存偏移量，变量在内存中的地址。\n\n通过死循环CAS实现线程安全。\n\n### 无锁的对象引用:AtomicReference\n\n\n\n### 带有时间戳的对象引用：AtomicStampedReference\n\n解决了CAS中不能判断ABA的问题。\n\n加入时间戳参数，只有时间戳也匹配时才更改新值。\n\n### 数组也能无锁：AtomicIntegerArray\n\n## 乐观锁与悲观锁\n\n#### 悲观锁\n\n- synchronized\n- ReentrantLock\n\n#### 乐观锁\n\n- CAS实现\n- 版本号机制实现（MVCC）\n\n## synchronized的使用细节\n\n- 修饰方法：锁实例\n- 修饰静态方法：锁类\n- 修饰对象：锁对象\n\n## Syn和Lock实现原理\n\n### 区别\n\n- 使用synchronized，JVM会有相应的锁优化，（偏向，轻量级，自旋）\n- lock可以是公平锁，synchronized不是公平锁\n- lock有许多好用的特性：trylock、可中断，公平，配合Condition使用。\n\n### 相同点\n\n- 可重入\n\n### 1.synchronized(syn)原理\n\n- 被synchronized修饰的代码块，编译的字节码中会被monitorenter和monitorexit包围。\n- 执行monitorenter时，首先要尝试获取对象的锁。如果获得成功，把锁的计数器加1。相应的，monitorexit会把锁的计数器减1.\n\n### 2. ReentrantLock原理\n\n[美团AQS分析](https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html)仅供参考，内容有误（非公平锁图解出错）\n\n[JUC必知必会](https://juejin.im/post/5e4f3cede51d4526c80e99cf)\n\n- 通过AQS实现\n- 双向链表实现的同步队列\n- Node的waitStatus\n- state操作\n\n### AQS AbstractQueuedSynchronizer\n\n同步队列，JUC工具几乎都是通过**组合AQS**，重写某些方法实现的。\n\n#### AQS核心思想\n\n1. 用CAS尝试改变state，如果成功则获得锁\n2. CAS失败，就加入同步队列，通过同步机制来有序请求锁。\n\n#### 同步机制\n\n\n\n### 锁的维度\n\n- 是否公平\n\n### AQS的三个维度\n\n- 是否**可中断**\n- 是否**超时**\n- 是否**共享**\n\n#### AQS是否可共享：共享模式shareMode，独占模式exclusiveMode\n\n```java\nprivate volatile int state; // 同步状态state\n```\n\n独占模式：state初始为0, state为0时，CAS操作+1，成功则获得锁。\n\n共享模式：state初始为n，每当一个线程获得锁-1，当state为0时阻塞。\n\n#### state操作\n\n- getState\n- setState\n- compareAndSetState\n\n#### 源码解读\n\n尝试获取锁：lock\n\n```java\nfinal void lock() {  // CAS操作state  if (compareAndSetState(0, 1))    // CAS成功，设置独占锁    setExclusiveOwnerThread(Thread.currentThread());   else    // CAS设置state失败，加入同步队列    acquire(1); // 模板方法}\n```\n\n```java\n// acquire模板public final void acquire(int arg) {    if (!tryAcquire(arg) // 再次尝试获取，标记1        &&        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) // 加入队列, 标记2        selfInterrupt();}\n```\n\n1. 再次尝试获取锁，tryAcquire标记1导读：\n\n```java\n// tryAcquire 标记1protected final boolean tryAcquire(int acquires) {  return nonfairTryAcquire(acquires); // 标记1}// 非公平锁的尝试获取//  nonfairTryAcquire 标记1final boolean nonfairTryAcquire(int acquires) {  final Thread current = Thread.currentThread();  int c = getState();  // 如果state为0，再尝试一次CAS获取锁  if (c == 0) {    if (compareAndSetState(0, acquires)) {      setExclusiveOwnerThread(current);      return true; // CAS成功，获得锁    }  }  // 如果自己是当前锁的持有者，重入操作，state++  else if (current == getExclusiveOwnerThread()) {    int nextc = c + acquires;    if (nextc < 0) // overflow      throw new Error(\"Maximum lock count exceeded\");    setState(nextc);    return true;  }  return false; // CAS失败，自己也不是持有者，失败}\n```\n\n2. 加入同步队列，标记2导读\n\n添加到队尾：addWaiter：\n\n```java\n// 主要思想：CAS操作添加节点到同步队列队尾private Node addWaiter(Node mode) {  Node node = new Node(Thread.currentThread(), mode);  Node pred = tail;  if (pred != null) {    node.prev = pred;    // CAS    if (compareAndSetTail(pred, node)) {      pred.next = node;      return node;    }  }  enq(node);  return node;}\n```\n\n2. 在同步队列中自旋请求锁，标记2导读\n\n   在队列中自旋请求锁：acquireQueued：\n\n```java\nfinal boolean acquireQueued(final Node node, int arg) {  boolean failed = true;  try {    boolean interrupted = false;    // 自旋操作，要么获得锁，要么阻塞（防止自旋浪费资源）    for (;;) {      // 获取当前node的前驱      final Node p = node.predecessor();      // 1.如果自己在队列头部，尝试CAS请求锁（和之前一样）      if (p == head && tryAcquire(arg)) {        // 请求锁成功，设置自己为队头        setHead(node);         p.next = null; // help GC，删除自己（因为已经获得锁了）        failed = false;        return interrupted; // 返回      }      // 2. 判断是否需要阻塞（根据waitStatus）      if (shouldParkAfterFailedAcquire(p, node) &&          parkAndCheckInterrupt())        interrupted = true;    }  } finally {    if (failed)      cancelAcquire(node);  }}\n```\n\n`shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())`分析：\n\n```java\n// 靠前驱节点判断是否需要阻塞private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {  int ws = pred.waitStatus; // 前驱节点状态  // 前驱处于唤醒状态  if (ws == Node.SIGNAL)    return true;  // 前驱处于取消状态  if (ws > 0) {    // 把 队列从自己往队头遍历，删除处于取消状态的节点    do {      node.prev = pred = pred.prev;    } while (pred.waitStatus > 0);    pred.next = node;  } else {    // 设置前驱唤醒    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);  }  return false;}\n```\n\n```java\n// 阻塞当前线程private final boolean parkAndCheckInterrupt() {    LockSupport.park(this);    return Thread.interrupted();}\n```\n\n#### waitStatus枚举表\n\n| 枚举      | 含义                                                         |\n| :-------- | :----------------------------------------------------------- |\n| 0         | 初始化值                                                     |\n| CANCELLED | 1，表示线程获取锁的请求已经取消了                            |\n| SIGNAL    | -1，等待被唤醒了，准备请求锁                                 |\n| CONDITION | -2，在队列中等待                                             |\n| PROPAGATE | -3，当前线程节点的后续节点的acquireShare方法能够被无条件执行 |\n\n\n#### AQS的公平锁与非公平锁实现\n\n主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。\n\n非公平锁：\n\n```java\nfinal void lock() {  // 直接CAS操作上锁  if (compareAndSetState(0, 1))    setExclusiveOwnerThread(Thread.currentThread());  else    acquire(1);}\n```\n\n","source":"_posts/Java-Concurrent.md","raw":"---\ntitle: Java-Concurrent\ndate: 2022-01-08 15:45:18\ntags: Java\n---\n\n# Java高并发学习\n\n[TOC]\n\n## 基本概念\n\n并发：多个任务交替执行\n\n并行：同时执行\n\n临界区：一种公共资源，但是同一时间只能被一个线程访问。\n\n饥饿：线程缺少资源，一直无法执行。\n\n活锁：互相谦让，但还是不能满足执行条件。\n\n### 并发级别\n\n阻塞：得到锁之前，无法执行。\n\n无饥饿：\n\n1. 公平锁\n\n   不会出现饥饿。\n\n2. 非公平锁\n\n   可能出现饥饿。\n\n3. 无障碍\n\n   乐观，并发程度低\n\n   线程之间不会因为临界区的问题被挂起，但检测到冲突就回滚。\n\n4. 无锁\n\n   所有的线程都能访问临界区。cas\n\n### JMM Java内存模型\n\n并发三大特性：\n\n1. 原子性\n\n   一个最小的操作，不会被其他线程干扰。\n\n2. 可见性\n\n   当一个线程修改了共享变量的值，其他线程立即可见。如果不使用volatile，变量则暂存在Java工作内存中，不会立即刷新主存。\n\n3. 有序性\n\n   总结为：在本线程内观察，所有的操作都是有序的；但在一个线程中观察另一个线程，所有的操作都是无序的。\n\n   无序主要体现在**指令重排序**和**工作内存和主存同步延迟**现象。\n\nvolatile关键字保证了有序性，可见性。\n\nsynchronized保证了全部特性。\n\n## 线程的基本操作\n\n1. 新建\n2. 终止 stop\n3. 中断 interrupt\n4. 等待 wait 和通知 notify\n5. （废弃）挂起 suspend和继续执行 resume\n6. 等待线程结束 join 和让出cpu yeild\n\n### 线程的状态\n\n1. 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。\n2. 运行(RUNNABLE)：可运行的，由CPU进行调度运行。\n3. 阻塞(BLOCKED)：synchronized请求锁monitor阻塞。\n4. 等待(WAITING)：object.wati()阻塞等待，需要object.notify()来唤醒。IO。\n5. 超时等待(TIMED_WAITING)：Thread.Sleep()睡眠，超时唤醒，或中断唤醒。\n6. 终止(TERMINATED)：表示该线程已经执行完毕。\n\n## 驻守后台-守护线程Deamon\n\n线程有两种：守护线程，用户线程\n\n正如名字一样，是系统的守护者，在后台守护用户线程。\n\n如果所有用户线程都结束了，那么守护线程会默默退出。\n\n默认创建的是用户线程，不会因main线程的结束而退出。\n\n```java\npublic class TestDeamonThread {\n    public static void main(String[] args) {\n        Thread t = new Thread(new MyRunnable());\n        t.setDaemon(true); // 设置守护线程后，主线程结束，守护线程默默退出\n        t.start();\n    }\n}\n```\n\n## Java并发工具\n\n### Synchronized\n\n- 同步类\n- 同步对象\n- 同步方法\n- 同步静态方法/相当于同步类\n- 同步静态变量/相当于同步类\n\n### Object / 属于管程的实现\n\n只能与Synchronized配合使用\n\n- obj.wait(); 释放锁monitor，阻塞等待notify和获得锁。\n- obj.notify(); 唤醒随机一个因wait()阻塞的对象。\n- obj.notifyAll(); 唤醒所有因wait()阻塞的对象。\n\n## JUT 同步工具\n\n### 可重入锁ReentrantLock\n\n可以反复进入的锁\n\n```Java\nlock.lock();\nlock.lock();\nlock.unlock();\nlock.unlock();\n```\n\n#### 方法：\n\n1. lock(); 锁\n2. tryLock(); 请求锁，失败返回false\n3. tryLock(time, unit) 请求锁，time unit后超时，返回false\n4. lockInterruptibly(); 可中断锁，请求锁时优先响应中断，中断后会放弃请求，并释放已有的锁。\n5. unlock() ; 释放锁\n\n### 可重入锁的好搭档Condition/管程实现\n\n#### 方法\n\n与Object的类似。\n\n- await();\n- signal();\n- signalAll();\n\n### 倒计数器CountDownLatch\n\n倒数计数器latch，数到0释放。\n\n#### 方法\n\n- await();阻塞等待count为0\n- countDown()，count--;\n\n### 循环屏障CyclicBarrier\n\n把线程阻止到屏障外。\n\n#### 方法\n\n- await(); 当n个线程都达到屏障后，各个线程才会继续运行。\n\n### 信号量Semaphore\n\n表示可进入临界区/可获得资源的线程数量。\n\n达到0时，阻塞请求的线程。\n\n#### 方法\n\n- acquire(): 获取，数量-1\n- release(): 释放，数量+1\n\n## 线程池\n\n为了避免系统频繁的创建和销毁线程浪费资源，让创建的线程复用。用空间换时间。\n\n创建线程==》从线程池中获取活跃线程，销毁线程==》把线程还回去。\n\n#### 线程池如何重用？\n\n```java\n// 线程池核心代码：\nstatic final class RunnableAdapter<T> implements Callable<T> {\n  final Runnable task;\n  final T result;\n  RunnableAdapter(Runnable task, T result) {\n    this.task = task;\n    this.result = result;\n  }\n  public T call() {\n    task.run(); // *调用run()方法\n    return result;\n  }\n}\n```\n\n\n\n#### 创建多少线程？\n\n不需要太精确，但是不能过大或过小。需要考虑CPU数量，内存大小等因素。\n\n一般来说，公式：threads = Ncpu * Ucpu * (1 + W / C)\n\n**公式解读：** 重点在于区分任务是IO密集型（W）还是计算密集型（C）：如果是IO密集型，则W很大，所以应该开更多线程；如果是计算密集型，则C很大，所以开更多的线程也没用。\n\n- Ncpu：Cpu数量\n- Ucpu：期望的Cpu使用率\n- W / C： 等待时间与计算时间的比值\n\n### JDK的Executor框架\n\nExecutors是一个线程工厂。通过Executors可以取得一个拥有特定功能的线程池。\n\n#### 工厂方法\n\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads)\npublic static ExecutorService newSingleThreadExecutor()\npublic static ExecutorService newCachedThreadPool()\npublic static ScheduledExecutorService newSingleThreadScheduledExecutor()\npublic static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)\n```\n\n- newFixedThreadPool() ：返回一个固定数量的线程池。有任务提交时，若线程池有空闲线程，立即执行。若无，任务放在队列中，空闲时执行。\n- newSingleThreadExecutor()：只有一个线程的线程池。也有任务队列。\n- newCachedThreadPool()：一个可根据实际情况调整线程数量的线程池。如果全部线程都在工作，有新任务提交时，就创建新线程处理任务。\n- newSingleThreadScheduledExecutor()：线程池大小为1，扩展了延时任务功能。\n- newScheduledThreadPool()：同上，但是可以指定线程池数量\n\n#### 常用方法\n\n- execute()：无返回值的提交\n- submit()：有返回值的提交（异步的概念）\n- shutdown()：不允许提交任务，会立即返回。可以用awaitTermination等待全部任务执行完毕。\n- shutdownNow()：会调用每个线程的interrupt。\n- isTeminated()：是否执行完毕\n\n#### 计划任务\n\n```java\n// 这两类属于计划任务\npublic static ScheduledExecutorService newSingleThreadScheduledExecutor()\npublic static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)\n  // 测试\nScheduledExecutorService executor = Executors.newScheduledThreadPool(10);\n```\n\n计划任务的三个方法：\n\n```java\n// 在给定时间对任务进行调度\npublic ScheduledFuture<?> schedule(Runnable command,\n                                       long delay, TimeUnit unit);\n// 周期性调度，以开始时间为起点，固定频率。\npublic ScheduledFuture<?> scheduleAtFixedRate(Runnable command,\n                                                  long initialDelay,\n                                                  long period,\n                                                  TimeUnit unit);\n// 周期性调度，以上一个任务结束时间为起点，固定频率。\npublic ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,\n                                                     long initialDelay,\n                                                     long delay,\n                                                     TimeUnit unit);\n```\n\n#### 计划任务特例\n\n执行时间超过调度时间会发生什么？\n\n- scheduleAtFixedRate(): 立即执行\n- scheduleWithFixedDelay()：等待调度时间才执行\n\n### 线程池内部实现 ThreadPoolExecutor\n\n```Java\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue) {\n    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n         Executors.defaultThreadFactory(), defaultHandler);\n}\n```\n\n参数解析：\n\n1. corePoolSize 线程数量\n2. maximumPoolSize 最大线程数量\n3. keepAliveTime 当**线程数量**超过**corePoolSize数量**，在多长时间后会被摧毁\n4. unit **keepAliveTime**的时间单位\n5. **workQueue** 任务队列，被提交但尚未执行的任务，使用**BlockingQueue**接口对象\n6. threadFactory 用于创建线程的工厂\n7. **handler** 拒绝策略。任务太多来不及处理，如何拒绝任务\n\n#### 核心参数之间的关系\n\n添加线程：\n\n​\t小于corePoolSize：分配执行\n\n​\t大于corePoolSize：加入任务队列，等待执行\n\n加入任务队列：\n\n​\t看具体任务队列处理办法。\n\n任务队列满了，提交线程池：\n\n​\t创建新线程执行，如果线程总数大于Max，执行拒绝策略。\n\n#### 线程池何时创建线程？\n\n- 线程池创建后，无任何线程，此时每提交一个任务，就会根据线程工厂创建一个线程，直到线程数量等于核心线程数量，提交任务队列处理。\n- 任务队列提交失败后，会创建线程或执行拒绝策略。\n\n#### 任务队列 workQueue\n\n- 直接提交的队列：使用**SynchronousQueue**，新的任务直接提交给线程池。\n- 有界的任务队列：使用**ArrayBlockingQueue**，如果超过队列大小，提交线程池。\n- 无界的任务队列：使用**LinkedBlockingQueue**，除非系统资源耗尽，否则无限入队。\n- 优先任务队列：使用**PriorityBlockingQueue**，可以控制任务的先后执行顺序，是一个特殊的无界队列。\n\n#### 任务队列对应实现\n\n- newFixedThreadPool(int nThreads)\n\n  使用**无界任务队列LinkedBlockingQueue**，corePoolSize可以和maximumPoolSize相等。当线程数到达max时且任务提交非常频繁，任务队列迅速膨胀耗尽资源。\n\n- newSingleThreadExecutor()\n\n  同上，不过max大小为1。\n\n- newCachedThreadPool()\n\n  使用**直接提交队列SynchronousQueue**，corePoolSize为0，为了能直接提交到任务队列，put任务后会立即被take去创建新线程执行。60秒内回收新线程。\n\n  同样，也可能因为大量任务耗尽资源。\n\n#### 拒绝策略 handler\n\n应对超负载。拒绝策略如下：\n\n- **AbortPolicy策略**：直接抛异常，阻止系统正常工作。\n- **CallerRunsPolicy**：在调用者栈中运行当前被丢弃的任务。\n- **DiscardOldestPolicy策略**：丢弃最老的一个任务，并再次提交该任务。\n- **DiscardPolicy**：默默丢弃无法处理的任务。\n\n#### 自定义线程创建：ThreadFactory\n\n线程池是为了线程复用，那么开始的线程从哪来？ThreadFactory\n\n主要用处：设置线程名字、组、优先级、守护线程等信息。\n\n## JDK并发容器\n\njdk提供了一系列线程安全的并发容器。\n\n#### 高并发容器\n\n- ConcurrentHashMap : 线程安全的HashMap\n- CopyOnWriteArrayList: 线程安全的ArrayList，适合读多写少。\n- ConcurrentLinkedListQueue：线程安全的LinkedList\n- BlockingQueue：ArrayBlockingQueue阻塞队列。\n- ConcurrentSkipListMap: 线程安全跳表。\n\n#### 普通线程安全容器\n\n- HashTable\n\n- Vector\n\n- Collections.synchronizedXXX(List/Map)包装的容器\n\n  此方法与HashTable、Vector的线程安全原理相似，都是一律使用Synchronized关键字来实现。\n\n### 阻塞队列 BlockingQueue\n\n阻塞队列接口有许多不同的实现。\n\n- **ArrayBlockingQueue**\n\n  数组实现的阻塞队列。不能扩容。\n\n- **SynchronousQueue**\n\n  一个特殊的阻塞队列，其实并不存放任何数据。put操作要等待take操作，take操作要等待put操作。\n\n- **LinkedBlockingQueue**\n\n  链表实现的阻塞队列。\n\n- **PriorityBlockingQueue**\n\n  带优先级的阻塞队列\n\n## 锁的优化\n\n1. 减少锁持有时间\n\n   只有在必要时进行同步。\n\n2. 减少锁粒度\n\n   分段锁，如ConcurrentHashMap被分为16个段\n\n   运气好的情况下，可以并发16个线程。\n\n   缺点，系统需要全局锁时，消耗增大。如需要取得size()，就要取得所有是分段锁。\n\n3. 用读写分离锁来替换独占锁\n\n   写的时候不能写，读的时候可以读写。如CopyOnWriteArrayList\n\n4. 锁分离\n\n   如LinkedBlockingQueue中，take()操作和put()操作可以并发。只有take()和take()/put()和put()之间存在竞争，所以可以把take()和put()分离。\n\n5. 锁粗化\n\n   如果对同一个锁不停地请求，同步和释放。会浪费宝贵的资源，不利于性能优化。\n\n   ```java\n   for (int i = 0; i < n; i++) {\n     synchronized(lock) {\n       // do sth.\n     }\n   }\n   ```\n\n   应该改成\n\n   ```java\n   synchronized(lock) {  for (int i = 0; i < n; i++) {      // do sth.  } }\n   ```\n\n   把synchronized，锁粗化。\n\n### Java虚拟机锁优化\n\n#### 偏向锁\n\n核心思想：如果一个线程获得一个锁，那么再次请求时，如果锁没有被其他线程获取，就不需要任何同步操作。\n\n- 原理：尝试使用CAS把获取到这个锁的线程ID记录到**锁对象头的标记字段**中，如果锁没有被其他线程获取，那么获取过的线程再次请求锁时，不需要进行任何同步操作。\n- 锁对象头的标记字段：偏向线程ID，偏向时间戳，GC年龄--01\n\n#### 轻量级锁\n\n如果偏向锁失败，虚拟机不会立即挂起线程，会尝试轻量级锁。\n\n- 原理：尝试用CAS将**锁对象头的标记字段**指向一个线程栈中的**锁记录空间**\n\n  如果操作成功，那么该线程获得了锁。\n\n- 锁对象头的标记字段：指向锁记录的指针--00\n\n如果有，顺利进入临界区，否则说明其他线程获得了锁。膨胀为重量级锁。\n\n#### 自旋锁\n\n锁膨胀后，为了避免线程真实地挂起，虚拟机还会做一次努力-自旋。\n\n虚拟会会让当前线程做几个空循环（默认10），循环后如果可以得到锁，那么就进入临界区，否则挂起。\n\n#### 重量级锁\n\nsynchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。\n\nMutex Lock也是通过CAS和挂起等待的操作来实现的，不过这部分由内核处理，Java的锁大部分在用户态实现。\n\n#### 锁消除\n\nJava虚拟机在JIT编译时，会除去不可能存在共享资源竞争的锁。\n\n根据`逃逸分析`技术，判断一个变量是否会逃出某一个作用域。\n\n如果不会，那就不必要加锁。\n\n#### ThreadLocal\n\nThreadLocal:针对某一个线程的全局变量\n\nstacic:全部线程的全局变量\n\n#### 最佳实践\n\n多线程环境中。有一个处理流程，每个流程都需要操作同一个上下文。\n\n最简单的做法是:doSth1(x,x,x,ctx),doSth2(x,x,x,ctx),doSth3(x,x,x,ctx)... 使用参数传递上下文。\n\n错误的做法是：使用static ctx来使ctx变成全局变量。\n\n正确的做法：使用LocalMap使ctx线程隔离。\n\n#### 引用分析\n\n![截屏2020-03-10下午4.52.01](../../../Notes/Java/assets/%25E6%2588%25AA%25E5%25B1%258F2020-03-10%25E4%25B8%258B%25E5%258D%25884.52.01.png)\n\n#### Thread原理\n\n`ThreadLocal`的实现是这样的：每个`Thread` 维护一个 `ThreadLocalMap` ，这个map的 `key` 是 `ThreadLocal`实例本身，`value` 是真正需要存储的对象。\n\n也就是说 `ThreadLocal` 本身并不存储值，它只是作为一个 `key` 来让线程从 `ThreadLocalMap` 获取 `value`。值得注意的是图中的虚线，表示 `ThreadLocalMap` 是使用 `ThreadLocal` 的弱引用作为 `Key` 的，弱引用的对象在 GC 时会被回收。\n\n#### Thread内存泄漏\n\n`ThreadLocalMap`使用`ThreadLocal`的弱引用作为`key`，如果一个`ThreadLocal`没有外部强引用来引用它，那么系统 GC 的时候，这个`ThreadLocal`势必会被回收，这样一来，`ThreadLocalMap`中就会出现`key`为`null`的`Entry`，就没有办法访问这些`key`为`null`的`Entry`的`value`，如果当前线程再迟迟不结束的话，这些`key`为`null`的`Entry`的`value`就会一直存在一条强引用链：`Thread Ref -> Thread -> ThreaLocalMap -> Entry -> value`永远无法回收，造成内存泄漏。\n\n其实，`ThreadLocalMap`的设计中已经考虑到这种情况，也加上了一些防护措施：在`ThreadLocal`的`get()`,`set()`,`remove()`的时候都会清除线程`ThreadLocalMap`里所有`key`为`null`的`value`。\n\n#### 源码分析\n\nset方法：\n\n```java\n// threadLocal的set方法public void set(T value) {  Thread t = Thread.currentThread(); // 获取当前线程  ThreadLocalMap map = getMap(t); // 从当前线程里获取map(这个map是线程私有的)  if (map != null)    map.set(this, value); // 关键点，调用线程私有的map的set方法  else    createMap(t, value);}// 线程私有的map的set方法的关键步骤int i = key.threadLocalHashCode & (len-1); // 除留余数法// 发生hash冲突（原因：一个线程中的ThreadLocal变量太多）// 开地址法，和HashMap相比，HashMap采用的是链地址法for (Entry e = tab[i];     e != null;     e = tab[i = nextIndex(i, len)]) {  ThreadLocal<?> k = e.get();  if (k == key) {    e.value = value;    return;  }  if (k == null) {    replaceStaleEntry(key, value, i);    return;  }}// 最关键的赋值步骤：tab[i] = new Entry(key, value); // key为threadLocal，value是自定义值\n```\n\n#### 常见使用\n\n```java\nThreadLocal<SimpleDateFormat> t = new ThreadLocal<>();\n```\n\n因为SimpleDateFormat.parse()方法不是线程安全的。\n\n因为SimpleDateFormat中的Calendar是线程不安全的。\n\n多个线程之间共享变量calendar，并修改calendar。因此在多线程环境下，当多个线程同时使用相同的SimpleDateFormat对象（如static修饰）的话，如调用format方法时，多个线程会同时调用calender.setTime方法，导致time被别的线程修改，因此线程是不安全的。\n\n#### ThreadLocal原理与实现\n\n每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。\n\n当调用一个 ThreadLocal 的set方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal->value 键值对插入到该 Map 中。\n\n#### ThreadLocal 业务\n\n...\n\n## 无锁\n\n### CAS Compare And Set\n\n原子操作。\n\n比较然后设置。\n\n三个参数:\n\n- 变量V\n- 预期值E\n- 新值N\n\n仅当V等于E时，把V更新为N。否则失败。\n\n这样就保证了只有一个线程可以操作成功。\n\n### 无锁的线程安全整数: AtomicInteger\n\n核心字段：value，valueOffset\n\n- value 保存值\n- valueOffset 保存偏移量，变量在内存中的地址。\n\n通过死循环CAS实现线程安全。\n\n### 无锁的对象引用:AtomicReference\n\n\n\n### 带有时间戳的对象引用：AtomicStampedReference\n\n解决了CAS中不能判断ABA的问题。\n\n加入时间戳参数，只有时间戳也匹配时才更改新值。\n\n### 数组也能无锁：AtomicIntegerArray\n\n## 乐观锁与悲观锁\n\n#### 悲观锁\n\n- synchronized\n- ReentrantLock\n\n#### 乐观锁\n\n- CAS实现\n- 版本号机制实现（MVCC）\n\n## synchronized的使用细节\n\n- 修饰方法：锁实例\n- 修饰静态方法：锁类\n- 修饰对象：锁对象\n\n## Syn和Lock实现原理\n\n### 区别\n\n- 使用synchronized，JVM会有相应的锁优化，（偏向，轻量级，自旋）\n- lock可以是公平锁，synchronized不是公平锁\n- lock有许多好用的特性：trylock、可中断，公平，配合Condition使用。\n\n### 相同点\n\n- 可重入\n\n### 1.synchronized(syn)原理\n\n- 被synchronized修饰的代码块，编译的字节码中会被monitorenter和monitorexit包围。\n- 执行monitorenter时，首先要尝试获取对象的锁。如果获得成功，把锁的计数器加1。相应的，monitorexit会把锁的计数器减1.\n\n### 2. ReentrantLock原理\n\n[美团AQS分析](https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html)仅供参考，内容有误（非公平锁图解出错）\n\n[JUC必知必会](https://juejin.im/post/5e4f3cede51d4526c80e99cf)\n\n- 通过AQS实现\n- 双向链表实现的同步队列\n- Node的waitStatus\n- state操作\n\n### AQS AbstractQueuedSynchronizer\n\n同步队列，JUC工具几乎都是通过**组合AQS**，重写某些方法实现的。\n\n#### AQS核心思想\n\n1. 用CAS尝试改变state，如果成功则获得锁\n2. CAS失败，就加入同步队列，通过同步机制来有序请求锁。\n\n#### 同步机制\n\n\n\n### 锁的维度\n\n- 是否公平\n\n### AQS的三个维度\n\n- 是否**可中断**\n- 是否**超时**\n- 是否**共享**\n\n#### AQS是否可共享：共享模式shareMode，独占模式exclusiveMode\n\n```java\nprivate volatile int state; // 同步状态state\n```\n\n独占模式：state初始为0, state为0时，CAS操作+1，成功则获得锁。\n\n共享模式：state初始为n，每当一个线程获得锁-1，当state为0时阻塞。\n\n#### state操作\n\n- getState\n- setState\n- compareAndSetState\n\n#### 源码解读\n\n尝试获取锁：lock\n\n```java\nfinal void lock() {  // CAS操作state  if (compareAndSetState(0, 1))    // CAS成功，设置独占锁    setExclusiveOwnerThread(Thread.currentThread());   else    // CAS设置state失败，加入同步队列    acquire(1); // 模板方法}\n```\n\n```java\n// acquire模板public final void acquire(int arg) {    if (!tryAcquire(arg) // 再次尝试获取，标记1        &&        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) // 加入队列, 标记2        selfInterrupt();}\n```\n\n1. 再次尝试获取锁，tryAcquire标记1导读：\n\n```java\n// tryAcquire 标记1protected final boolean tryAcquire(int acquires) {  return nonfairTryAcquire(acquires); // 标记1}// 非公平锁的尝试获取//  nonfairTryAcquire 标记1final boolean nonfairTryAcquire(int acquires) {  final Thread current = Thread.currentThread();  int c = getState();  // 如果state为0，再尝试一次CAS获取锁  if (c == 0) {    if (compareAndSetState(0, acquires)) {      setExclusiveOwnerThread(current);      return true; // CAS成功，获得锁    }  }  // 如果自己是当前锁的持有者，重入操作，state++  else if (current == getExclusiveOwnerThread()) {    int nextc = c + acquires;    if (nextc < 0) // overflow      throw new Error(\"Maximum lock count exceeded\");    setState(nextc);    return true;  }  return false; // CAS失败，自己也不是持有者，失败}\n```\n\n2. 加入同步队列，标记2导读\n\n添加到队尾：addWaiter：\n\n```java\n// 主要思想：CAS操作添加节点到同步队列队尾private Node addWaiter(Node mode) {  Node node = new Node(Thread.currentThread(), mode);  Node pred = tail;  if (pred != null) {    node.prev = pred;    // CAS    if (compareAndSetTail(pred, node)) {      pred.next = node;      return node;    }  }  enq(node);  return node;}\n```\n\n2. 在同步队列中自旋请求锁，标记2导读\n\n   在队列中自旋请求锁：acquireQueued：\n\n```java\nfinal boolean acquireQueued(final Node node, int arg) {  boolean failed = true;  try {    boolean interrupted = false;    // 自旋操作，要么获得锁，要么阻塞（防止自旋浪费资源）    for (;;) {      // 获取当前node的前驱      final Node p = node.predecessor();      // 1.如果自己在队列头部，尝试CAS请求锁（和之前一样）      if (p == head && tryAcquire(arg)) {        // 请求锁成功，设置自己为队头        setHead(node);         p.next = null; // help GC，删除自己（因为已经获得锁了）        failed = false;        return interrupted; // 返回      }      // 2. 判断是否需要阻塞（根据waitStatus）      if (shouldParkAfterFailedAcquire(p, node) &&          parkAndCheckInterrupt())        interrupted = true;    }  } finally {    if (failed)      cancelAcquire(node);  }}\n```\n\n`shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())`分析：\n\n```java\n// 靠前驱节点判断是否需要阻塞private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {  int ws = pred.waitStatus; // 前驱节点状态  // 前驱处于唤醒状态  if (ws == Node.SIGNAL)    return true;  // 前驱处于取消状态  if (ws > 0) {    // 把 队列从自己往队头遍历，删除处于取消状态的节点    do {      node.prev = pred = pred.prev;    } while (pred.waitStatus > 0);    pred.next = node;  } else {    // 设置前驱唤醒    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);  }  return false;}\n```\n\n```java\n// 阻塞当前线程private final boolean parkAndCheckInterrupt() {    LockSupport.park(this);    return Thread.interrupted();}\n```\n\n#### waitStatus枚举表\n\n| 枚举      | 含义                                                         |\n| :-------- | :----------------------------------------------------------- |\n| 0         | 初始化值                                                     |\n| CANCELLED | 1，表示线程获取锁的请求已经取消了                            |\n| SIGNAL    | -1，等待被唤醒了，准备请求锁                                 |\n| CONDITION | -2，在队列中等待                                             |\n| PROPAGATE | -3，当前线程节点的后续节点的acquireShare方法能够被无条件执行 |\n\n\n#### AQS的公平锁与非公平锁实现\n\n主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。\n\n非公平锁：\n\n```java\nfinal void lock() {  // 直接CAS操作上锁  if (compareAndSetState(0, 1))    setExclusiveOwnerThread(Thread.currentThread());  else    acquire(1);}\n```\n\n","slug":"Java-Concurrent","published":1,"updated":"2022-01-08T07:46:17.256Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky5j9fdv000fw3xwcqun1ljm","content":"<h1 id=\"Java高并发学习\"><a href=\"#Java高并发学习\" class=\"headerlink\" title=\"Java高并发学习\"></a>Java高并发学习</h1><p>[TOC]</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>并发：多个任务交替执行</p>\n<p>并行：同时执行</p>\n<p>临界区：一种公共资源，但是同一时间只能被一个线程访问。</p>\n<p>饥饿：线程缺少资源，一直无法执行。</p>\n<p>活锁：互相谦让，但还是不能满足执行条件。</p>\n<h3 id=\"并发级别\"><a href=\"#并发级别\" class=\"headerlink\" title=\"并发级别\"></a>并发级别</h3><p>阻塞：得到锁之前，无法执行。</p>\n<p>无饥饿：</p>\n<ol>\n<li><p>公平锁</p>\n<p>不会出现饥饿。</p>\n</li>\n<li><p>非公平锁</p>\n<p>可能出现饥饿。</p>\n</li>\n<li><p>无障碍</p>\n<p>乐观，并发程度低</p>\n<p>线程之间不会因为临界区的问题被挂起，但检测到冲突就回滚。</p>\n</li>\n<li><p>无锁</p>\n<p>所有的线程都能访问临界区。cas</p>\n</li>\n</ol>\n<h3 id=\"JMM-Java内存模型\"><a href=\"#JMM-Java内存模型\" class=\"headerlink\" title=\"JMM Java内存模型\"></a>JMM Java内存模型</h3><p>并发三大特性：</p>\n<ol>\n<li><p>原子性</p>\n<p>一个最小的操作，不会被其他线程干扰。</p>\n</li>\n<li><p>可见性</p>\n<p>当一个线程修改了共享变量的值，其他线程立即可见。如果不使用volatile，变量则暂存在Java工作内存中，不会立即刷新主存。</p>\n</li>\n<li><p>有序性</p>\n<p>总结为：在本线程内观察，所有的操作都是有序的；但在一个线程中观察另一个线程，所有的操作都是无序的。</p>\n<p>无序主要体现在<strong>指令重排序</strong>和<strong>工作内存和主存同步延迟</strong>现象。</p>\n</li>\n</ol>\n<p>volatile关键字保证了有序性，可见性。</p>\n<p>synchronized保证了全部特性。</p>\n<h2 id=\"线程的基本操作\"><a href=\"#线程的基本操作\" class=\"headerlink\" title=\"线程的基本操作\"></a>线程的基本操作</h2><ol>\n<li>新建</li>\n<li>终止 stop</li>\n<li>中断 interrupt</li>\n<li>等待 wait 和通知 notify</li>\n<li>（废弃）挂起 suspend和继续执行 resume</li>\n<li>等待线程结束 join 和让出cpu yeild</li>\n</ol>\n<h3 id=\"线程的状态\"><a href=\"#线程的状态\" class=\"headerlink\" title=\"线程的状态\"></a>线程的状态</h3><ol>\n<li>初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。</li>\n<li>运行(RUNNABLE)：可运行的，由CPU进行调度运行。</li>\n<li>阻塞(BLOCKED)：synchronized请求锁monitor阻塞。</li>\n<li>等待(WAITING)：object.wati()阻塞等待，需要object.notify()来唤醒。IO。</li>\n<li>超时等待(TIMED_WAITING)：Thread.Sleep()睡眠，超时唤醒，或中断唤醒。</li>\n<li>终止(TERMINATED)：表示该线程已经执行完毕。</li>\n</ol>\n<h2 id=\"驻守后台-守护线程Deamon\"><a href=\"#驻守后台-守护线程Deamon\" class=\"headerlink\" title=\"驻守后台-守护线程Deamon\"></a>驻守后台-守护线程Deamon</h2><p>线程有两种：守护线程，用户线程</p>\n<p>正如名字一样，是系统的守护者，在后台守护用户线程。</p>\n<p>如果所有用户线程都结束了，那么守护线程会默默退出。</p>\n<p>默认创建的是用户线程，不会因main线程的结束而退出。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestDeamonThread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread t = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> MyRunnable());</span><br><span class=\"line\">        t.setDaemon(<span class=\"keyword\">true</span>); <span class=\"comment\">// 设置守护线程后，主线程结束，守护线程默默退出</span></span><br><span class=\"line\">        t.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Java并发工具\"><a href=\"#Java并发工具\" class=\"headerlink\" title=\"Java并发工具\"></a>Java并发工具</h2><h3 id=\"Synchronized\"><a href=\"#Synchronized\" class=\"headerlink\" title=\"Synchronized\"></a>Synchronized</h3><ul>\n<li>同步类</li>\n<li>同步对象</li>\n<li>同步方法</li>\n<li>同步静态方法/相当于同步类</li>\n<li>同步静态变量/相当于同步类</li>\n</ul>\n<h3 id=\"Object-属于管程的实现\"><a href=\"#Object-属于管程的实现\" class=\"headerlink\" title=\"Object / 属于管程的实现\"></a>Object / 属于管程的实现</h3><p>只能与Synchronized配合使用</p>\n<ul>\n<li>obj.wait(); 释放锁monitor，阻塞等待notify和获得锁。</li>\n<li>obj.notify(); 唤醒随机一个因wait()阻塞的对象。</li>\n<li>obj.notifyAll(); 唤醒所有因wait()阻塞的对象。</li>\n</ul>\n<h2 id=\"JUT-同步工具\"><a href=\"#JUT-同步工具\" class=\"headerlink\" title=\"JUT 同步工具\"></a>JUT 同步工具</h2><h3 id=\"可重入锁ReentrantLock\"><a href=\"#可重入锁ReentrantLock\" class=\"headerlink\" title=\"可重入锁ReentrantLock\"></a>可重入锁ReentrantLock</h3><p>可以反复进入的锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock.lock();</span><br><span class=\"line\">lock.lock();</span><br><span class=\"line\">lock.unlock();</span><br><span class=\"line\">lock.unlock();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法：\"><a href=\"#方法：\" class=\"headerlink\" title=\"方法：\"></a>方法：</h4><ol>\n<li>lock(); 锁</li>\n<li>tryLock(); 请求锁，失败返回false</li>\n<li>tryLock(time, unit) 请求锁，time unit后超时，返回false</li>\n<li>lockInterruptibly(); 可中断锁，请求锁时优先响应中断，中断后会放弃请求，并释放已有的锁。</li>\n<li>unlock() ; 释放锁</li>\n</ol>\n<h3 id=\"可重入锁的好搭档Condition-管程实现\"><a href=\"#可重入锁的好搭档Condition-管程实现\" class=\"headerlink\" title=\"可重入锁的好搭档Condition/管程实现\"></a>可重入锁的好搭档Condition/管程实现</h3><h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><p>与Object的类似。</p>\n<ul>\n<li>await();</li>\n<li>signal();</li>\n<li>signalAll();</li>\n</ul>\n<h3 id=\"倒计数器CountDownLatch\"><a href=\"#倒计数器CountDownLatch\" class=\"headerlink\" title=\"倒计数器CountDownLatch\"></a>倒计数器CountDownLatch</h3><p>倒数计数器latch，数到0释放。</p>\n<h4 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h4><ul>\n<li>await();阻塞等待count为0</li>\n<li>countDown()，count–;</li>\n</ul>\n<h3 id=\"循环屏障CyclicBarrier\"><a href=\"#循环屏障CyclicBarrier\" class=\"headerlink\" title=\"循环屏障CyclicBarrier\"></a>循环屏障CyclicBarrier</h3><p>把线程阻止到屏障外。</p>\n<h4 id=\"方法-2\"><a href=\"#方法-2\" class=\"headerlink\" title=\"方法\"></a>方法</h4><ul>\n<li>await(); 当n个线程都达到屏障后，各个线程才会继续运行。</li>\n</ul>\n<h3 id=\"信号量Semaphore\"><a href=\"#信号量Semaphore\" class=\"headerlink\" title=\"信号量Semaphore\"></a>信号量Semaphore</h3><p>表示可进入临界区/可获得资源的线程数量。</p>\n<p>达到0时，阻塞请求的线程。</p>\n<h4 id=\"方法-3\"><a href=\"#方法-3\" class=\"headerlink\" title=\"方法\"></a>方法</h4><ul>\n<li>acquire(): 获取，数量-1</li>\n<li>release(): 释放，数量+1</li>\n</ul>\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><p>为了避免系统频繁的创建和销毁线程浪费资源，让创建的线程复用。用空间换时间。</p>\n<p>创建线程==》从线程池中获取活跃线程，销毁线程==》把线程还回去。</p>\n<h4 id=\"线程池如何重用？\"><a href=\"#线程池如何重用？\" class=\"headerlink\" title=\"线程池如何重用？\"></a>线程池如何重用？</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 线程池核心代码：</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RunnableAdapter</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Runnable task;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> T result;</span><br><span class=\"line\">  RunnableAdapter(Runnable task, T result) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task = task;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.result = result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    task.run(); <span class=\"comment\">// *调用run()方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"创建多少线程？\"><a href=\"#创建多少线程？\" class=\"headerlink\" title=\"创建多少线程？\"></a>创建多少线程？</h4><p>不需要太精确，但是不能过大或过小。需要考虑CPU数量，内存大小等因素。</p>\n<p>一般来说，公式：threads = Ncpu * Ucpu * (1 + W / C)</p>\n<p><strong>公式解读：</strong> 重点在于区分任务是IO密集型（W）还是计算密集型（C）：如果是IO密集型，则W很大，所以应该开更多线程；如果是计算密集型，则C很大，所以开更多的线程也没用。</p>\n<ul>\n<li>Ncpu：Cpu数量</li>\n<li>Ucpu：期望的Cpu使用率</li>\n<li>W / C： 等待时间与计算时间的比值</li>\n</ul>\n<h3 id=\"JDK的Executor框架\"><a href=\"#JDK的Executor框架\" class=\"headerlink\" title=\"JDK的Executor框架\"></a>JDK的Executor框架</h3><p>Executors是一个线程工厂。通过Executors可以取得一个拥有特定功能的线程池。</p>\n<h4 id=\"工厂方法\"><a href=\"#工厂方法\" class=\"headerlink\" title=\"工厂方法\"></a>工厂方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newSingleThreadExecutor</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newCachedThreadPool</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ScheduledExecutorService <span class=\"title\">newSingleThreadScheduledExecutor</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ScheduledExecutorService <span class=\"title\">newScheduledThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize)</span></span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>newFixedThreadPool() ：返回一个固定数量的线程池。有任务提交时，若线程池有空闲线程，立即执行。若无，任务放在队列中，空闲时执行。</li>\n<li>newSingleThreadExecutor()：只有一个线程的线程池。也有任务队列。</li>\n<li>newCachedThreadPool()：一个可根据实际情况调整线程数量的线程池。如果全部线程都在工作，有新任务提交时，就创建新线程处理任务。</li>\n<li>newSingleThreadScheduledExecutor()：线程池大小为1，扩展了延时任务功能。</li>\n<li>newScheduledThreadPool()：同上，但是可以指定线程池数量</li>\n</ul>\n<h4 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><ul>\n<li>execute()：无返回值的提交</li>\n<li>submit()：有返回值的提交（异步的概念）</li>\n<li>shutdown()：不允许提交任务，会立即返回。可以用awaitTermination等待全部任务执行完毕。</li>\n<li>shutdownNow()：会调用每个线程的interrupt。</li>\n<li>isTeminated()：是否执行完毕</li>\n</ul>\n<h4 id=\"计划任务\"><a href=\"#计划任务\" class=\"headerlink\" title=\"计划任务\"></a>计划任务</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这两类属于计划任务</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ScheduledExecutorService <span class=\"title\">newSingleThreadScheduledExecutor</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ScheduledExecutorService <span class=\"title\">newScheduledThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize)</span></span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"comment\">// 测试</span></span></span><br><span class=\"line\"><span class=\"function\">ScheduledExecutorService executor </span>= Executors.newScheduledThreadPool(<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n\n<p>计划任务的三个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在给定时间对任务进行调度</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class=\"line\">                                       <span class=\"keyword\">long</span> delay, TimeUnit unit);</span><br><span class=\"line\"><span class=\"comment\">// 周期性调度，以开始时间为起点，固定频率。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class=\"line\">                                                  <span class=\"keyword\">long</span> initialDelay,</span><br><span class=\"line\">                                                  <span class=\"keyword\">long</span> period,</span><br><span class=\"line\">                                                  TimeUnit unit);</span><br><span class=\"line\"><span class=\"comment\">// 周期性调度，以上一个任务结束时间为起点，固定频率。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class=\"line\">                                                     <span class=\"keyword\">long</span> initialDelay,</span><br><span class=\"line\">                                                     <span class=\"keyword\">long</span> delay,</span><br><span class=\"line\">                                                     TimeUnit unit);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"计划任务特例\"><a href=\"#计划任务特例\" class=\"headerlink\" title=\"计划任务特例\"></a>计划任务特例</h4><p>执行时间超过调度时间会发生什么？</p>\n<ul>\n<li>scheduleAtFixedRate(): 立即执行</li>\n<li>scheduleWithFixedDelay()：等待调度时间才执行</li>\n</ul>\n<h3 id=\"线程池内部实现-ThreadPoolExecutor\"><a href=\"#线程池内部实现-ThreadPoolExecutor\" class=\"headerlink\" title=\"线程池内部实现 ThreadPoolExecutor\"></a>线程池内部实现 ThreadPoolExecutor</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                          <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                          <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                          TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class=\"line\">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>参数解析：</p>\n<ol>\n<li>corePoolSize 线程数量</li>\n<li>maximumPoolSize 最大线程数量</li>\n<li>keepAliveTime 当<strong>线程数量</strong>超过<strong>corePoolSize数量</strong>，在多长时间后会被摧毁</li>\n<li>unit <strong>keepAliveTime</strong>的时间单位</li>\n<li><strong>workQueue</strong> 任务队列，被提交但尚未执行的任务，使用<strong>BlockingQueue</strong>接口对象</li>\n<li>threadFactory 用于创建线程的工厂</li>\n<li><strong>handler</strong> 拒绝策略。任务太多来不及处理，如何拒绝任务</li>\n</ol>\n<h4 id=\"核心参数之间的关系\"><a href=\"#核心参数之间的关系\" class=\"headerlink\" title=\"核心参数之间的关系\"></a>核心参数之间的关系</h4><p>添加线程：</p>\n<p>​    小于corePoolSize：分配执行</p>\n<p>​    大于corePoolSize：加入任务队列，等待执行</p>\n<p>加入任务队列：</p>\n<p>​    看具体任务队列处理办法。</p>\n<p>任务队列满了，提交线程池：</p>\n<p>​    创建新线程执行，如果线程总数大于Max，执行拒绝策略。</p>\n<h4 id=\"线程池何时创建线程？\"><a href=\"#线程池何时创建线程？\" class=\"headerlink\" title=\"线程池何时创建线程？\"></a>线程池何时创建线程？</h4><ul>\n<li>线程池创建后，无任何线程，此时每提交一个任务，就会根据线程工厂创建一个线程，直到线程数量等于核心线程数量，提交任务队列处理。</li>\n<li>任务队列提交失败后，会创建线程或执行拒绝策略。</li>\n</ul>\n<h4 id=\"任务队列-workQueue\"><a href=\"#任务队列-workQueue\" class=\"headerlink\" title=\"任务队列 workQueue\"></a>任务队列 workQueue</h4><ul>\n<li>直接提交的队列：使用<strong>SynchronousQueue</strong>，新的任务直接提交给线程池。</li>\n<li>有界的任务队列：使用<strong>ArrayBlockingQueue</strong>，如果超过队列大小，提交线程池。</li>\n<li>无界的任务队列：使用<strong>LinkedBlockingQueue</strong>，除非系统资源耗尽，否则无限入队。</li>\n<li>优先任务队列：使用<strong>PriorityBlockingQueue</strong>，可以控制任务的先后执行顺序，是一个特殊的无界队列。</li>\n</ul>\n<h4 id=\"任务队列对应实现\"><a href=\"#任务队列对应实现\" class=\"headerlink\" title=\"任务队列对应实现\"></a>任务队列对应实现</h4><ul>\n<li><p>newFixedThreadPool(int nThreads)</p>\n<p>使用<strong>无界任务队列LinkedBlockingQueue</strong>，corePoolSize可以和maximumPoolSize相等。当线程数到达max时且任务提交非常频繁，任务队列迅速膨胀耗尽资源。</p>\n</li>\n<li><p>newSingleThreadExecutor()</p>\n<p>同上，不过max大小为1。</p>\n</li>\n<li><p>newCachedThreadPool()</p>\n<p>使用<strong>直接提交队列SynchronousQueue</strong>，corePoolSize为0，为了能直接提交到任务队列，put任务后会立即被take去创建新线程执行。60秒内回收新线程。</p>\n<p>同样，也可能因为大量任务耗尽资源。</p>\n</li>\n</ul>\n<h4 id=\"拒绝策略-handler\"><a href=\"#拒绝策略-handler\" class=\"headerlink\" title=\"拒绝策略 handler\"></a>拒绝策略 handler</h4><p>应对超负载。拒绝策略如下：</p>\n<ul>\n<li><strong>AbortPolicy策略</strong>：直接抛异常，阻止系统正常工作。</li>\n<li><strong>CallerRunsPolicy</strong>：在调用者栈中运行当前被丢弃的任务。</li>\n<li><strong>DiscardOldestPolicy策略</strong>：丢弃最老的一个任务，并再次提交该任务。</li>\n<li><strong>DiscardPolicy</strong>：默默丢弃无法处理的任务。</li>\n</ul>\n<h4 id=\"自定义线程创建：ThreadFactory\"><a href=\"#自定义线程创建：ThreadFactory\" class=\"headerlink\" title=\"自定义线程创建：ThreadFactory\"></a>自定义线程创建：ThreadFactory</h4><p>线程池是为了线程复用，那么开始的线程从哪来？ThreadFactory</p>\n<p>主要用处：设置线程名字、组、优先级、守护线程等信息。</p>\n<h2 id=\"JDK并发容器\"><a href=\"#JDK并发容器\" class=\"headerlink\" title=\"JDK并发容器\"></a>JDK并发容器</h2><p>jdk提供了一系列线程安全的并发容器。</p>\n<h4 id=\"高并发容器\"><a href=\"#高并发容器\" class=\"headerlink\" title=\"高并发容器\"></a>高并发容器</h4><ul>\n<li>ConcurrentHashMap : 线程安全的HashMap</li>\n<li>CopyOnWriteArrayList: 线程安全的ArrayList，适合读多写少。</li>\n<li>ConcurrentLinkedListQueue：线程安全的LinkedList</li>\n<li>BlockingQueue：ArrayBlockingQueue阻塞队列。</li>\n<li>ConcurrentSkipListMap: 线程安全跳表。</li>\n</ul>\n<h4 id=\"普通线程安全容器\"><a href=\"#普通线程安全容器\" class=\"headerlink\" title=\"普通线程安全容器\"></a>普通线程安全容器</h4><ul>\n<li><p>HashTable</p>\n</li>\n<li><p>Vector</p>\n</li>\n<li><p>Collections.synchronizedXXX(List/Map)包装的容器</p>\n<p>此方法与HashTable、Vector的线程安全原理相似，都是一律使用Synchronized关键字来实现。</p>\n</li>\n</ul>\n<h3 id=\"阻塞队列-BlockingQueue\"><a href=\"#阻塞队列-BlockingQueue\" class=\"headerlink\" title=\"阻塞队列 BlockingQueue\"></a>阻塞队列 BlockingQueue</h3><p>阻塞队列接口有许多不同的实现。</p>\n<ul>\n<li><p><strong>ArrayBlockingQueue</strong></p>\n<p>数组实现的阻塞队列。不能扩容。</p>\n</li>\n<li><p><strong>SynchronousQueue</strong></p>\n<p>一个特殊的阻塞队列，其实并不存放任何数据。put操作要等待take操作，take操作要等待put操作。</p>\n</li>\n<li><p><strong>LinkedBlockingQueue</strong></p>\n<p>链表实现的阻塞队列。</p>\n</li>\n<li><p><strong>PriorityBlockingQueue</strong></p>\n<p>带优先级的阻塞队列</p>\n</li>\n</ul>\n<h2 id=\"锁的优化\"><a href=\"#锁的优化\" class=\"headerlink\" title=\"锁的优化\"></a>锁的优化</h2><ol>\n<li><p>减少锁持有时间</p>\n<p>只有在必要时进行同步。</p>\n</li>\n<li><p>减少锁粒度</p>\n<p>分段锁，如ConcurrentHashMap被分为16个段</p>\n<p>运气好的情况下，可以并发16个线程。</p>\n<p>缺点，系统需要全局锁时，消耗增大。如需要取得size()，就要取得所有是分段锁。</p>\n</li>\n<li><p>用读写分离锁来替换独占锁</p>\n<p>写的时候不能写，读的时候可以读写。如CopyOnWriteArrayList</p>\n</li>\n<li><p>锁分离</p>\n<p>如LinkedBlockingQueue中，take()操作和put()操作可以并发。只有take()和take()/put()和put()之间存在竞争，所以可以把take()和put()分离。</p>\n</li>\n<li><p>锁粗化</p>\n<p>如果对同一个锁不停地请求，同步和释放。会浪费宝贵的资源，不利于性能优化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span>(lock) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do sth.</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>应该改成</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(lock) &#123;  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;      <span class=\"comment\">// do sth.  &#125; &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>把synchronized，锁粗化。</p>\n</li>\n</ol>\n<h3 id=\"Java虚拟机锁优化\"><a href=\"#Java虚拟机锁优化\" class=\"headerlink\" title=\"Java虚拟机锁优化\"></a>Java虚拟机锁优化</h3><h4 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a>偏向锁</h4><p>核心思想：如果一个线程获得一个锁，那么再次请求时，如果锁没有被其他线程获取，就不需要任何同步操作。</p>\n<ul>\n<li>原理：尝试使用CAS把获取到这个锁的线程ID记录到<strong>锁对象头的标记字段</strong>中，如果锁没有被其他线程获取，那么获取过的线程再次请求锁时，不需要进行任何同步操作。</li>\n<li>锁对象头的标记字段：偏向线程ID，偏向时间戳，GC年龄–01</li>\n</ul>\n<h4 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h4><p>如果偏向锁失败，虚拟机不会立即挂起线程，会尝试轻量级锁。</p>\n<ul>\n<li><p>原理：尝试用CAS将<strong>锁对象头的标记字段</strong>指向一个线程栈中的<strong>锁记录空间</strong></p>\n<p>如果操作成功，那么该线程获得了锁。</p>\n</li>\n<li><p>锁对象头的标记字段：指向锁记录的指针–00</p>\n</li>\n</ul>\n<p>如果有，顺利进入临界区，否则说明其他线程获得了锁。膨胀为重量级锁。</p>\n<h4 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h4><p>锁膨胀后，为了避免线程真实地挂起，虚拟机还会做一次努力-自旋。</p>\n<p>虚拟会会让当前线程做几个空循环（默认10），循环后如果可以得到锁，那么就进入临界区，否则挂起。</p>\n<h4 id=\"重量级锁\"><a href=\"#重量级锁\" class=\"headerlink\" title=\"重量级锁\"></a>重量级锁</h4><p>synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p>\n<p>Mutex Lock也是通过CAS和挂起等待的操作来实现的，不过这部分由内核处理，Java的锁大部分在用户态实现。</p>\n<h4 id=\"锁消除\"><a href=\"#锁消除\" class=\"headerlink\" title=\"锁消除\"></a>锁消除</h4><p>Java虚拟机在JIT编译时，会除去不可能存在共享资源竞争的锁。</p>\n<p>根据<code>逃逸分析</code>技术，判断一个变量是否会逃出某一个作用域。</p>\n<p>如果不会，那就不必要加锁。</p>\n<h4 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h4><p>ThreadLocal:针对某一个线程的全局变量</p>\n<p>stacic:全部线程的全局变量</p>\n<h4 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h4><p>多线程环境中。有一个处理流程，每个流程都需要操作同一个上下文。</p>\n<p>最简单的做法是:doSth1(x,x,x,ctx),doSth2(x,x,x,ctx),doSth3(x,x,x,ctx)… 使用参数传递上下文。</p>\n<p>错误的做法是：使用static ctx来使ctx变成全局变量。</p>\n<p>正确的做法：使用LocalMap使ctx线程隔离。</p>\n<h4 id=\"引用分析\"><a href=\"#引用分析\" class=\"headerlink\" title=\"引用分析\"></a>引用分析</h4><p><img src=\"../../../Notes/Java/assets/%25E6%2588%25AA%25E5%25B1%258F2020-03-10%25E4%25B8%258B%25E5%258D%25884.52.01.png\" alt=\"截屏2020-03-10下午4.52.01\"></p>\n<h4 id=\"Thread原理\"><a href=\"#Thread原理\" class=\"headerlink\" title=\"Thread原理\"></a>Thread原理</h4><p><code>ThreadLocal</code>的实现是这样的：每个<code>Thread</code> 维护一个 <code>ThreadLocalMap</code> ，这个map的 <code>key</code> 是 <code>ThreadLocal</code>实例本身，<code>value</code> 是真正需要存储的对象。</p>\n<p>也就是说 <code>ThreadLocal</code> 本身并不存储值，它只是作为一个 <code>key</code> 来让线程从 <code>ThreadLocalMap</code> 获取 <code>value</code>。值得注意的是图中的虚线，表示 <code>ThreadLocalMap</code> 是使用 <code>ThreadLocal</code> 的弱引用作为 <code>Key</code> 的，弱引用的对象在 GC 时会被回收。</p>\n<h4 id=\"Thread内存泄漏\"><a href=\"#Thread内存泄漏\" class=\"headerlink\" title=\"Thread内存泄漏\"></a>Thread内存泄漏</h4><p><code>ThreadLocalMap</code>使用<code>ThreadLocal</code>的弱引用作为<code>key</code>，如果一个<code>ThreadLocal</code>没有外部强引用来引用它，那么系统 GC 的时候，这个<code>ThreadLocal</code>势必会被回收，这样一来，<code>ThreadLocalMap</code>中就会出现<code>key</code>为<code>null</code>的<code>Entry</code>，就没有办法访问这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>，如果当前线程再迟迟不结束的话，这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>就会一直存在一条强引用链：<code>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</code>永远无法回收，造成内存泄漏。</p>\n<p>其实，<code>ThreadLocalMap</code>的设计中已经考虑到这种情况，也加上了一些防护措施：在<code>ThreadLocal</code>的<code>get()</code>,<code>set()</code>,<code>remove()</code>的时候都会清除线程<code>ThreadLocalMap</code>里所有<code>key</code>为<code>null</code>的<code>value</code>。</p>\n<h4 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h4><p>set方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// threadLocal的set方法public void set(T value) &#123;  Thread t = Thread.currentThread(); // 获取当前线程  ThreadLocalMap map = getMap(t); // 从当前线程里获取map(这个map是线程私有的)  if (map != null)    map.set(this, value); // 关键点，调用线程私有的map的set方法  else    createMap(t, value);&#125;// 线程私有的map的set方法的关键步骤int i = key.threadLocalHashCode &amp; (len-1); // 除留余数法// 发生hash冲突（原因：一个线程中的ThreadLocal变量太多）// 开地址法，和HashMap相比，HashMap采用的是链地址法for (Entry e = tab[i];     e != null;     e = tab[i = nextIndex(i, len)]) &#123;  ThreadLocal&lt;?&gt; k = e.get();  if (k == key) &#123;    e.value = value;    return;  &#125;  if (k == null) &#123;    replaceStaleEntry(key, value, i);    return;  &#125;&#125;// 最关键的赋值步骤：tab[i] = new Entry(key, value); // key为threadLocal，value是自定义值</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"常见使用\"><a href=\"#常见使用\" class=\"headerlink\" title=\"常见使用\"></a>常见使用</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadLocal&lt;SimpleDateFormat&gt; t = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>因为SimpleDateFormat.parse()方法不是线程安全的。</p>\n<p>因为SimpleDateFormat中的Calendar是线程不安全的。</p>\n<p>多个线程之间共享变量calendar，并修改calendar。因此在多线程环境下，当多个线程同时使用相同的SimpleDateFormat对象（如static修饰）的话，如调用format方法时，多个线程会同时调用calender.setTime方法，导致time被别的线程修改，因此线程是不安全的。</p>\n<h4 id=\"ThreadLocal原理与实现\"><a href=\"#ThreadLocal原理与实现\" class=\"headerlink\" title=\"ThreadLocal原理与实现\"></a>ThreadLocal原理与实现</h4><p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。</p>\n<p>当调用一个 ThreadLocal 的set方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。</p>\n<h4 id=\"ThreadLocal-业务\"><a href=\"#ThreadLocal-业务\" class=\"headerlink\" title=\"ThreadLocal 业务\"></a>ThreadLocal 业务</h4><p>…</p>\n<h2 id=\"无锁\"><a href=\"#无锁\" class=\"headerlink\" title=\"无锁\"></a>无锁</h2><h3 id=\"CAS-Compare-And-Set\"><a href=\"#CAS-Compare-And-Set\" class=\"headerlink\" title=\"CAS Compare And Set\"></a>CAS Compare And Set</h3><p>原子操作。</p>\n<p>比较然后设置。</p>\n<p>三个参数:</p>\n<ul>\n<li>变量V</li>\n<li>预期值E</li>\n<li>新值N</li>\n</ul>\n<p>仅当V等于E时，把V更新为N。否则失败。</p>\n<p>这样就保证了只有一个线程可以操作成功。</p>\n<h3 id=\"无锁的线程安全整数-AtomicInteger\"><a href=\"#无锁的线程安全整数-AtomicInteger\" class=\"headerlink\" title=\"无锁的线程安全整数: AtomicInteger\"></a>无锁的线程安全整数: AtomicInteger</h3><p>核心字段：value，valueOffset</p>\n<ul>\n<li>value 保存值</li>\n<li>valueOffset 保存偏移量，变量在内存中的地址。</li>\n</ul>\n<p>通过死循环CAS实现线程安全。</p>\n<h3 id=\"无锁的对象引用-AtomicReference\"><a href=\"#无锁的对象引用-AtomicReference\" class=\"headerlink\" title=\"无锁的对象引用:AtomicReference\"></a>无锁的对象引用:AtomicReference</h3><h3 id=\"带有时间戳的对象引用：AtomicStampedReference\"><a href=\"#带有时间戳的对象引用：AtomicStampedReference\" class=\"headerlink\" title=\"带有时间戳的对象引用：AtomicStampedReference\"></a>带有时间戳的对象引用：AtomicStampedReference</h3><p>解决了CAS中不能判断ABA的问题。</p>\n<p>加入时间戳参数，只有时间戳也匹配时才更改新值。</p>\n<h3 id=\"数组也能无锁：AtomicIntegerArray\"><a href=\"#数组也能无锁：AtomicIntegerArray\" class=\"headerlink\" title=\"数组也能无锁：AtomicIntegerArray\"></a>数组也能无锁：AtomicIntegerArray</h3><h2 id=\"乐观锁与悲观锁\"><a href=\"#乐观锁与悲观锁\" class=\"headerlink\" title=\"乐观锁与悲观锁\"></a>乐观锁与悲观锁</h2><h4 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h4><ul>\n<li>synchronized</li>\n<li>ReentrantLock</li>\n</ul>\n<h4 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h4><ul>\n<li>CAS实现</li>\n<li>版本号机制实现（MVCC）</li>\n</ul>\n<h2 id=\"synchronized的使用细节\"><a href=\"#synchronized的使用细节\" class=\"headerlink\" title=\"synchronized的使用细节\"></a>synchronized的使用细节</h2><ul>\n<li>修饰方法：锁实例</li>\n<li>修饰静态方法：锁类</li>\n<li>修饰对象：锁对象</li>\n</ul>\n<h2 id=\"Syn和Lock实现原理\"><a href=\"#Syn和Lock实现原理\" class=\"headerlink\" title=\"Syn和Lock实现原理\"></a>Syn和Lock实现原理</h2><h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><ul>\n<li>使用synchronized，JVM会有相应的锁优化，（偏向，轻量级，自旋）</li>\n<li>lock可以是公平锁，synchronized不是公平锁</li>\n<li>lock有许多好用的特性：trylock、可中断，公平，配合Condition使用。</li>\n</ul>\n<h3 id=\"相同点\"><a href=\"#相同点\" class=\"headerlink\" title=\"相同点\"></a>相同点</h3><ul>\n<li>可重入</li>\n</ul>\n<h3 id=\"1-synchronized-syn-原理\"><a href=\"#1-synchronized-syn-原理\" class=\"headerlink\" title=\"1.synchronized(syn)原理\"></a>1.synchronized(syn)原理</h3><ul>\n<li>被synchronized修饰的代码块，编译的字节码中会被monitorenter和monitorexit包围。</li>\n<li>执行monitorenter时，首先要尝试获取对象的锁。如果获得成功，把锁的计数器加1。相应的，monitorexit会把锁的计数器减1.</li>\n</ul>\n<h3 id=\"2-ReentrantLock原理\"><a href=\"#2-ReentrantLock原理\" class=\"headerlink\" title=\"2. ReentrantLock原理\"></a>2. ReentrantLock原理</h3><p><a href=\"https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html\">美团AQS分析</a>仅供参考，内容有误（非公平锁图解出错）</p>\n<p><a href=\"https://juejin.im/post/5e4f3cede51d4526c80e99cf\">JUC必知必会</a></p>\n<ul>\n<li>通过AQS实现</li>\n<li>双向链表实现的同步队列</li>\n<li>Node的waitStatus</li>\n<li>state操作</li>\n</ul>\n<h3 id=\"AQS-AbstractQueuedSynchronizer\"><a href=\"#AQS-AbstractQueuedSynchronizer\" class=\"headerlink\" title=\"AQS AbstractQueuedSynchronizer\"></a>AQS AbstractQueuedSynchronizer</h3><p>同步队列，JUC工具几乎都是通过<strong>组合AQS</strong>，重写某些方法实现的。</p>\n<h4 id=\"AQS核心思想\"><a href=\"#AQS核心思想\" class=\"headerlink\" title=\"AQS核心思想\"></a>AQS核心思想</h4><ol>\n<li>用CAS尝试改变state，如果成功则获得锁</li>\n<li>CAS失败，就加入同步队列，通过同步机制来有序请求锁。</li>\n</ol>\n<h4 id=\"同步机制\"><a href=\"#同步机制\" class=\"headerlink\" title=\"同步机制\"></a>同步机制</h4><h3 id=\"锁的维度\"><a href=\"#锁的维度\" class=\"headerlink\" title=\"锁的维度\"></a>锁的维度</h3><ul>\n<li>是否公平</li>\n</ul>\n<h3 id=\"AQS的三个维度\"><a href=\"#AQS的三个维度\" class=\"headerlink\" title=\"AQS的三个维度\"></a>AQS的三个维度</h3><ul>\n<li>是否<strong>可中断</strong></li>\n<li>是否<strong>超时</strong></li>\n<li>是否<strong>共享</strong></li>\n</ul>\n<h4 id=\"AQS是否可共享：共享模式shareMode，独占模式exclusiveMode\"><a href=\"#AQS是否可共享：共享模式shareMode，独占模式exclusiveMode\" class=\"headerlink\" title=\"AQS是否可共享：共享模式shareMode，独占模式exclusiveMode\"></a>AQS是否可共享：共享模式shareMode，独占模式exclusiveMode</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> state; <span class=\"comment\">// 同步状态state</span></span><br></pre></td></tr></table></figure>\n\n<p>独占模式：state初始为0, state为0时，CAS操作+1，成功则获得锁。</p>\n<p>共享模式：state初始为n，每当一个线程获得锁-1，当state为0时阻塞。</p>\n<h4 id=\"state操作\"><a href=\"#state操作\" class=\"headerlink\" title=\"state操作\"></a>state操作</h4><ul>\n<li>getState</li>\n<li>setState</li>\n<li>compareAndSetState</li>\n</ul>\n<h4 id=\"源码解读\"><a href=\"#源码解读\" class=\"headerlink\" title=\"源码解读\"></a>源码解读</h4><p>尝试获取锁：lock</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;  <span class=\"comment\">// CAS操作state  if (compareAndSetState(0, 1))    // CAS成功，设置独占锁    setExclusiveOwnerThread(Thread.currentThread());   else    // CAS设置state失败，加入同步队列    acquire(1); // 模板方法&#125;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// acquire模板public final void acquire(int arg) &#123;    if (!tryAcquire(arg) // 再次尝试获取，标记1        &amp;&amp;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) // 加入队列, 标记2        selfInterrupt();&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>再次尝试获取锁，tryAcquire标记1导读：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tryAcquire 标记1protected final boolean tryAcquire(int acquires) &#123;  return nonfairTryAcquire(acquires); // 标记1&#125;// 非公平锁的尝试获取//  nonfairTryAcquire 标记1final boolean nonfairTryAcquire(int acquires) &#123;  final Thread current = Thread.currentThread();  int c = getState();  // 如果state为0，再尝试一次CAS获取锁  if (c == 0) &#123;    if (compareAndSetState(0, acquires)) &#123;      setExclusiveOwnerThread(current);      return true; // CAS成功，获得锁    &#125;  &#125;  // 如果自己是当前锁的持有者，重入操作，state++  else if (current == getExclusiveOwnerThread()) &#123;    int nextc = c + acquires;    if (nextc &lt; 0) // overflow      throw new Error(&quot;Maximum lock count exceeded&quot;);    setState(nextc);    return true;  &#125;  return false; // CAS失败，自己也不是持有者，失败&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>加入同步队列，标记2导读</li>\n</ol>\n<p>添加到队尾：addWaiter：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主要思想：CAS操作添加节点到同步队列队尾private Node addWaiter(Node mode) &#123;  Node node = new Node(Thread.currentThread(), mode);  Node pred = tail;  if (pred != null) &#123;    node.prev = pred;    // CAS    if (compareAndSetTail(pred, node)) &#123;      pred.next = node;      return node;    &#125;  &#125;  enq(node);  return node;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>在同步队列中自旋请求锁，标记2导读</p>\n<p>在队列中自旋请求锁：acquireQueued：</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"keyword\">int</span> arg)</span> </span>&#123;  <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;  <span class=\"keyword\">try</span> &#123;    <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;    <span class=\"comment\">// 自旋操作，要么获得锁，要么阻塞（防止自旋浪费资源）    for (;;) &#123;      // 获取当前node的前驱      final Node p = node.predecessor();      // 1.如果自己在队列头部，尝试CAS请求锁（和之前一样）      if (p == head &amp;&amp; tryAcquire(arg)) &#123;        // 请求锁成功，设置自己为队头        setHead(node);         p.next = null; // help GC，删除自己（因为已经获得锁了）        failed = false;        return interrupted; // 返回      &#125;      // 2. 判断是否需要阻塞（根据waitStatus）      if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;          parkAndCheckInterrupt())        interrupted = true;    &#125;  &#125; finally &#123;    if (failed)      cancelAcquire(node);  &#125;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</code>分析：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 靠前驱节点判断是否需要阻塞private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;  int ws = pred.waitStatus; // 前驱节点状态  // 前驱处于唤醒状态  if (ws == Node.SIGNAL)    return true;  // 前驱处于取消状态  if (ws &gt; 0) &#123;    // 把 队列从自己往队头遍历，删除处于取消状态的节点    do &#123;      node.prev = pred = pred.prev;    &#125; while (pred.waitStatus &gt; 0);    pred.next = node;  &#125; else &#123;    // 设置前驱唤醒    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);  &#125;  return false;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 阻塞当前线程private final boolean parkAndCheckInterrupt() &#123;    LockSupport.park(this);    return Thread.interrupted();&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"waitStatus枚举表\"><a href=\"#waitStatus枚举表\" class=\"headerlink\" title=\"waitStatus枚举表\"></a>waitStatus枚举表</h4><table>\n<thead>\n<tr>\n<th align=\"left\">枚举</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0</td>\n<td align=\"left\">初始化值</td>\n</tr>\n<tr>\n<td align=\"left\">CANCELLED</td>\n<td align=\"left\">1，表示线程获取锁的请求已经取消了</td>\n</tr>\n<tr>\n<td align=\"left\">SIGNAL</td>\n<td align=\"left\">-1，等待被唤醒了，准备请求锁</td>\n</tr>\n<tr>\n<td align=\"left\">CONDITION</td>\n<td align=\"left\">-2，在队列中等待</td>\n</tr>\n<tr>\n<td align=\"left\">PROPAGATE</td>\n<td align=\"left\">-3，当前线程节点的后续节点的acquireShare方法能够被无条件执行</td>\n</tr>\n</tbody></table>\n<h4 id=\"AQS的公平锁与非公平锁实现\"><a href=\"#AQS的公平锁与非公平锁实现\" class=\"headerlink\" title=\"AQS的公平锁与非公平锁实现\"></a>AQS的公平锁与非公平锁实现</h4><p>主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</p>\n<p>非公平锁：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;  <span class=\"comment\">// 直接CAS操作上锁  if (compareAndSetState(0, 1))    setExclusiveOwnerThread(Thread.currentThread());  else    acquire(1);&#125;</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"cover":"/images/dota2Img.jpeg","excerpt":"","more":"<h1 id=\"Java高并发学习\"><a href=\"#Java高并发学习\" class=\"headerlink\" title=\"Java高并发学习\"></a>Java高并发学习</h1><p>[TOC]</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>并发：多个任务交替执行</p>\n<p>并行：同时执行</p>\n<p>临界区：一种公共资源，但是同一时间只能被一个线程访问。</p>\n<p>饥饿：线程缺少资源，一直无法执行。</p>\n<p>活锁：互相谦让，但还是不能满足执行条件。</p>\n<h3 id=\"并发级别\"><a href=\"#并发级别\" class=\"headerlink\" title=\"并发级别\"></a>并发级别</h3><p>阻塞：得到锁之前，无法执行。</p>\n<p>无饥饿：</p>\n<ol>\n<li><p>公平锁</p>\n<p>不会出现饥饿。</p>\n</li>\n<li><p>非公平锁</p>\n<p>可能出现饥饿。</p>\n</li>\n<li><p>无障碍</p>\n<p>乐观，并发程度低</p>\n<p>线程之间不会因为临界区的问题被挂起，但检测到冲突就回滚。</p>\n</li>\n<li><p>无锁</p>\n<p>所有的线程都能访问临界区。cas</p>\n</li>\n</ol>\n<h3 id=\"JMM-Java内存模型\"><a href=\"#JMM-Java内存模型\" class=\"headerlink\" title=\"JMM Java内存模型\"></a>JMM Java内存模型</h3><p>并发三大特性：</p>\n<ol>\n<li><p>原子性</p>\n<p>一个最小的操作，不会被其他线程干扰。</p>\n</li>\n<li><p>可见性</p>\n<p>当一个线程修改了共享变量的值，其他线程立即可见。如果不使用volatile，变量则暂存在Java工作内存中，不会立即刷新主存。</p>\n</li>\n<li><p>有序性</p>\n<p>总结为：在本线程内观察，所有的操作都是有序的；但在一个线程中观察另一个线程，所有的操作都是无序的。</p>\n<p>无序主要体现在<strong>指令重排序</strong>和<strong>工作内存和主存同步延迟</strong>现象。</p>\n</li>\n</ol>\n<p>volatile关键字保证了有序性，可见性。</p>\n<p>synchronized保证了全部特性。</p>\n<h2 id=\"线程的基本操作\"><a href=\"#线程的基本操作\" class=\"headerlink\" title=\"线程的基本操作\"></a>线程的基本操作</h2><ol>\n<li>新建</li>\n<li>终止 stop</li>\n<li>中断 interrupt</li>\n<li>等待 wait 和通知 notify</li>\n<li>（废弃）挂起 suspend和继续执行 resume</li>\n<li>等待线程结束 join 和让出cpu yeild</li>\n</ol>\n<h3 id=\"线程的状态\"><a href=\"#线程的状态\" class=\"headerlink\" title=\"线程的状态\"></a>线程的状态</h3><ol>\n<li>初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。</li>\n<li>运行(RUNNABLE)：可运行的，由CPU进行调度运行。</li>\n<li>阻塞(BLOCKED)：synchronized请求锁monitor阻塞。</li>\n<li>等待(WAITING)：object.wati()阻塞等待，需要object.notify()来唤醒。IO。</li>\n<li>超时等待(TIMED_WAITING)：Thread.Sleep()睡眠，超时唤醒，或中断唤醒。</li>\n<li>终止(TERMINATED)：表示该线程已经执行完毕。</li>\n</ol>\n<h2 id=\"驻守后台-守护线程Deamon\"><a href=\"#驻守后台-守护线程Deamon\" class=\"headerlink\" title=\"驻守后台-守护线程Deamon\"></a>驻守后台-守护线程Deamon</h2><p>线程有两种：守护线程，用户线程</p>\n<p>正如名字一样，是系统的守护者，在后台守护用户线程。</p>\n<p>如果所有用户线程都结束了，那么守护线程会默默退出。</p>\n<p>默认创建的是用户线程，不会因main线程的结束而退出。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestDeamonThread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread t = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> MyRunnable());</span><br><span class=\"line\">        t.setDaemon(<span class=\"keyword\">true</span>); <span class=\"comment\">// 设置守护线程后，主线程结束，守护线程默默退出</span></span><br><span class=\"line\">        t.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Java并发工具\"><a href=\"#Java并发工具\" class=\"headerlink\" title=\"Java并发工具\"></a>Java并发工具</h2><h3 id=\"Synchronized\"><a href=\"#Synchronized\" class=\"headerlink\" title=\"Synchronized\"></a>Synchronized</h3><ul>\n<li>同步类</li>\n<li>同步对象</li>\n<li>同步方法</li>\n<li>同步静态方法/相当于同步类</li>\n<li>同步静态变量/相当于同步类</li>\n</ul>\n<h3 id=\"Object-属于管程的实现\"><a href=\"#Object-属于管程的实现\" class=\"headerlink\" title=\"Object / 属于管程的实现\"></a>Object / 属于管程的实现</h3><p>只能与Synchronized配合使用</p>\n<ul>\n<li>obj.wait(); 释放锁monitor，阻塞等待notify和获得锁。</li>\n<li>obj.notify(); 唤醒随机一个因wait()阻塞的对象。</li>\n<li>obj.notifyAll(); 唤醒所有因wait()阻塞的对象。</li>\n</ul>\n<h2 id=\"JUT-同步工具\"><a href=\"#JUT-同步工具\" class=\"headerlink\" title=\"JUT 同步工具\"></a>JUT 同步工具</h2><h3 id=\"可重入锁ReentrantLock\"><a href=\"#可重入锁ReentrantLock\" class=\"headerlink\" title=\"可重入锁ReentrantLock\"></a>可重入锁ReentrantLock</h3><p>可以反复进入的锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock.lock();</span><br><span class=\"line\">lock.lock();</span><br><span class=\"line\">lock.unlock();</span><br><span class=\"line\">lock.unlock();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法：\"><a href=\"#方法：\" class=\"headerlink\" title=\"方法：\"></a>方法：</h4><ol>\n<li>lock(); 锁</li>\n<li>tryLock(); 请求锁，失败返回false</li>\n<li>tryLock(time, unit) 请求锁，time unit后超时，返回false</li>\n<li>lockInterruptibly(); 可中断锁，请求锁时优先响应中断，中断后会放弃请求，并释放已有的锁。</li>\n<li>unlock() ; 释放锁</li>\n</ol>\n<h3 id=\"可重入锁的好搭档Condition-管程实现\"><a href=\"#可重入锁的好搭档Condition-管程实现\" class=\"headerlink\" title=\"可重入锁的好搭档Condition/管程实现\"></a>可重入锁的好搭档Condition/管程实现</h3><h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><p>与Object的类似。</p>\n<ul>\n<li>await();</li>\n<li>signal();</li>\n<li>signalAll();</li>\n</ul>\n<h3 id=\"倒计数器CountDownLatch\"><a href=\"#倒计数器CountDownLatch\" class=\"headerlink\" title=\"倒计数器CountDownLatch\"></a>倒计数器CountDownLatch</h3><p>倒数计数器latch，数到0释放。</p>\n<h4 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h4><ul>\n<li>await();阻塞等待count为0</li>\n<li>countDown()，count–;</li>\n</ul>\n<h3 id=\"循环屏障CyclicBarrier\"><a href=\"#循环屏障CyclicBarrier\" class=\"headerlink\" title=\"循环屏障CyclicBarrier\"></a>循环屏障CyclicBarrier</h3><p>把线程阻止到屏障外。</p>\n<h4 id=\"方法-2\"><a href=\"#方法-2\" class=\"headerlink\" title=\"方法\"></a>方法</h4><ul>\n<li>await(); 当n个线程都达到屏障后，各个线程才会继续运行。</li>\n</ul>\n<h3 id=\"信号量Semaphore\"><a href=\"#信号量Semaphore\" class=\"headerlink\" title=\"信号量Semaphore\"></a>信号量Semaphore</h3><p>表示可进入临界区/可获得资源的线程数量。</p>\n<p>达到0时，阻塞请求的线程。</p>\n<h4 id=\"方法-3\"><a href=\"#方法-3\" class=\"headerlink\" title=\"方法\"></a>方法</h4><ul>\n<li>acquire(): 获取，数量-1</li>\n<li>release(): 释放，数量+1</li>\n</ul>\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><p>为了避免系统频繁的创建和销毁线程浪费资源，让创建的线程复用。用空间换时间。</p>\n<p>创建线程==》从线程池中获取活跃线程，销毁线程==》把线程还回去。</p>\n<h4 id=\"线程池如何重用？\"><a href=\"#线程池如何重用？\" class=\"headerlink\" title=\"线程池如何重用？\"></a>线程池如何重用？</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 线程池核心代码：</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RunnableAdapter</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Runnable task;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> T result;</span><br><span class=\"line\">  RunnableAdapter(Runnable task, T result) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task = task;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.result = result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    task.run(); <span class=\"comment\">// *调用run()方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"创建多少线程？\"><a href=\"#创建多少线程？\" class=\"headerlink\" title=\"创建多少线程？\"></a>创建多少线程？</h4><p>不需要太精确，但是不能过大或过小。需要考虑CPU数量，内存大小等因素。</p>\n<p>一般来说，公式：threads = Ncpu * Ucpu * (1 + W / C)</p>\n<p><strong>公式解读：</strong> 重点在于区分任务是IO密集型（W）还是计算密集型（C）：如果是IO密集型，则W很大，所以应该开更多线程；如果是计算密集型，则C很大，所以开更多的线程也没用。</p>\n<ul>\n<li>Ncpu：Cpu数量</li>\n<li>Ucpu：期望的Cpu使用率</li>\n<li>W / C： 等待时间与计算时间的比值</li>\n</ul>\n<h3 id=\"JDK的Executor框架\"><a href=\"#JDK的Executor框架\" class=\"headerlink\" title=\"JDK的Executor框架\"></a>JDK的Executor框架</h3><p>Executors是一个线程工厂。通过Executors可以取得一个拥有特定功能的线程池。</p>\n<h4 id=\"工厂方法\"><a href=\"#工厂方法\" class=\"headerlink\" title=\"工厂方法\"></a>工厂方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newSingleThreadExecutor</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newCachedThreadPool</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ScheduledExecutorService <span class=\"title\">newSingleThreadScheduledExecutor</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ScheduledExecutorService <span class=\"title\">newScheduledThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize)</span></span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>newFixedThreadPool() ：返回一个固定数量的线程池。有任务提交时，若线程池有空闲线程，立即执行。若无，任务放在队列中，空闲时执行。</li>\n<li>newSingleThreadExecutor()：只有一个线程的线程池。也有任务队列。</li>\n<li>newCachedThreadPool()：一个可根据实际情况调整线程数量的线程池。如果全部线程都在工作，有新任务提交时，就创建新线程处理任务。</li>\n<li>newSingleThreadScheduledExecutor()：线程池大小为1，扩展了延时任务功能。</li>\n<li>newScheduledThreadPool()：同上，但是可以指定线程池数量</li>\n</ul>\n<h4 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><ul>\n<li>execute()：无返回值的提交</li>\n<li>submit()：有返回值的提交（异步的概念）</li>\n<li>shutdown()：不允许提交任务，会立即返回。可以用awaitTermination等待全部任务执行完毕。</li>\n<li>shutdownNow()：会调用每个线程的interrupt。</li>\n<li>isTeminated()：是否执行完毕</li>\n</ul>\n<h4 id=\"计划任务\"><a href=\"#计划任务\" class=\"headerlink\" title=\"计划任务\"></a>计划任务</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这两类属于计划任务</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ScheduledExecutorService <span class=\"title\">newSingleThreadScheduledExecutor</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ScheduledExecutorService <span class=\"title\">newScheduledThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize)</span></span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"comment\">// 测试</span></span></span><br><span class=\"line\"><span class=\"function\">ScheduledExecutorService executor </span>= Executors.newScheduledThreadPool(<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n\n<p>计划任务的三个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在给定时间对任务进行调度</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class=\"line\">                                       <span class=\"keyword\">long</span> delay, TimeUnit unit);</span><br><span class=\"line\"><span class=\"comment\">// 周期性调度，以开始时间为起点，固定频率。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class=\"line\">                                                  <span class=\"keyword\">long</span> initialDelay,</span><br><span class=\"line\">                                                  <span class=\"keyword\">long</span> period,</span><br><span class=\"line\">                                                  TimeUnit unit);</span><br><span class=\"line\"><span class=\"comment\">// 周期性调度，以上一个任务结束时间为起点，固定频率。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class=\"line\">                                                     <span class=\"keyword\">long</span> initialDelay,</span><br><span class=\"line\">                                                     <span class=\"keyword\">long</span> delay,</span><br><span class=\"line\">                                                     TimeUnit unit);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"计划任务特例\"><a href=\"#计划任务特例\" class=\"headerlink\" title=\"计划任务特例\"></a>计划任务特例</h4><p>执行时间超过调度时间会发生什么？</p>\n<ul>\n<li>scheduleAtFixedRate(): 立即执行</li>\n<li>scheduleWithFixedDelay()：等待调度时间才执行</li>\n</ul>\n<h3 id=\"线程池内部实现-ThreadPoolExecutor\"><a href=\"#线程池内部实现-ThreadPoolExecutor\" class=\"headerlink\" title=\"线程池内部实现 ThreadPoolExecutor\"></a>线程池内部实现 ThreadPoolExecutor</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                          <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                          <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                          TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class=\"line\">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>参数解析：</p>\n<ol>\n<li>corePoolSize 线程数量</li>\n<li>maximumPoolSize 最大线程数量</li>\n<li>keepAliveTime 当<strong>线程数量</strong>超过<strong>corePoolSize数量</strong>，在多长时间后会被摧毁</li>\n<li>unit <strong>keepAliveTime</strong>的时间单位</li>\n<li><strong>workQueue</strong> 任务队列，被提交但尚未执行的任务，使用<strong>BlockingQueue</strong>接口对象</li>\n<li>threadFactory 用于创建线程的工厂</li>\n<li><strong>handler</strong> 拒绝策略。任务太多来不及处理，如何拒绝任务</li>\n</ol>\n<h4 id=\"核心参数之间的关系\"><a href=\"#核心参数之间的关系\" class=\"headerlink\" title=\"核心参数之间的关系\"></a>核心参数之间的关系</h4><p>添加线程：</p>\n<p>​    小于corePoolSize：分配执行</p>\n<p>​    大于corePoolSize：加入任务队列，等待执行</p>\n<p>加入任务队列：</p>\n<p>​    看具体任务队列处理办法。</p>\n<p>任务队列满了，提交线程池：</p>\n<p>​    创建新线程执行，如果线程总数大于Max，执行拒绝策略。</p>\n<h4 id=\"线程池何时创建线程？\"><a href=\"#线程池何时创建线程？\" class=\"headerlink\" title=\"线程池何时创建线程？\"></a>线程池何时创建线程？</h4><ul>\n<li>线程池创建后，无任何线程，此时每提交一个任务，就会根据线程工厂创建一个线程，直到线程数量等于核心线程数量，提交任务队列处理。</li>\n<li>任务队列提交失败后，会创建线程或执行拒绝策略。</li>\n</ul>\n<h4 id=\"任务队列-workQueue\"><a href=\"#任务队列-workQueue\" class=\"headerlink\" title=\"任务队列 workQueue\"></a>任务队列 workQueue</h4><ul>\n<li>直接提交的队列：使用<strong>SynchronousQueue</strong>，新的任务直接提交给线程池。</li>\n<li>有界的任务队列：使用<strong>ArrayBlockingQueue</strong>，如果超过队列大小，提交线程池。</li>\n<li>无界的任务队列：使用<strong>LinkedBlockingQueue</strong>，除非系统资源耗尽，否则无限入队。</li>\n<li>优先任务队列：使用<strong>PriorityBlockingQueue</strong>，可以控制任务的先后执行顺序，是一个特殊的无界队列。</li>\n</ul>\n<h4 id=\"任务队列对应实现\"><a href=\"#任务队列对应实现\" class=\"headerlink\" title=\"任务队列对应实现\"></a>任务队列对应实现</h4><ul>\n<li><p>newFixedThreadPool(int nThreads)</p>\n<p>使用<strong>无界任务队列LinkedBlockingQueue</strong>，corePoolSize可以和maximumPoolSize相等。当线程数到达max时且任务提交非常频繁，任务队列迅速膨胀耗尽资源。</p>\n</li>\n<li><p>newSingleThreadExecutor()</p>\n<p>同上，不过max大小为1。</p>\n</li>\n<li><p>newCachedThreadPool()</p>\n<p>使用<strong>直接提交队列SynchronousQueue</strong>，corePoolSize为0，为了能直接提交到任务队列，put任务后会立即被take去创建新线程执行。60秒内回收新线程。</p>\n<p>同样，也可能因为大量任务耗尽资源。</p>\n</li>\n</ul>\n<h4 id=\"拒绝策略-handler\"><a href=\"#拒绝策略-handler\" class=\"headerlink\" title=\"拒绝策略 handler\"></a>拒绝策略 handler</h4><p>应对超负载。拒绝策略如下：</p>\n<ul>\n<li><strong>AbortPolicy策略</strong>：直接抛异常，阻止系统正常工作。</li>\n<li><strong>CallerRunsPolicy</strong>：在调用者栈中运行当前被丢弃的任务。</li>\n<li><strong>DiscardOldestPolicy策略</strong>：丢弃最老的一个任务，并再次提交该任务。</li>\n<li><strong>DiscardPolicy</strong>：默默丢弃无法处理的任务。</li>\n</ul>\n<h4 id=\"自定义线程创建：ThreadFactory\"><a href=\"#自定义线程创建：ThreadFactory\" class=\"headerlink\" title=\"自定义线程创建：ThreadFactory\"></a>自定义线程创建：ThreadFactory</h4><p>线程池是为了线程复用，那么开始的线程从哪来？ThreadFactory</p>\n<p>主要用处：设置线程名字、组、优先级、守护线程等信息。</p>\n<h2 id=\"JDK并发容器\"><a href=\"#JDK并发容器\" class=\"headerlink\" title=\"JDK并发容器\"></a>JDK并发容器</h2><p>jdk提供了一系列线程安全的并发容器。</p>\n<h4 id=\"高并发容器\"><a href=\"#高并发容器\" class=\"headerlink\" title=\"高并发容器\"></a>高并发容器</h4><ul>\n<li>ConcurrentHashMap : 线程安全的HashMap</li>\n<li>CopyOnWriteArrayList: 线程安全的ArrayList，适合读多写少。</li>\n<li>ConcurrentLinkedListQueue：线程安全的LinkedList</li>\n<li>BlockingQueue：ArrayBlockingQueue阻塞队列。</li>\n<li>ConcurrentSkipListMap: 线程安全跳表。</li>\n</ul>\n<h4 id=\"普通线程安全容器\"><a href=\"#普通线程安全容器\" class=\"headerlink\" title=\"普通线程安全容器\"></a>普通线程安全容器</h4><ul>\n<li><p>HashTable</p>\n</li>\n<li><p>Vector</p>\n</li>\n<li><p>Collections.synchronizedXXX(List/Map)包装的容器</p>\n<p>此方法与HashTable、Vector的线程安全原理相似，都是一律使用Synchronized关键字来实现。</p>\n</li>\n</ul>\n<h3 id=\"阻塞队列-BlockingQueue\"><a href=\"#阻塞队列-BlockingQueue\" class=\"headerlink\" title=\"阻塞队列 BlockingQueue\"></a>阻塞队列 BlockingQueue</h3><p>阻塞队列接口有许多不同的实现。</p>\n<ul>\n<li><p><strong>ArrayBlockingQueue</strong></p>\n<p>数组实现的阻塞队列。不能扩容。</p>\n</li>\n<li><p><strong>SynchronousQueue</strong></p>\n<p>一个特殊的阻塞队列，其实并不存放任何数据。put操作要等待take操作，take操作要等待put操作。</p>\n</li>\n<li><p><strong>LinkedBlockingQueue</strong></p>\n<p>链表实现的阻塞队列。</p>\n</li>\n<li><p><strong>PriorityBlockingQueue</strong></p>\n<p>带优先级的阻塞队列</p>\n</li>\n</ul>\n<h2 id=\"锁的优化\"><a href=\"#锁的优化\" class=\"headerlink\" title=\"锁的优化\"></a>锁的优化</h2><ol>\n<li><p>减少锁持有时间</p>\n<p>只有在必要时进行同步。</p>\n</li>\n<li><p>减少锁粒度</p>\n<p>分段锁，如ConcurrentHashMap被分为16个段</p>\n<p>运气好的情况下，可以并发16个线程。</p>\n<p>缺点，系统需要全局锁时，消耗增大。如需要取得size()，就要取得所有是分段锁。</p>\n</li>\n<li><p>用读写分离锁来替换独占锁</p>\n<p>写的时候不能写，读的时候可以读写。如CopyOnWriteArrayList</p>\n</li>\n<li><p>锁分离</p>\n<p>如LinkedBlockingQueue中，take()操作和put()操作可以并发。只有take()和take()/put()和put()之间存在竞争，所以可以把take()和put()分离。</p>\n</li>\n<li><p>锁粗化</p>\n<p>如果对同一个锁不停地请求，同步和释放。会浪费宝贵的资源，不利于性能优化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span>(lock) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do sth.</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>应该改成</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(lock) &#123;  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;      <span class=\"comment\">// do sth.  &#125; &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>把synchronized，锁粗化。</p>\n</li>\n</ol>\n<h3 id=\"Java虚拟机锁优化\"><a href=\"#Java虚拟机锁优化\" class=\"headerlink\" title=\"Java虚拟机锁优化\"></a>Java虚拟机锁优化</h3><h4 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a>偏向锁</h4><p>核心思想：如果一个线程获得一个锁，那么再次请求时，如果锁没有被其他线程获取，就不需要任何同步操作。</p>\n<ul>\n<li>原理：尝试使用CAS把获取到这个锁的线程ID记录到<strong>锁对象头的标记字段</strong>中，如果锁没有被其他线程获取，那么获取过的线程再次请求锁时，不需要进行任何同步操作。</li>\n<li>锁对象头的标记字段：偏向线程ID，偏向时间戳，GC年龄–01</li>\n</ul>\n<h4 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h4><p>如果偏向锁失败，虚拟机不会立即挂起线程，会尝试轻量级锁。</p>\n<ul>\n<li><p>原理：尝试用CAS将<strong>锁对象头的标记字段</strong>指向一个线程栈中的<strong>锁记录空间</strong></p>\n<p>如果操作成功，那么该线程获得了锁。</p>\n</li>\n<li><p>锁对象头的标记字段：指向锁记录的指针–00</p>\n</li>\n</ul>\n<p>如果有，顺利进入临界区，否则说明其他线程获得了锁。膨胀为重量级锁。</p>\n<h4 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h4><p>锁膨胀后，为了避免线程真实地挂起，虚拟机还会做一次努力-自旋。</p>\n<p>虚拟会会让当前线程做几个空循环（默认10），循环后如果可以得到锁，那么就进入临界区，否则挂起。</p>\n<h4 id=\"重量级锁\"><a href=\"#重量级锁\" class=\"headerlink\" title=\"重量级锁\"></a>重量级锁</h4><p>synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p>\n<p>Mutex Lock也是通过CAS和挂起等待的操作来实现的，不过这部分由内核处理，Java的锁大部分在用户态实现。</p>\n<h4 id=\"锁消除\"><a href=\"#锁消除\" class=\"headerlink\" title=\"锁消除\"></a>锁消除</h4><p>Java虚拟机在JIT编译时，会除去不可能存在共享资源竞争的锁。</p>\n<p>根据<code>逃逸分析</code>技术，判断一个变量是否会逃出某一个作用域。</p>\n<p>如果不会，那就不必要加锁。</p>\n<h4 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h4><p>ThreadLocal:针对某一个线程的全局变量</p>\n<p>stacic:全部线程的全局变量</p>\n<h4 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h4><p>多线程环境中。有一个处理流程，每个流程都需要操作同一个上下文。</p>\n<p>最简单的做法是:doSth1(x,x,x,ctx),doSth2(x,x,x,ctx),doSth3(x,x,x,ctx)… 使用参数传递上下文。</p>\n<p>错误的做法是：使用static ctx来使ctx变成全局变量。</p>\n<p>正确的做法：使用LocalMap使ctx线程隔离。</p>\n<h4 id=\"引用分析\"><a href=\"#引用分析\" class=\"headerlink\" title=\"引用分析\"></a>引用分析</h4><p><img src=\"../../../Notes/Java/assets/%25E6%2588%25AA%25E5%25B1%258F2020-03-10%25E4%25B8%258B%25E5%258D%25884.52.01.png\" alt=\"截屏2020-03-10下午4.52.01\"></p>\n<h4 id=\"Thread原理\"><a href=\"#Thread原理\" class=\"headerlink\" title=\"Thread原理\"></a>Thread原理</h4><p><code>ThreadLocal</code>的实现是这样的：每个<code>Thread</code> 维护一个 <code>ThreadLocalMap</code> ，这个map的 <code>key</code> 是 <code>ThreadLocal</code>实例本身，<code>value</code> 是真正需要存储的对象。</p>\n<p>也就是说 <code>ThreadLocal</code> 本身并不存储值，它只是作为一个 <code>key</code> 来让线程从 <code>ThreadLocalMap</code> 获取 <code>value</code>。值得注意的是图中的虚线，表示 <code>ThreadLocalMap</code> 是使用 <code>ThreadLocal</code> 的弱引用作为 <code>Key</code> 的，弱引用的对象在 GC 时会被回收。</p>\n<h4 id=\"Thread内存泄漏\"><a href=\"#Thread内存泄漏\" class=\"headerlink\" title=\"Thread内存泄漏\"></a>Thread内存泄漏</h4><p><code>ThreadLocalMap</code>使用<code>ThreadLocal</code>的弱引用作为<code>key</code>，如果一个<code>ThreadLocal</code>没有外部强引用来引用它，那么系统 GC 的时候，这个<code>ThreadLocal</code>势必会被回收，这样一来，<code>ThreadLocalMap</code>中就会出现<code>key</code>为<code>null</code>的<code>Entry</code>，就没有办法访问这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>，如果当前线程再迟迟不结束的话，这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>就会一直存在一条强引用链：<code>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</code>永远无法回收，造成内存泄漏。</p>\n<p>其实，<code>ThreadLocalMap</code>的设计中已经考虑到这种情况，也加上了一些防护措施：在<code>ThreadLocal</code>的<code>get()</code>,<code>set()</code>,<code>remove()</code>的时候都会清除线程<code>ThreadLocalMap</code>里所有<code>key</code>为<code>null</code>的<code>value</code>。</p>\n<h4 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h4><p>set方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// threadLocal的set方法public void set(T value) &#123;  Thread t = Thread.currentThread(); // 获取当前线程  ThreadLocalMap map = getMap(t); // 从当前线程里获取map(这个map是线程私有的)  if (map != null)    map.set(this, value); // 关键点，调用线程私有的map的set方法  else    createMap(t, value);&#125;// 线程私有的map的set方法的关键步骤int i = key.threadLocalHashCode &amp; (len-1); // 除留余数法// 发生hash冲突（原因：一个线程中的ThreadLocal变量太多）// 开地址法，和HashMap相比，HashMap采用的是链地址法for (Entry e = tab[i];     e != null;     e = tab[i = nextIndex(i, len)]) &#123;  ThreadLocal&lt;?&gt; k = e.get();  if (k == key) &#123;    e.value = value;    return;  &#125;  if (k == null) &#123;    replaceStaleEntry(key, value, i);    return;  &#125;&#125;// 最关键的赋值步骤：tab[i] = new Entry(key, value); // key为threadLocal，value是自定义值</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"常见使用\"><a href=\"#常见使用\" class=\"headerlink\" title=\"常见使用\"></a>常见使用</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadLocal&lt;SimpleDateFormat&gt; t = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>因为SimpleDateFormat.parse()方法不是线程安全的。</p>\n<p>因为SimpleDateFormat中的Calendar是线程不安全的。</p>\n<p>多个线程之间共享变量calendar，并修改calendar。因此在多线程环境下，当多个线程同时使用相同的SimpleDateFormat对象（如static修饰）的话，如调用format方法时，多个线程会同时调用calender.setTime方法，导致time被别的线程修改，因此线程是不安全的。</p>\n<h4 id=\"ThreadLocal原理与实现\"><a href=\"#ThreadLocal原理与实现\" class=\"headerlink\" title=\"ThreadLocal原理与实现\"></a>ThreadLocal原理与实现</h4><p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。</p>\n<p>当调用一个 ThreadLocal 的set方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。</p>\n<h4 id=\"ThreadLocal-业务\"><a href=\"#ThreadLocal-业务\" class=\"headerlink\" title=\"ThreadLocal 业务\"></a>ThreadLocal 业务</h4><p>…</p>\n<h2 id=\"无锁\"><a href=\"#无锁\" class=\"headerlink\" title=\"无锁\"></a>无锁</h2><h3 id=\"CAS-Compare-And-Set\"><a href=\"#CAS-Compare-And-Set\" class=\"headerlink\" title=\"CAS Compare And Set\"></a>CAS Compare And Set</h3><p>原子操作。</p>\n<p>比较然后设置。</p>\n<p>三个参数:</p>\n<ul>\n<li>变量V</li>\n<li>预期值E</li>\n<li>新值N</li>\n</ul>\n<p>仅当V等于E时，把V更新为N。否则失败。</p>\n<p>这样就保证了只有一个线程可以操作成功。</p>\n<h3 id=\"无锁的线程安全整数-AtomicInteger\"><a href=\"#无锁的线程安全整数-AtomicInteger\" class=\"headerlink\" title=\"无锁的线程安全整数: AtomicInteger\"></a>无锁的线程安全整数: AtomicInteger</h3><p>核心字段：value，valueOffset</p>\n<ul>\n<li>value 保存值</li>\n<li>valueOffset 保存偏移量，变量在内存中的地址。</li>\n</ul>\n<p>通过死循环CAS实现线程安全。</p>\n<h3 id=\"无锁的对象引用-AtomicReference\"><a href=\"#无锁的对象引用-AtomicReference\" class=\"headerlink\" title=\"无锁的对象引用:AtomicReference\"></a>无锁的对象引用:AtomicReference</h3><h3 id=\"带有时间戳的对象引用：AtomicStampedReference\"><a href=\"#带有时间戳的对象引用：AtomicStampedReference\" class=\"headerlink\" title=\"带有时间戳的对象引用：AtomicStampedReference\"></a>带有时间戳的对象引用：AtomicStampedReference</h3><p>解决了CAS中不能判断ABA的问题。</p>\n<p>加入时间戳参数，只有时间戳也匹配时才更改新值。</p>\n<h3 id=\"数组也能无锁：AtomicIntegerArray\"><a href=\"#数组也能无锁：AtomicIntegerArray\" class=\"headerlink\" title=\"数组也能无锁：AtomicIntegerArray\"></a>数组也能无锁：AtomicIntegerArray</h3><h2 id=\"乐观锁与悲观锁\"><a href=\"#乐观锁与悲观锁\" class=\"headerlink\" title=\"乐观锁与悲观锁\"></a>乐观锁与悲观锁</h2><h4 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h4><ul>\n<li>synchronized</li>\n<li>ReentrantLock</li>\n</ul>\n<h4 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h4><ul>\n<li>CAS实现</li>\n<li>版本号机制实现（MVCC）</li>\n</ul>\n<h2 id=\"synchronized的使用细节\"><a href=\"#synchronized的使用细节\" class=\"headerlink\" title=\"synchronized的使用细节\"></a>synchronized的使用细节</h2><ul>\n<li>修饰方法：锁实例</li>\n<li>修饰静态方法：锁类</li>\n<li>修饰对象：锁对象</li>\n</ul>\n<h2 id=\"Syn和Lock实现原理\"><a href=\"#Syn和Lock实现原理\" class=\"headerlink\" title=\"Syn和Lock实现原理\"></a>Syn和Lock实现原理</h2><h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><ul>\n<li>使用synchronized，JVM会有相应的锁优化，（偏向，轻量级，自旋）</li>\n<li>lock可以是公平锁，synchronized不是公平锁</li>\n<li>lock有许多好用的特性：trylock、可中断，公平，配合Condition使用。</li>\n</ul>\n<h3 id=\"相同点\"><a href=\"#相同点\" class=\"headerlink\" title=\"相同点\"></a>相同点</h3><ul>\n<li>可重入</li>\n</ul>\n<h3 id=\"1-synchronized-syn-原理\"><a href=\"#1-synchronized-syn-原理\" class=\"headerlink\" title=\"1.synchronized(syn)原理\"></a>1.synchronized(syn)原理</h3><ul>\n<li>被synchronized修饰的代码块，编译的字节码中会被monitorenter和monitorexit包围。</li>\n<li>执行monitorenter时，首先要尝试获取对象的锁。如果获得成功，把锁的计数器加1。相应的，monitorexit会把锁的计数器减1.</li>\n</ul>\n<h3 id=\"2-ReentrantLock原理\"><a href=\"#2-ReentrantLock原理\" class=\"headerlink\" title=\"2. ReentrantLock原理\"></a>2. ReentrantLock原理</h3><p><a href=\"https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html\">美团AQS分析</a>仅供参考，内容有误（非公平锁图解出错）</p>\n<p><a href=\"https://juejin.im/post/5e4f3cede51d4526c80e99cf\">JUC必知必会</a></p>\n<ul>\n<li>通过AQS实现</li>\n<li>双向链表实现的同步队列</li>\n<li>Node的waitStatus</li>\n<li>state操作</li>\n</ul>\n<h3 id=\"AQS-AbstractQueuedSynchronizer\"><a href=\"#AQS-AbstractQueuedSynchronizer\" class=\"headerlink\" title=\"AQS AbstractQueuedSynchronizer\"></a>AQS AbstractQueuedSynchronizer</h3><p>同步队列，JUC工具几乎都是通过<strong>组合AQS</strong>，重写某些方法实现的。</p>\n<h4 id=\"AQS核心思想\"><a href=\"#AQS核心思想\" class=\"headerlink\" title=\"AQS核心思想\"></a>AQS核心思想</h4><ol>\n<li>用CAS尝试改变state，如果成功则获得锁</li>\n<li>CAS失败，就加入同步队列，通过同步机制来有序请求锁。</li>\n</ol>\n<h4 id=\"同步机制\"><a href=\"#同步机制\" class=\"headerlink\" title=\"同步机制\"></a>同步机制</h4><h3 id=\"锁的维度\"><a href=\"#锁的维度\" class=\"headerlink\" title=\"锁的维度\"></a>锁的维度</h3><ul>\n<li>是否公平</li>\n</ul>\n<h3 id=\"AQS的三个维度\"><a href=\"#AQS的三个维度\" class=\"headerlink\" title=\"AQS的三个维度\"></a>AQS的三个维度</h3><ul>\n<li>是否<strong>可中断</strong></li>\n<li>是否<strong>超时</strong></li>\n<li>是否<strong>共享</strong></li>\n</ul>\n<h4 id=\"AQS是否可共享：共享模式shareMode，独占模式exclusiveMode\"><a href=\"#AQS是否可共享：共享模式shareMode，独占模式exclusiveMode\" class=\"headerlink\" title=\"AQS是否可共享：共享模式shareMode，独占模式exclusiveMode\"></a>AQS是否可共享：共享模式shareMode，独占模式exclusiveMode</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> state; <span class=\"comment\">// 同步状态state</span></span><br></pre></td></tr></table></figure>\n\n<p>独占模式：state初始为0, state为0时，CAS操作+1，成功则获得锁。</p>\n<p>共享模式：state初始为n，每当一个线程获得锁-1，当state为0时阻塞。</p>\n<h4 id=\"state操作\"><a href=\"#state操作\" class=\"headerlink\" title=\"state操作\"></a>state操作</h4><ul>\n<li>getState</li>\n<li>setState</li>\n<li>compareAndSetState</li>\n</ul>\n<h4 id=\"源码解读\"><a href=\"#源码解读\" class=\"headerlink\" title=\"源码解读\"></a>源码解读</h4><p>尝试获取锁：lock</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;  <span class=\"comment\">// CAS操作state  if (compareAndSetState(0, 1))    // CAS成功，设置独占锁    setExclusiveOwnerThread(Thread.currentThread());   else    // CAS设置state失败，加入同步队列    acquire(1); // 模板方法&#125;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// acquire模板public final void acquire(int arg) &#123;    if (!tryAcquire(arg) // 再次尝试获取，标记1        &amp;&amp;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) // 加入队列, 标记2        selfInterrupt();&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>再次尝试获取锁，tryAcquire标记1导读：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tryAcquire 标记1protected final boolean tryAcquire(int acquires) &#123;  return nonfairTryAcquire(acquires); // 标记1&#125;// 非公平锁的尝试获取//  nonfairTryAcquire 标记1final boolean nonfairTryAcquire(int acquires) &#123;  final Thread current = Thread.currentThread();  int c = getState();  // 如果state为0，再尝试一次CAS获取锁  if (c == 0) &#123;    if (compareAndSetState(0, acquires)) &#123;      setExclusiveOwnerThread(current);      return true; // CAS成功，获得锁    &#125;  &#125;  // 如果自己是当前锁的持有者，重入操作，state++  else if (current == getExclusiveOwnerThread()) &#123;    int nextc = c + acquires;    if (nextc &lt; 0) // overflow      throw new Error(&quot;Maximum lock count exceeded&quot;);    setState(nextc);    return true;  &#125;  return false; // CAS失败，自己也不是持有者，失败&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>加入同步队列，标记2导读</li>\n</ol>\n<p>添加到队尾：addWaiter：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主要思想：CAS操作添加节点到同步队列队尾private Node addWaiter(Node mode) &#123;  Node node = new Node(Thread.currentThread(), mode);  Node pred = tail;  if (pred != null) &#123;    node.prev = pred;    // CAS    if (compareAndSetTail(pred, node)) &#123;      pred.next = node;      return node;    &#125;  &#125;  enq(node);  return node;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>在同步队列中自旋请求锁，标记2导读</p>\n<p>在队列中自旋请求锁：acquireQueued：</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"keyword\">int</span> arg)</span> </span>&#123;  <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;  <span class=\"keyword\">try</span> &#123;    <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;    <span class=\"comment\">// 自旋操作，要么获得锁，要么阻塞（防止自旋浪费资源）    for (;;) &#123;      // 获取当前node的前驱      final Node p = node.predecessor();      // 1.如果自己在队列头部，尝试CAS请求锁（和之前一样）      if (p == head &amp;&amp; tryAcquire(arg)) &#123;        // 请求锁成功，设置自己为队头        setHead(node);         p.next = null; // help GC，删除自己（因为已经获得锁了）        failed = false;        return interrupted; // 返回      &#125;      // 2. 判断是否需要阻塞（根据waitStatus）      if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;          parkAndCheckInterrupt())        interrupted = true;    &#125;  &#125; finally &#123;    if (failed)      cancelAcquire(node);  &#125;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</code>分析：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 靠前驱节点判断是否需要阻塞private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;  int ws = pred.waitStatus; // 前驱节点状态  // 前驱处于唤醒状态  if (ws == Node.SIGNAL)    return true;  // 前驱处于取消状态  if (ws &gt; 0) &#123;    // 把 队列从自己往队头遍历，删除处于取消状态的节点    do &#123;      node.prev = pred = pred.prev;    &#125; while (pred.waitStatus &gt; 0);    pred.next = node;  &#125; else &#123;    // 设置前驱唤醒    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);  &#125;  return false;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 阻塞当前线程private final boolean parkAndCheckInterrupt() &#123;    LockSupport.park(this);    return Thread.interrupted();&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"waitStatus枚举表\"><a href=\"#waitStatus枚举表\" class=\"headerlink\" title=\"waitStatus枚举表\"></a>waitStatus枚举表</h4><table>\n<thead>\n<tr>\n<th align=\"left\">枚举</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0</td>\n<td align=\"left\">初始化值</td>\n</tr>\n<tr>\n<td align=\"left\">CANCELLED</td>\n<td align=\"left\">1，表示线程获取锁的请求已经取消了</td>\n</tr>\n<tr>\n<td align=\"left\">SIGNAL</td>\n<td align=\"left\">-1，等待被唤醒了，准备请求锁</td>\n</tr>\n<tr>\n<td align=\"left\">CONDITION</td>\n<td align=\"left\">-2，在队列中等待</td>\n</tr>\n<tr>\n<td align=\"left\">PROPAGATE</td>\n<td align=\"left\">-3，当前线程节点的后续节点的acquireShare方法能够被无条件执行</td>\n</tr>\n</tbody></table>\n<h4 id=\"AQS的公平锁与非公平锁实现\"><a href=\"#AQS的公平锁与非公平锁实现\" class=\"headerlink\" title=\"AQS的公平锁与非公平锁实现\"></a>AQS的公平锁与非公平锁实现</h4><p>主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</p>\n<p>非公平锁：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;  <span class=\"comment\">// 直接CAS操作上锁  if (compareAndSetState(0, 1))    setExclusiveOwnerThread(Thread.currentThread());  else    acquire(1);&#125;</span></span><br></pre></td></tr></table></figure>\n\n"},{"title":"init commit","date":"2022-01-04T10:23:50.000Z","cover":"https://raw.githubusercontent.com/sawyerRick/Assets/main/night.jpeg","_content":"\nFirst post!\n\nLet's get SCHWIFTY!\n\n","source":"_posts/init-commit.md","raw":"---\ntitle: init commit\ndate: 2022-01-04 18:23:50\ntags: init_commit\ncategories: init_commit\ncover: https://raw.githubusercontent.com/sawyerRick/Assets/main/night.jpeg\n---\n\nFirst post!\n\nLet's get SCHWIFTY!\n\n","slug":"init-commit","published":1,"updated":"2022-01-04T10:38:13.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky5j9fdv000hw3xw5m9fbd77","content":"<p>First post!</p>\n<p>Let’s get SCHWIFTY!</p>\n","site":{"data":{}},"excerpt":"","more":"<p>First post!</p>\n<p>Let’s get SCHWIFTY!</p>\n"},{"title":"Java-JVM","date":"2022-01-08T07:45:22.000Z","_content":"\n# Java虚拟机学习\n\n[TOC]\n\n\n\n## Java内存模型\n\n### 程序计数器\n\n当前线程的所执行字节码行号指示器。\n\n### Java虚拟机栈\n\nJava方法运行的地方\n\n每个方法运行时都有一个栈帧，**栈帧**保存有\n\n- 局部变量表\n- 操作数栈\n- 动态链接\n- 方法出口\n\n### 本地方法栈\n\nnative方法运行的地方\n\n和Java虚拟机栈很相似\n\n### Java堆 / GC年轻代和老年代\n\n**线程共享**\n\nJava对象生存的地方，也是GC主要发生的地方。\n\n### Java方法区 / GC永久代\n\n**线程共享**\n\n用来储存已被虚拟机加载的类信息，常量，静态变量等数据。\n\n#### 运行时常量池\n\n属于Java方法区的一部分（Java8以前）\n\n存放编译时期生成的各种字面量和符号引用。\n\n#### String.intern()\n\n1.6以前intern()会把首次出现的字符串复制到永久代，返回永久代对象。\n1.6以后intern()不会把首次出现的字符串复制到永久代，直接返回对象引用。\n\n#### Integer和StringBuilder()和“字符串”\n\nInteger -128~127 永久代中保存。\n\n\"字符串\" 如果永久代中存在，直接取，否则创建对象。\n\n### 元空间\n\nJava8后 Java方法区被元空间代替。\n\n元空间使用直接内存。不受虚拟机限制。\n\n为什么要用元空间代替方法区？\n\n- 整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。\n- 元空间大小可以动态调整。\n- 在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。\n\n### 逃逸分析技术\n\n测试 逃逸\n\n```java\n// jvm参数：-Xmx10m -Xms10m -XX:+PrintGC -XX:-DoEscapeAnalysis\npublic class Main {\n    public static void main(String[] args) {\n        while (true) {\n            Integer integer = new Integer(1111111);\n        }\n    }\n}\n```\n\n#### 逃逸分析算法\n\n使用连通图来构建对象和对象引用之间的可达性关系，并在次基础上，提出一种组合数据流分析法。\n\n#### 逃逸状态\n\n- 全局逃逸：一个对象的作用范围跳出了当前方法或线程。\n\n  例子：对象作为返回值，静态变量。\n\n- 参数逃逸：一个对象被方法的参数传递\n\n- 没有逃逸：当前方法中对象没有发送逃逸\n\n#### 逃逸分析优化\n\n- 锁消除：如果检测到对象未逃逸，那么锁是无效的，编译器优化就会移出掉这些操作。\n- 标量替换：如果一个对象没有发生逃逸，那么根本不需要在堆中创建它，只需要在栈中创建它所用到的成员标量即可。\n- 栈上分配：同上，对象的标量分配在栈中，随方法的结束销毁，减少了GC压力。\n\n#### 虚拟机参数\n\n在JDK1.6后才有逃逸分析的实现\n\n开启：`-XX:+DoEscapeAnalysis`\n\n关闭：`-XX:-DoEscapeAnalysis`\n\n## 对象\n\n### Java对象内存布局\n\nHotSpot虚拟机中，对象在内存的储存布局分三块区域：对象头，内容，对齐填充。\n\n#### 对象头\n\n对象头有两部分，Mark Word和指针类型。\n\n1. 对象类型指针 **8/4字节**（地址）\n\n   当JVM开启压缩指针：4字节（默认），否则为8字节\n\n   对象指向他的类元数据的指针。虚拟机通过这个指针确定这个对象属于哪个类的实例。\n\n2. 标记Mark Word **8字节**\n\n   储存对象自身运行时数据，如hashCode、GC年龄、锁状态、线程持有的锁等。\n\n   储存内容(29bit) - 标志位(2) - 0(1bit)\n\n3. 数组[] **4字节**（如果是个数组）\n\n   记录数组长度\n\n#### 内容\n\n对象真正的有效信息，就是代码中定义的各个字段和字段的内容。\n\n#### 对齐填充\n\nHotSpot虚拟机规定对象的大小必须是8字节（32位）的整数倍。\n\n#### 如何计算对象的大小？\n\n工具依赖：\n\n```xml\n<dependency>\n  <groupId>org.apache.lucene</groupId>\n  <artifactId>lucene-core</artifactId>\n  <version>4.0.0</version>\n</dependency>\n```\n\n```java\nInteger i = 1;\nSystem.out.println(RamUsageEstimator.shallowSizeOf(i)); // 16（4 + 8 + 4）\n```\n\n手动计算：\n\n1. 计算头部：类型4/8 + MarkWord8，如果是数组再+4。\n\n2. 计算内容部分\n\n   从父类开始寻找非静态变量。找到一个对象类型则加4/8，找到主数据类型则+4/8。\n\n#### new对象在堆上分配的时候，会发生线程安全问题吗？\n\n会造成线程安全问题！概念上来说，需要给堆加锁。但是由于这样做效率太低，为了减小锁粒度，HotSpot用TLAB技术优雅地解决了此问题。\n\nHotSpot的实现：\n\n**TLAB**：线程本地分配缓存\n\nJava虚拟机在新生代Eden空间分配了一小块**线程私有**的内存空间TLAB。\n\n新创建的对象优先在这个空间分配，他们不存在线程共享也适合快速GC。\n\n### 对象的访问定位\n\n1. 句柄访问\n\n   虚拟机栈中存在对象的引用reference，引用储存对象的句柄地址。\n\n   句柄池包含**到对象实例数据的指针**和**到对象类型数据的指针**\n\n2. 直接指针（HotSpot虚拟机实现）\n\n   虚拟机栈中（方法栈）存在对象的引用reference，引用储存的对象的直接访问地址。\n\n   对象类型指针，可以从对象头部中获取。\n\n## GC垃圾收集\n\n#### 说明\n\n**程序计数器，虚拟机栈，本地方法栈**3个区域随线程生死。\n\n当方法或线程结束，内存自然也回收了。\n\n而**堆**和**方法区**的内存都是动态回收的。\n\n#### 如何判断对象生死？\n\n1. 引用计数法\n\n   给对象添加一个引用计数器，有地方引用它时，计数器+1；引用失败时，计数器-1；\n\n   当计数器为0，判断对象死。\n\n   存在问题：难以解决对象之间循环引用问题。\n\n2. 可达性分析法\n\n   通过一系列**GC Root**对象作为起点，向下搜索，搜索路径称**引用链**。\n\n   当一个对象从**GC Root**不可达，证明这个对象是不可引用的。\n\n#### 可作为GC Root的对象\n\n- 虚拟机栈中引用的对象\n- 本地方法栈中引用的对象\n- 方法区中的静态变量、常量引用的对象\n\n#### 引用类型\n\njdk1.2后，引用类型分为强引用、软引用、弱引用、虚引用四种。强度逐级减弱。\n\n- 强引用\n\n  代码中普遍存在的，`Object o = new Object()`，只要强引用还在，就不会回收。\n\n- 软引用\n\n  描述还有用但非必须对象。内存溢出之前，会进行第二次回收。\n\n  `SoftReference s = new SoftReference() `\n\n  用途：缓存\n\n- 弱引用\n\n  非必须对象，比软引用更弱。只能存活到下一次垃圾收集发生之前。\n\n  `WeakReference w = new WeakReference()`\n\n  用途：threadLocal\n\n- 虚引用/幻影引用\n\n  最弱的引用，存在目的：能在这个对象被垃圾收集器回收时收到一个系统通知。\n\n  `PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);`\n\n  用途：通知\n\n### 堆的收集\n\n#### 垃圾收集算法\n\n- 标记-清除\n\n  用GC Root进行可达性分析，标记，清除对象。\n\n  缺点：标记和清除的效率都不高，容易产生不连续内存碎片。\n\n- 标记-整理\n\n  让存活的对象都向一端移动，然后清理掉端边界以外的内存。\n\n  缺点：大量移动对象，效率不高。\n\n- 复制\n\n  把内存分为两块，一块内存用完了，就把存活的复制到另一块。\n\n  HotSpot实现：一块较大的Eden和两块较小的Survivor。8：1的比例。\n\n  每次使用Eden和一块Survivor，回收时，把存活的复制到另一块Survivor上。清理原来的Eden和Survivor。\n\n#### 分代收集\n\n- 新生代Young：**复制**\n\n- 老年代Tenured：标记-清除，标记-整理\n\n#### 何时收集？什么时候Full GC 什么时候Minor GC\n\n在SafePoint，程序可以进入GC。\n\n老年代不足时，Full GC，伴随一次Minor GC\n\n新生代不足时，Minor GC\n\n#### 垃圾收集器\n\n##### 新生代收集器\n\n新生代收集器有Serial，ParNew和PS三种。\n\n- Serial\n\n  单线程收集器。\n\n- ParNew\n\n  Serial的多线程版本。\n\n- PS Parallel Scavenge （客户端常用）\n\n  注重吞吐量的垃圾收集器，意味着GC的平均时间短\n\n  吞吐量 = 代码运行时间/(代码运行时间 + 垃圾收集时间)\n\n##### 老年代收集器\n\n老年代收集器有Serial Old，Parallel Old和CMS三种。\n\n- Serial Old\n\n  单线程收集器老年代版本。\n\n- Parallel Old\n\n  PS收集器老年代版本，多线程并发收集，使用标记-整理算法。\n\n- CMS Concurrent Mark Sweep\n\n  一种以获取最短暂停时间为目标的收集器。\n\n  收集步骤：\n\n  - 初始标记 stop\n\n    标记GC Root\n\n  - 并发标记\n\n    从GC Root 开始扫描\n\n  - 重新标记 stop\n\n    修正因扫描而产生变动对象的记录\n\n  - 并发清除 \n\n    标记-清除\n\n  其中**并发标记**和**并发清除**可以和用户程序并发执行，**初始标记**和**重新标记**需要stop the world。\n\n  缺点：\n\n  - 对CPU资源敏感，因为需要多线程。\n  - 无法处理浮动垃圾，指的是标记完成后产生的垃圾。\n  - 基于 标记-清除 算法实现，可能产生内存碎片。\n\n##### G1 收集器\n\n最前沿的收集器，范围是整个新生代和老年代。\n\n新生代和老年代不再是物理隔离，他们都是一部分Region(不需要连续)的集合。\n\n把对内存分为多个Region空间。每个Region可以单独回收。\n\n特点：\n\n- 并行与并发\n- 分代收集\n- 空间整合\n- 可预测的停顿\n\n##### 根据Region划分的内存区域，如何判断对象存活？\n\n各个Region中的对象互相引用，如何判断关系？\n\n为了避免全堆扫描，G1中的每个Region都有一个Remembered Set。\n\n当发生对Reference类型数据进行写操作时，产生一个Write Barrier中断，检查引用的对象是否处于不同Region，如果是则通过CardTable把相关引用信息记录到所属Region的Remembered Set之中。\n\n这样一来，就不必进行全堆扫描，也不会造成遗漏。\n\n##### 运作流程\n\n和CMS的流程很相似。\n\n- 初始标记 GC Root 扫描标记 stop\n- 并发标记 GC Root 可达性分析\n- 最终标记 微调，修正因并发标记期间程序继续运作改变的标记 stop\n- 筛选回收 回收，根据各个Region的回收价值和成本进行排序回收 stop\n\n### 方法区/永久代Perm收集\n\n主要回收废弃常量和无用的类。\n\n主要发生在类卸载。\n\n1. 废弃常量\n\n   从一系列GC Root不可达常量池的某个常量引用，那么这个常量就会被清理。\n\n2. 无用的类\n\n   三个条件：\n\n   - 该类所有实例已经被回收。\n   - 加载该类的ClassLoader已经被回收。\n   - 该类的Class对象没有在任何地方被引用。\n\n### 内存分配与回收策略\n\n- Minor GC：新生代回收\n- Major GC/Full GC: 新生代和老年代一起回收。\n\n#### 分配\n\n1. 对象优先在Eden分配\n\n2. 大对象直接进入老年代\n\n3. 长期存活对象将进入老年代\n\n   对象每熬过一次Minor GC年龄增加1岁。默认15岁会到老年代。\n\n#### 年龄判定\n\n如果Survivor空间中相同年龄的对象大小大于Survivor的一半，那么年龄大于等于该年龄的对象就进入老年代。\n\n## 实战\n\n### 堆溢出OutOfMemoryError异常\n\n创建尽可能多的对象并维持对象的GC root，造成堆内存溢出。\n\nVM参数：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError\n\n### 栈溢出StackOverflowError 异常\n\n1. 请求栈的深度大于虚拟机允许的深度——栈溢出\n2. 创建多个线程，线程所用的空间太大，导致进程空间溢出——内存溢出\n\nVM参数：-Xss256k\n\n## 虚拟机参数\n\n-Xms:设置堆最小值\n\n-Xmx:设置堆最大值\n\n-Xss:设置虚拟机栈大小。\n\n-XX:MaxMetaspaceSize 设置元空间大小。\n\n-XX:+HeapDumpOnOutOfMemoryError: OutOfMemoryError异常时，Dump出堆储存快照。\n\n-XX:+PrintGCDetails 打印GC日志。\n\n## Java类与类加载机制\n\n每个java程序都是一个JVM进程（不同的main运行在不同JVM中）。\n\n#### 如何确定一个类和另一个类相同？\n\n- 该类的全限定名 \n\n  查看该类的全限定名：xxx.getClass().getName()\n\n- 该类的类加载器 \n\n  查看该类是哪个类加载器加载的：clazz.getClassLoader()\n\n### 类加载时机\n\n- 遇到new、getstatic、putstatic或invokestatic这四条字节码指令。\n- 反射，通过java.lang.reflect包对类进行反射调用时。\n- 初始化一个类，发现父类未被初始化时。\n- 虚拟机启动时，包含main的那个启动类。\n\n### 双亲委派机制（并不是强制约束，是一种思想）\n\n#### 核心思想\n\n类加载器自己拿到类名后，先交给父类加载，当父类不能加载时，自己才尝试去加载这个类。\n\n#### 优点\n\nJava中的类随着它的类加载器一起具备了一种带优先级的层次关系。\n\n如：就算自己编写的类名和系统类的类名一模一样，那么JVM也能正确加载系统类。\n\n- 保证了系统类的唯一\n- 保证了已经加载的类不会重复加载\n\n#### 缺点\n\n如果系统类要回调用户类怎么办？（高层调用低层）\n\n#### 什么时候需要打破双亲委派机制\n\n- 包的版本冲突。\n- 层级高的类需要使用层级低的类。\n\n### 三大类加载器\n\n这三大类加载器都是ClassLoader实例。\n\n1. Bootstrap ClassLoader：启动类加载器，负责加载JAVA_HOME/lib中的东东。\n\n   由于此加载器是C++/C实现的，所以Java中可能返回null。\n\n2. Extension ClassLoader：扩展类加载器，负责加载JAVA_HOME/lib/ext目录中的东东。\n\n3. Application ClassLoader：应用程序类加载器/系统类加载器，负责加载用户类路径ClassPath下的东东（就是自己写的程序）。\n\n#### 源码分析\n\n通过父加载器parent可以看出，双亲委派机制的实现采用组合，而不是继承。\n\n关键类：\n\n- ClassLoader ：一个负责加载类的类。需要自定义类加载器的时候，继承它，里面有许多内置方法可用。\n\n关键方法：\n\n- findLoadedClass 查看该类有没有被加载\n- findClass 通过某种方式（用户自定义的关键），找到class文件，并转换成Class\n- defineClass 把class文件转换成Class（实际的加载方法，是native的）\n\n分析完后发现，自定义一个UserClassLoader需要：\n\n- 继承ClassLoader\n\n```java\nprotected Class<?> loadClass(String name, boolean resolve)\n        throws ClassNotFoundException\n    {\n        synchronized (getClassLoadingLock(name)) {\n            // 首先，查看该类有没有被加载。\n            Class<?> c = findLoadedClass(name);\n            if (c == null) {\n                long t0 = System.nanoTime();\n              // 尝试委派给父类加载器parent\n                try {\n                    if (parent != null) {\n                        c = parent.loadClass(name, false);\n                    } else {\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // 父类加载器不能加载此类\n                }\n\n                if (c == null) {\n                    // 如果父类加载不了，自己加载\n                    long t1 = System.nanoTime();\n                    c = findClass(name); // 用户类加载器重写关键方法，如何find\n\n                    // this is the defining class loader; record the stats\n                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                    sun.misc.PerfCounter.getFindClasses().increment();\n                }\n            }\n            if (resolve) {\n                resolveClass(c);\n            }\n            return c;\n        }\n    }\n```\n\n#### 当自定义一个类加载器的时候，我们在自定义什么？\n\n简单地说，其实是为了自定义findClass方法，为了能自定义寻找类的方法。\n\n比如Tomcat，有一大堆类加载器。\n\nTomcat本是别人写好的程序，不知道用户编写的逻辑实现类放在哪。\n\n所以，Tomcat自定义一些类加载器，规定一些路径。只要用户按照规定放置类，Tomcat就能找到并加载用户的类。\n\n#### 自定义类加载器的正确姿势！\n\n委派模型（更上层省略）：LoaderChild -> LoaderFather -> Application ClassLoader\n\n核心：组合而不是继承。\n\n自定义一个类加载器方法：\n\n```java\n@Override\nprotected Class<?> findClass(String name) throws ClassNotFoundException {\n  System.out.println(\"Parent:\" + this.getParent());\n  System.out.println(\"name = \" + name);\n  // 双亲委派\n  byte[] classData = getClassData(name);\n  if (classData == null) {\n    throw new ClassNotFoundException();\n  }\n  else {\n    // 父类加载器不能加载，自己加载\n    return defineClass(name, classData, 0, classData.length);\n  }\n}\n```\n\n\n\n自定义父子类加载器方法：\n\n1. LoaderFather 继承 ClassLoader，重写findClass方法，在findClass方法里加入defineClass()。\n\n   关键：继承ClassLoader，这样一来，LoaderFather的parent就是 Application ClassLoader了（前面有分析）。\n\n2. LoaderChild 继承 ClassLoader，但是！**构造函数**要填**LoaderFather**，这样就成功地组合了父类加载器。\n\n   剩下部分和前者一样。\n\n#### 自定义ClassLoader Demo\n\n> 直接看Demo吧，这上下文意识流样的废话太多了\n\nhttps://github.com/sawyerRick/MyClassContainer\n\n### 总结\n\n#### 如果想打破双亲委派机制：\n\n重写loadClass方法\n\n#### 如果想不想打破双亲委派机制：\n\n重写findClass方法\n\n#### 如何优雅地defineClass？\n\n使用javaassist\n\n#### 问题：ClassLoader此抽象类的parent从哪来？\n\n自给自足，如果不给它添加parent，它就自己添加**getSystemClassLoader()**，也就是应用程序类加载器/系统类加载器\n\n```java\nprotected ClassLoader() {\n    this(checkCreateClassLoader(), getSystemClassLoader());\n}\n```\n\n## 杂谈\n\n#### 如何判断程序内存泄漏？\n\n- 使用jvisualvm分析工具，查看Visual GC标签（插件，默认没有，需要安装）。\n\n  分析堆内存情况，如果老年代内存不足，GC发生频繁（GC频率可以通过jconsole工具分析）那么很可能发生了内存泄漏。\n\n#### 如何定位内存泄漏？\n\n- 使用jvisualvm分析工具，转储堆内存快照（dump堆），分析堆中实例数量，如果某个实例数量很多，很可能就是此实例泄漏。\n\n#### 如何合理设置线程数量？\n\n- 线程数量不能太多，也不能太少，不需要计算出精确的数量。\n\n- 根据公式：cpu数量 * 期望cpu使用率 * (1 + 等待时间/ 计算时间)\n\n  公式分析：如果任务是IO密集型，应该开较多的线程；如果任务是计算密集型，开再多线程也没用，反而会因上下文的切换耗费更多的资源，所以应该开较少的线程。\n\n  一般来说，开和cpu逻辑核心数相同的线程数量即够用。\n\n## 工具\n\n### Jdk自带\n\njvisualvm：可以查看内存快照\n\njconsole: 查看\n\njps: 查看正在运行的虚拟机进程。\n\n- 反解析字节码：javap -verbose xxxxx\n\n  把字节码解析为code区\n\n### JVM参数\n\n- 堆大小 最大：`-Xmx10m` ；初始： `-Xms10m`\n- 栈内存大小：`-Xss10m`\n- 堆新生代老年代比例：`-XX:NewRatio`\n- 方法区（JDK1.8以前永久代）：初始：`-XX: PermSize=128m` 最大：`-XX:MaxPermSize=512m` \n- 元数据空间：初始：`-XX:MetaspaceSize=128m` 最大： `-XX:MaxMetaspaceSize=512m`\n- 输出GC日志：-XX:+PrintGC\n- 逃逸分析开启/关闭： -XX:-DoEscapeAnalysis\n\n \n","source":"_posts/Java-JVM.md","raw":"---\ntitle: Java-JVM\ndate: 2022-01-08 15:45:22\ntags: Java\n---\n\n# Java虚拟机学习\n\n[TOC]\n\n\n\n## Java内存模型\n\n### 程序计数器\n\n当前线程的所执行字节码行号指示器。\n\n### Java虚拟机栈\n\nJava方法运行的地方\n\n每个方法运行时都有一个栈帧，**栈帧**保存有\n\n- 局部变量表\n- 操作数栈\n- 动态链接\n- 方法出口\n\n### 本地方法栈\n\nnative方法运行的地方\n\n和Java虚拟机栈很相似\n\n### Java堆 / GC年轻代和老年代\n\n**线程共享**\n\nJava对象生存的地方，也是GC主要发生的地方。\n\n### Java方法区 / GC永久代\n\n**线程共享**\n\n用来储存已被虚拟机加载的类信息，常量，静态变量等数据。\n\n#### 运行时常量池\n\n属于Java方法区的一部分（Java8以前）\n\n存放编译时期生成的各种字面量和符号引用。\n\n#### String.intern()\n\n1.6以前intern()会把首次出现的字符串复制到永久代，返回永久代对象。\n1.6以后intern()不会把首次出现的字符串复制到永久代，直接返回对象引用。\n\n#### Integer和StringBuilder()和“字符串”\n\nInteger -128~127 永久代中保存。\n\n\"字符串\" 如果永久代中存在，直接取，否则创建对象。\n\n### 元空间\n\nJava8后 Java方法区被元空间代替。\n\n元空间使用直接内存。不受虚拟机限制。\n\n为什么要用元空间代替方法区？\n\n- 整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。\n- 元空间大小可以动态调整。\n- 在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。\n\n### 逃逸分析技术\n\n测试 逃逸\n\n```java\n// jvm参数：-Xmx10m -Xms10m -XX:+PrintGC -XX:-DoEscapeAnalysis\npublic class Main {\n    public static void main(String[] args) {\n        while (true) {\n            Integer integer = new Integer(1111111);\n        }\n    }\n}\n```\n\n#### 逃逸分析算法\n\n使用连通图来构建对象和对象引用之间的可达性关系，并在次基础上，提出一种组合数据流分析法。\n\n#### 逃逸状态\n\n- 全局逃逸：一个对象的作用范围跳出了当前方法或线程。\n\n  例子：对象作为返回值，静态变量。\n\n- 参数逃逸：一个对象被方法的参数传递\n\n- 没有逃逸：当前方法中对象没有发送逃逸\n\n#### 逃逸分析优化\n\n- 锁消除：如果检测到对象未逃逸，那么锁是无效的，编译器优化就会移出掉这些操作。\n- 标量替换：如果一个对象没有发生逃逸，那么根本不需要在堆中创建它，只需要在栈中创建它所用到的成员标量即可。\n- 栈上分配：同上，对象的标量分配在栈中，随方法的结束销毁，减少了GC压力。\n\n#### 虚拟机参数\n\n在JDK1.6后才有逃逸分析的实现\n\n开启：`-XX:+DoEscapeAnalysis`\n\n关闭：`-XX:-DoEscapeAnalysis`\n\n## 对象\n\n### Java对象内存布局\n\nHotSpot虚拟机中，对象在内存的储存布局分三块区域：对象头，内容，对齐填充。\n\n#### 对象头\n\n对象头有两部分，Mark Word和指针类型。\n\n1. 对象类型指针 **8/4字节**（地址）\n\n   当JVM开启压缩指针：4字节（默认），否则为8字节\n\n   对象指向他的类元数据的指针。虚拟机通过这个指针确定这个对象属于哪个类的实例。\n\n2. 标记Mark Word **8字节**\n\n   储存对象自身运行时数据，如hashCode、GC年龄、锁状态、线程持有的锁等。\n\n   储存内容(29bit) - 标志位(2) - 0(1bit)\n\n3. 数组[] **4字节**（如果是个数组）\n\n   记录数组长度\n\n#### 内容\n\n对象真正的有效信息，就是代码中定义的各个字段和字段的内容。\n\n#### 对齐填充\n\nHotSpot虚拟机规定对象的大小必须是8字节（32位）的整数倍。\n\n#### 如何计算对象的大小？\n\n工具依赖：\n\n```xml\n<dependency>\n  <groupId>org.apache.lucene</groupId>\n  <artifactId>lucene-core</artifactId>\n  <version>4.0.0</version>\n</dependency>\n```\n\n```java\nInteger i = 1;\nSystem.out.println(RamUsageEstimator.shallowSizeOf(i)); // 16（4 + 8 + 4）\n```\n\n手动计算：\n\n1. 计算头部：类型4/8 + MarkWord8，如果是数组再+4。\n\n2. 计算内容部分\n\n   从父类开始寻找非静态变量。找到一个对象类型则加4/8，找到主数据类型则+4/8。\n\n#### new对象在堆上分配的时候，会发生线程安全问题吗？\n\n会造成线程安全问题！概念上来说，需要给堆加锁。但是由于这样做效率太低，为了减小锁粒度，HotSpot用TLAB技术优雅地解决了此问题。\n\nHotSpot的实现：\n\n**TLAB**：线程本地分配缓存\n\nJava虚拟机在新生代Eden空间分配了一小块**线程私有**的内存空间TLAB。\n\n新创建的对象优先在这个空间分配，他们不存在线程共享也适合快速GC。\n\n### 对象的访问定位\n\n1. 句柄访问\n\n   虚拟机栈中存在对象的引用reference，引用储存对象的句柄地址。\n\n   句柄池包含**到对象实例数据的指针**和**到对象类型数据的指针**\n\n2. 直接指针（HotSpot虚拟机实现）\n\n   虚拟机栈中（方法栈）存在对象的引用reference，引用储存的对象的直接访问地址。\n\n   对象类型指针，可以从对象头部中获取。\n\n## GC垃圾收集\n\n#### 说明\n\n**程序计数器，虚拟机栈，本地方法栈**3个区域随线程生死。\n\n当方法或线程结束，内存自然也回收了。\n\n而**堆**和**方法区**的内存都是动态回收的。\n\n#### 如何判断对象生死？\n\n1. 引用计数法\n\n   给对象添加一个引用计数器，有地方引用它时，计数器+1；引用失败时，计数器-1；\n\n   当计数器为0，判断对象死。\n\n   存在问题：难以解决对象之间循环引用问题。\n\n2. 可达性分析法\n\n   通过一系列**GC Root**对象作为起点，向下搜索，搜索路径称**引用链**。\n\n   当一个对象从**GC Root**不可达，证明这个对象是不可引用的。\n\n#### 可作为GC Root的对象\n\n- 虚拟机栈中引用的对象\n- 本地方法栈中引用的对象\n- 方法区中的静态变量、常量引用的对象\n\n#### 引用类型\n\njdk1.2后，引用类型分为强引用、软引用、弱引用、虚引用四种。强度逐级减弱。\n\n- 强引用\n\n  代码中普遍存在的，`Object o = new Object()`，只要强引用还在，就不会回收。\n\n- 软引用\n\n  描述还有用但非必须对象。内存溢出之前，会进行第二次回收。\n\n  `SoftReference s = new SoftReference() `\n\n  用途：缓存\n\n- 弱引用\n\n  非必须对象，比软引用更弱。只能存活到下一次垃圾收集发生之前。\n\n  `WeakReference w = new WeakReference()`\n\n  用途：threadLocal\n\n- 虚引用/幻影引用\n\n  最弱的引用，存在目的：能在这个对象被垃圾收集器回收时收到一个系统通知。\n\n  `PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);`\n\n  用途：通知\n\n### 堆的收集\n\n#### 垃圾收集算法\n\n- 标记-清除\n\n  用GC Root进行可达性分析，标记，清除对象。\n\n  缺点：标记和清除的效率都不高，容易产生不连续内存碎片。\n\n- 标记-整理\n\n  让存活的对象都向一端移动，然后清理掉端边界以外的内存。\n\n  缺点：大量移动对象，效率不高。\n\n- 复制\n\n  把内存分为两块，一块内存用完了，就把存活的复制到另一块。\n\n  HotSpot实现：一块较大的Eden和两块较小的Survivor。8：1的比例。\n\n  每次使用Eden和一块Survivor，回收时，把存活的复制到另一块Survivor上。清理原来的Eden和Survivor。\n\n#### 分代收集\n\n- 新生代Young：**复制**\n\n- 老年代Tenured：标记-清除，标记-整理\n\n#### 何时收集？什么时候Full GC 什么时候Minor GC\n\n在SafePoint，程序可以进入GC。\n\n老年代不足时，Full GC，伴随一次Minor GC\n\n新生代不足时，Minor GC\n\n#### 垃圾收集器\n\n##### 新生代收集器\n\n新生代收集器有Serial，ParNew和PS三种。\n\n- Serial\n\n  单线程收集器。\n\n- ParNew\n\n  Serial的多线程版本。\n\n- PS Parallel Scavenge （客户端常用）\n\n  注重吞吐量的垃圾收集器，意味着GC的平均时间短\n\n  吞吐量 = 代码运行时间/(代码运行时间 + 垃圾收集时间)\n\n##### 老年代收集器\n\n老年代收集器有Serial Old，Parallel Old和CMS三种。\n\n- Serial Old\n\n  单线程收集器老年代版本。\n\n- Parallel Old\n\n  PS收集器老年代版本，多线程并发收集，使用标记-整理算法。\n\n- CMS Concurrent Mark Sweep\n\n  一种以获取最短暂停时间为目标的收集器。\n\n  收集步骤：\n\n  - 初始标记 stop\n\n    标记GC Root\n\n  - 并发标记\n\n    从GC Root 开始扫描\n\n  - 重新标记 stop\n\n    修正因扫描而产生变动对象的记录\n\n  - 并发清除 \n\n    标记-清除\n\n  其中**并发标记**和**并发清除**可以和用户程序并发执行，**初始标记**和**重新标记**需要stop the world。\n\n  缺点：\n\n  - 对CPU资源敏感，因为需要多线程。\n  - 无法处理浮动垃圾，指的是标记完成后产生的垃圾。\n  - 基于 标记-清除 算法实现，可能产生内存碎片。\n\n##### G1 收集器\n\n最前沿的收集器，范围是整个新生代和老年代。\n\n新生代和老年代不再是物理隔离，他们都是一部分Region(不需要连续)的集合。\n\n把对内存分为多个Region空间。每个Region可以单独回收。\n\n特点：\n\n- 并行与并发\n- 分代收集\n- 空间整合\n- 可预测的停顿\n\n##### 根据Region划分的内存区域，如何判断对象存活？\n\n各个Region中的对象互相引用，如何判断关系？\n\n为了避免全堆扫描，G1中的每个Region都有一个Remembered Set。\n\n当发生对Reference类型数据进行写操作时，产生一个Write Barrier中断，检查引用的对象是否处于不同Region，如果是则通过CardTable把相关引用信息记录到所属Region的Remembered Set之中。\n\n这样一来，就不必进行全堆扫描，也不会造成遗漏。\n\n##### 运作流程\n\n和CMS的流程很相似。\n\n- 初始标记 GC Root 扫描标记 stop\n- 并发标记 GC Root 可达性分析\n- 最终标记 微调，修正因并发标记期间程序继续运作改变的标记 stop\n- 筛选回收 回收，根据各个Region的回收价值和成本进行排序回收 stop\n\n### 方法区/永久代Perm收集\n\n主要回收废弃常量和无用的类。\n\n主要发生在类卸载。\n\n1. 废弃常量\n\n   从一系列GC Root不可达常量池的某个常量引用，那么这个常量就会被清理。\n\n2. 无用的类\n\n   三个条件：\n\n   - 该类所有实例已经被回收。\n   - 加载该类的ClassLoader已经被回收。\n   - 该类的Class对象没有在任何地方被引用。\n\n### 内存分配与回收策略\n\n- Minor GC：新生代回收\n- Major GC/Full GC: 新生代和老年代一起回收。\n\n#### 分配\n\n1. 对象优先在Eden分配\n\n2. 大对象直接进入老年代\n\n3. 长期存活对象将进入老年代\n\n   对象每熬过一次Minor GC年龄增加1岁。默认15岁会到老年代。\n\n#### 年龄判定\n\n如果Survivor空间中相同年龄的对象大小大于Survivor的一半，那么年龄大于等于该年龄的对象就进入老年代。\n\n## 实战\n\n### 堆溢出OutOfMemoryError异常\n\n创建尽可能多的对象并维持对象的GC root，造成堆内存溢出。\n\nVM参数：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError\n\n### 栈溢出StackOverflowError 异常\n\n1. 请求栈的深度大于虚拟机允许的深度——栈溢出\n2. 创建多个线程，线程所用的空间太大，导致进程空间溢出——内存溢出\n\nVM参数：-Xss256k\n\n## 虚拟机参数\n\n-Xms:设置堆最小值\n\n-Xmx:设置堆最大值\n\n-Xss:设置虚拟机栈大小。\n\n-XX:MaxMetaspaceSize 设置元空间大小。\n\n-XX:+HeapDumpOnOutOfMemoryError: OutOfMemoryError异常时，Dump出堆储存快照。\n\n-XX:+PrintGCDetails 打印GC日志。\n\n## Java类与类加载机制\n\n每个java程序都是一个JVM进程（不同的main运行在不同JVM中）。\n\n#### 如何确定一个类和另一个类相同？\n\n- 该类的全限定名 \n\n  查看该类的全限定名：xxx.getClass().getName()\n\n- 该类的类加载器 \n\n  查看该类是哪个类加载器加载的：clazz.getClassLoader()\n\n### 类加载时机\n\n- 遇到new、getstatic、putstatic或invokestatic这四条字节码指令。\n- 反射，通过java.lang.reflect包对类进行反射调用时。\n- 初始化一个类，发现父类未被初始化时。\n- 虚拟机启动时，包含main的那个启动类。\n\n### 双亲委派机制（并不是强制约束，是一种思想）\n\n#### 核心思想\n\n类加载器自己拿到类名后，先交给父类加载，当父类不能加载时，自己才尝试去加载这个类。\n\n#### 优点\n\nJava中的类随着它的类加载器一起具备了一种带优先级的层次关系。\n\n如：就算自己编写的类名和系统类的类名一模一样，那么JVM也能正确加载系统类。\n\n- 保证了系统类的唯一\n- 保证了已经加载的类不会重复加载\n\n#### 缺点\n\n如果系统类要回调用户类怎么办？（高层调用低层）\n\n#### 什么时候需要打破双亲委派机制\n\n- 包的版本冲突。\n- 层级高的类需要使用层级低的类。\n\n### 三大类加载器\n\n这三大类加载器都是ClassLoader实例。\n\n1. Bootstrap ClassLoader：启动类加载器，负责加载JAVA_HOME/lib中的东东。\n\n   由于此加载器是C++/C实现的，所以Java中可能返回null。\n\n2. Extension ClassLoader：扩展类加载器，负责加载JAVA_HOME/lib/ext目录中的东东。\n\n3. Application ClassLoader：应用程序类加载器/系统类加载器，负责加载用户类路径ClassPath下的东东（就是自己写的程序）。\n\n#### 源码分析\n\n通过父加载器parent可以看出，双亲委派机制的实现采用组合，而不是继承。\n\n关键类：\n\n- ClassLoader ：一个负责加载类的类。需要自定义类加载器的时候，继承它，里面有许多内置方法可用。\n\n关键方法：\n\n- findLoadedClass 查看该类有没有被加载\n- findClass 通过某种方式（用户自定义的关键），找到class文件，并转换成Class\n- defineClass 把class文件转换成Class（实际的加载方法，是native的）\n\n分析完后发现，自定义一个UserClassLoader需要：\n\n- 继承ClassLoader\n\n```java\nprotected Class<?> loadClass(String name, boolean resolve)\n        throws ClassNotFoundException\n    {\n        synchronized (getClassLoadingLock(name)) {\n            // 首先，查看该类有没有被加载。\n            Class<?> c = findLoadedClass(name);\n            if (c == null) {\n                long t0 = System.nanoTime();\n              // 尝试委派给父类加载器parent\n                try {\n                    if (parent != null) {\n                        c = parent.loadClass(name, false);\n                    } else {\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // 父类加载器不能加载此类\n                }\n\n                if (c == null) {\n                    // 如果父类加载不了，自己加载\n                    long t1 = System.nanoTime();\n                    c = findClass(name); // 用户类加载器重写关键方法，如何find\n\n                    // this is the defining class loader; record the stats\n                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                    sun.misc.PerfCounter.getFindClasses().increment();\n                }\n            }\n            if (resolve) {\n                resolveClass(c);\n            }\n            return c;\n        }\n    }\n```\n\n#### 当自定义一个类加载器的时候，我们在自定义什么？\n\n简单地说，其实是为了自定义findClass方法，为了能自定义寻找类的方法。\n\n比如Tomcat，有一大堆类加载器。\n\nTomcat本是别人写好的程序，不知道用户编写的逻辑实现类放在哪。\n\n所以，Tomcat自定义一些类加载器，规定一些路径。只要用户按照规定放置类，Tomcat就能找到并加载用户的类。\n\n#### 自定义类加载器的正确姿势！\n\n委派模型（更上层省略）：LoaderChild -> LoaderFather -> Application ClassLoader\n\n核心：组合而不是继承。\n\n自定义一个类加载器方法：\n\n```java\n@Override\nprotected Class<?> findClass(String name) throws ClassNotFoundException {\n  System.out.println(\"Parent:\" + this.getParent());\n  System.out.println(\"name = \" + name);\n  // 双亲委派\n  byte[] classData = getClassData(name);\n  if (classData == null) {\n    throw new ClassNotFoundException();\n  }\n  else {\n    // 父类加载器不能加载，自己加载\n    return defineClass(name, classData, 0, classData.length);\n  }\n}\n```\n\n\n\n自定义父子类加载器方法：\n\n1. LoaderFather 继承 ClassLoader，重写findClass方法，在findClass方法里加入defineClass()。\n\n   关键：继承ClassLoader，这样一来，LoaderFather的parent就是 Application ClassLoader了（前面有分析）。\n\n2. LoaderChild 继承 ClassLoader，但是！**构造函数**要填**LoaderFather**，这样就成功地组合了父类加载器。\n\n   剩下部分和前者一样。\n\n#### 自定义ClassLoader Demo\n\n> 直接看Demo吧，这上下文意识流样的废话太多了\n\nhttps://github.com/sawyerRick/MyClassContainer\n\n### 总结\n\n#### 如果想打破双亲委派机制：\n\n重写loadClass方法\n\n#### 如果想不想打破双亲委派机制：\n\n重写findClass方法\n\n#### 如何优雅地defineClass？\n\n使用javaassist\n\n#### 问题：ClassLoader此抽象类的parent从哪来？\n\n自给自足，如果不给它添加parent，它就自己添加**getSystemClassLoader()**，也就是应用程序类加载器/系统类加载器\n\n```java\nprotected ClassLoader() {\n    this(checkCreateClassLoader(), getSystemClassLoader());\n}\n```\n\n## 杂谈\n\n#### 如何判断程序内存泄漏？\n\n- 使用jvisualvm分析工具，查看Visual GC标签（插件，默认没有，需要安装）。\n\n  分析堆内存情况，如果老年代内存不足，GC发生频繁（GC频率可以通过jconsole工具分析）那么很可能发生了内存泄漏。\n\n#### 如何定位内存泄漏？\n\n- 使用jvisualvm分析工具，转储堆内存快照（dump堆），分析堆中实例数量，如果某个实例数量很多，很可能就是此实例泄漏。\n\n#### 如何合理设置线程数量？\n\n- 线程数量不能太多，也不能太少，不需要计算出精确的数量。\n\n- 根据公式：cpu数量 * 期望cpu使用率 * (1 + 等待时间/ 计算时间)\n\n  公式分析：如果任务是IO密集型，应该开较多的线程；如果任务是计算密集型，开再多线程也没用，反而会因上下文的切换耗费更多的资源，所以应该开较少的线程。\n\n  一般来说，开和cpu逻辑核心数相同的线程数量即够用。\n\n## 工具\n\n### Jdk自带\n\njvisualvm：可以查看内存快照\n\njconsole: 查看\n\njps: 查看正在运行的虚拟机进程。\n\n- 反解析字节码：javap -verbose xxxxx\n\n  把字节码解析为code区\n\n### JVM参数\n\n- 堆大小 最大：`-Xmx10m` ；初始： `-Xms10m`\n- 栈内存大小：`-Xss10m`\n- 堆新生代老年代比例：`-XX:NewRatio`\n- 方法区（JDK1.8以前永久代）：初始：`-XX: PermSize=128m` 最大：`-XX:MaxPermSize=512m` \n- 元数据空间：初始：`-XX:MetaspaceSize=128m` 最大： `-XX:MaxMetaspaceSize=512m`\n- 输出GC日志：-XX:+PrintGC\n- 逃逸分析开启/关闭： -XX:-DoEscapeAnalysis\n\n \n","slug":"Java-JVM","published":1,"updated":"2022-01-08T07:55:51.451Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky5j9fdw000jw3xw1ja47ans","content":"<h1 id=\"Java虚拟机学习\"><a href=\"#Java虚拟机学习\" class=\"headerlink\" title=\"Java虚拟机学习\"></a>Java虚拟机学习</h1><p>[TOC]</p>\n<h2 id=\"Java内存模型\"><a href=\"#Java内存模型\" class=\"headerlink\" title=\"Java内存模型\"></a>Java内存模型</h2><h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><p>当前线程的所执行字节码行号指示器。</p>\n<h3 id=\"Java虚拟机栈\"><a href=\"#Java虚拟机栈\" class=\"headerlink\" title=\"Java虚拟机栈\"></a>Java虚拟机栈</h3><p>Java方法运行的地方</p>\n<p>每个方法运行时都有一个栈帧，<strong>栈帧</strong>保存有</p>\n<ul>\n<li>局部变量表</li>\n<li>操作数栈</li>\n<li>动态链接</li>\n<li>方法出口</li>\n</ul>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p>native方法运行的地方</p>\n<p>和Java虚拟机栈很相似</p>\n<h3 id=\"Java堆-GC年轻代和老年代\"><a href=\"#Java堆-GC年轻代和老年代\" class=\"headerlink\" title=\"Java堆 / GC年轻代和老年代\"></a>Java堆 / GC年轻代和老年代</h3><p><strong>线程共享</strong></p>\n<p>Java对象生存的地方，也是GC主要发生的地方。</p>\n<h3 id=\"Java方法区-GC永久代\"><a href=\"#Java方法区-GC永久代\" class=\"headerlink\" title=\"Java方法区 / GC永久代\"></a>Java方法区 / GC永久代</h3><p><strong>线程共享</strong></p>\n<p>用来储存已被虚拟机加载的类信息，常量，静态变量等数据。</p>\n<h4 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a>运行时常量池</h4><p>属于Java方法区的一部分（Java8以前）</p>\n<p>存放编译时期生成的各种字面量和符号引用。</p>\n<h4 id=\"String-intern\"><a href=\"#String-intern\" class=\"headerlink\" title=\"String.intern()\"></a>String.intern()</h4><p>1.6以前intern()会把首次出现的字符串复制到永久代，返回永久代对象。<br>1.6以后intern()不会把首次出现的字符串复制到永久代，直接返回对象引用。</p>\n<h4 id=\"Integer和StringBuilder-和“字符串”\"><a href=\"#Integer和StringBuilder-和“字符串”\" class=\"headerlink\" title=\"Integer和StringBuilder()和“字符串”\"></a>Integer和StringBuilder()和“字符串”</h4><p>Integer -128~127 永久代中保存。</p>\n<p>“字符串” 如果永久代中存在，直接取，否则创建对象。</p>\n<h3 id=\"元空间\"><a href=\"#元空间\" class=\"headerlink\" title=\"元空间\"></a>元空间</h3><p>Java8后 Java方法区被元空间代替。</p>\n<p>元空间使用直接内存。不受虚拟机限制。</p>\n<p>为什么要用元空间代替方法区？</p>\n<ul>\n<li>整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</li>\n<li>元空间大小可以动态调整。</li>\n<li>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</li>\n</ul>\n<h3 id=\"逃逸分析技术\"><a href=\"#逃逸分析技术\" class=\"headerlink\" title=\"逃逸分析技术\"></a>逃逸分析技术</h3><p>测试 逃逸</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// jvm参数：-Xmx10m -Xms10m -XX:+PrintGC -XX:-DoEscapeAnalysis</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            Integer integer = <span class=\"keyword\">new</span> Integer(<span class=\"number\">1111111</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"逃逸分析算法\"><a href=\"#逃逸分析算法\" class=\"headerlink\" title=\"逃逸分析算法\"></a>逃逸分析算法</h4><p>使用连通图来构建对象和对象引用之间的可达性关系，并在次基础上，提出一种组合数据流分析法。</p>\n<h4 id=\"逃逸状态\"><a href=\"#逃逸状态\" class=\"headerlink\" title=\"逃逸状态\"></a>逃逸状态</h4><ul>\n<li><p>全局逃逸：一个对象的作用范围跳出了当前方法或线程。</p>\n<p>例子：对象作为返回值，静态变量。</p>\n</li>\n<li><p>参数逃逸：一个对象被方法的参数传递</p>\n</li>\n<li><p>没有逃逸：当前方法中对象没有发送逃逸</p>\n</li>\n</ul>\n<h4 id=\"逃逸分析优化\"><a href=\"#逃逸分析优化\" class=\"headerlink\" title=\"逃逸分析优化\"></a>逃逸分析优化</h4><ul>\n<li>锁消除：如果检测到对象未逃逸，那么锁是无效的，编译器优化就会移出掉这些操作。</li>\n<li>标量替换：如果一个对象没有发生逃逸，那么根本不需要在堆中创建它，只需要在栈中创建它所用到的成员标量即可。</li>\n<li>栈上分配：同上，对象的标量分配在栈中，随方法的结束销毁，减少了GC压力。</li>\n</ul>\n<h4 id=\"虚拟机参数\"><a href=\"#虚拟机参数\" class=\"headerlink\" title=\"虚拟机参数\"></a>虚拟机参数</h4><p>在JDK1.6后才有逃逸分析的实现</p>\n<p>开启：<code>-XX:+DoEscapeAnalysis</code></p>\n<p>关闭：<code>-XX:-DoEscapeAnalysis</code></p>\n<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><h3 id=\"Java对象内存布局\"><a href=\"#Java对象内存布局\" class=\"headerlink\" title=\"Java对象内存布局\"></a>Java对象内存布局</h3><p>HotSpot虚拟机中，对象在内存的储存布局分三块区域：对象头，内容，对齐填充。</p>\n<h4 id=\"对象头\"><a href=\"#对象头\" class=\"headerlink\" title=\"对象头\"></a>对象头</h4><p>对象头有两部分，Mark Word和指针类型。</p>\n<ol>\n<li><p>对象类型指针 <strong>8/4字节</strong>（地址）</p>\n<p>当JVM开启压缩指针：4字节（默认），否则为8字节</p>\n<p>对象指向他的类元数据的指针。虚拟机通过这个指针确定这个对象属于哪个类的实例。</p>\n</li>\n<li><p>标记Mark Word <strong>8字节</strong></p>\n<p>储存对象自身运行时数据，如hashCode、GC年龄、锁状态、线程持有的锁等。</p>\n<p>储存内容(29bit) - 标志位(2) - 0(1bit)</p>\n</li>\n<li><p>数组[] <strong>4字节</strong>（如果是个数组）</p>\n<p>记录数组长度</p>\n</li>\n</ol>\n<h4 id=\"内容\"><a href=\"#内容\" class=\"headerlink\" title=\"内容\"></a>内容</h4><p>对象真正的有效信息，就是代码中定义的各个字段和字段的内容。</p>\n<h4 id=\"对齐填充\"><a href=\"#对齐填充\" class=\"headerlink\" title=\"对齐填充\"></a>对齐填充</h4><p>HotSpot虚拟机规定对象的大小必须是8字节（32位）的整数倍。</p>\n<h4 id=\"如何计算对象的大小？\"><a href=\"#如何计算对象的大小？\" class=\"headerlink\" title=\"如何计算对象的大小？\"></a>如何计算对象的大小？</h4><p>工具依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.lucene<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>lucene-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i = <span class=\"number\">1</span>;</span><br><span class=\"line\">System.out.println(RamUsageEstimator.shallowSizeOf(i)); <span class=\"comment\">// 16（4 + 8 + 4）</span></span><br></pre></td></tr></table></figure>\n\n<p>手动计算：</p>\n<ol>\n<li><p>计算头部：类型4/8 + MarkWord8，如果是数组再+4。</p>\n</li>\n<li><p>计算内容部分</p>\n<p>从父类开始寻找非静态变量。找到一个对象类型则加4/8，找到主数据类型则+4/8。</p>\n</li>\n</ol>\n<h4 id=\"new对象在堆上分配的时候，会发生线程安全问题吗？\"><a href=\"#new对象在堆上分配的时候，会发生线程安全问题吗？\" class=\"headerlink\" title=\"new对象在堆上分配的时候，会发生线程安全问题吗？\"></a>new对象在堆上分配的时候，会发生线程安全问题吗？</h4><p>会造成线程安全问题！概念上来说，需要给堆加锁。但是由于这样做效率太低，为了减小锁粒度，HotSpot用TLAB技术优雅地解决了此问题。</p>\n<p>HotSpot的实现：</p>\n<p><strong>TLAB</strong>：线程本地分配缓存</p>\n<p>Java虚拟机在新生代Eden空间分配了一小块<strong>线程私有</strong>的内存空间TLAB。</p>\n<p>新创建的对象优先在这个空间分配，他们不存在线程共享也适合快速GC。</p>\n<h3 id=\"对象的访问定位\"><a href=\"#对象的访问定位\" class=\"headerlink\" title=\"对象的访问定位\"></a>对象的访问定位</h3><ol>\n<li><p>句柄访问</p>\n<p>虚拟机栈中存在对象的引用reference，引用储存对象的句柄地址。</p>\n<p>句柄池包含<strong>到对象实例数据的指针</strong>和<strong>到对象类型数据的指针</strong></p>\n</li>\n<li><p>直接指针（HotSpot虚拟机实现）</p>\n<p>虚拟机栈中（方法栈）存在对象的引用reference，引用储存的对象的直接访问地址。</p>\n<p>对象类型指针，可以从对象头部中获取。</p>\n</li>\n</ol>\n<h2 id=\"GC垃圾收集\"><a href=\"#GC垃圾收集\" class=\"headerlink\" title=\"GC垃圾收集\"></a>GC垃圾收集</h2><h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h4><p><strong>程序计数器，虚拟机栈，本地方法栈</strong>3个区域随线程生死。</p>\n<p>当方法或线程结束，内存自然也回收了。</p>\n<p>而<strong>堆</strong>和<strong>方法区</strong>的内存都是动态回收的。</p>\n<h4 id=\"如何判断对象生死？\"><a href=\"#如何判断对象生死？\" class=\"headerlink\" title=\"如何判断对象生死？\"></a>如何判断对象生死？</h4><ol>\n<li><p>引用计数法</p>\n<p>给对象添加一个引用计数器，有地方引用它时，计数器+1；引用失败时，计数器-1；</p>\n<p>当计数器为0，判断对象死。</p>\n<p>存在问题：难以解决对象之间循环引用问题。</p>\n</li>\n<li><p>可达性分析法</p>\n<p>通过一系列<strong>GC Root</strong>对象作为起点，向下搜索，搜索路径称<strong>引用链</strong>。</p>\n<p>当一个对象从<strong>GC Root</strong>不可达，证明这个对象是不可引用的。</p>\n</li>\n</ol>\n<h4 id=\"可作为GC-Root的对象\"><a href=\"#可作为GC-Root的对象\" class=\"headerlink\" title=\"可作为GC Root的对象\"></a>可作为GC Root的对象</h4><ul>\n<li>虚拟机栈中引用的对象</li>\n<li>本地方法栈中引用的对象</li>\n<li>方法区中的静态变量、常量引用的对象</li>\n</ul>\n<h4 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h4><p>jdk1.2后，引用类型分为强引用、软引用、弱引用、虚引用四种。强度逐级减弱。</p>\n<ul>\n<li><p>强引用</p>\n<p>代码中普遍存在的，<code>Object o = new Object()</code>，只要强引用还在，就不会回收。</p>\n</li>\n<li><p>软引用</p>\n<p>描述还有用但非必须对象。内存溢出之前，会进行第二次回收。</p>\n<p><code>SoftReference s = new SoftReference() </code></p>\n<p>用途：缓存</p>\n</li>\n<li><p>弱引用</p>\n<p>非必须对象，比软引用更弱。只能存活到下一次垃圾收集发生之前。</p>\n<p><code>WeakReference w = new WeakReference()</code></p>\n<p>用途：threadLocal</p>\n</li>\n<li><p>虚引用/幻影引用</p>\n<p>最弱的引用，存在目的：能在这个对象被垃圾收集器回收时收到一个系统通知。</p>\n<p><code>PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj, null);</code></p>\n<p>用途：通知</p>\n</li>\n</ul>\n<h3 id=\"堆的收集\"><a href=\"#堆的收集\" class=\"headerlink\" title=\"堆的收集\"></a>堆的收集</h3><h4 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h4><ul>\n<li><p>标记-清除</p>\n<p>用GC Root进行可达性分析，标记，清除对象。</p>\n<p>缺点：标记和清除的效率都不高，容易产生不连续内存碎片。</p>\n</li>\n<li><p>标记-整理</p>\n<p>让存活的对象都向一端移动，然后清理掉端边界以外的内存。</p>\n<p>缺点：大量移动对象，效率不高。</p>\n</li>\n<li><p>复制</p>\n<p>把内存分为两块，一块内存用完了，就把存活的复制到另一块。</p>\n<p>HotSpot实现：一块较大的Eden和两块较小的Survivor。8：1的比例。</p>\n<p>每次使用Eden和一块Survivor，回收时，把存活的复制到另一块Survivor上。清理原来的Eden和Survivor。</p>\n</li>\n</ul>\n<h4 id=\"分代收集\"><a href=\"#分代收集\" class=\"headerlink\" title=\"分代收集\"></a>分代收集</h4><ul>\n<li><p>新生代Young：<strong>复制</strong></p>\n</li>\n<li><p>老年代Tenured：标记-清除，标记-整理</p>\n</li>\n</ul>\n<h4 id=\"何时收集？什么时候Full-GC-什么时候Minor-GC\"><a href=\"#何时收集？什么时候Full-GC-什么时候Minor-GC\" class=\"headerlink\" title=\"何时收集？什么时候Full GC 什么时候Minor GC\"></a>何时收集？什么时候Full GC 什么时候Minor GC</h4><p>在SafePoint，程序可以进入GC。</p>\n<p>老年代不足时，Full GC，伴随一次Minor GC</p>\n<p>新生代不足时，Minor GC</p>\n<h4 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h4><h5 id=\"新生代收集器\"><a href=\"#新生代收集器\" class=\"headerlink\" title=\"新生代收集器\"></a>新生代收集器</h5><p>新生代收集器有Serial，ParNew和PS三种。</p>\n<ul>\n<li><p>Serial</p>\n<p>单线程收集器。</p>\n</li>\n<li><p>ParNew</p>\n<p>Serial的多线程版本。</p>\n</li>\n<li><p>PS Parallel Scavenge （客户端常用）</p>\n<p>注重吞吐量的垃圾收集器，意味着GC的平均时间短</p>\n<p>吞吐量 = 代码运行时间/(代码运行时间 + 垃圾收集时间)</p>\n</li>\n</ul>\n<h5 id=\"老年代收集器\"><a href=\"#老年代收集器\" class=\"headerlink\" title=\"老年代收集器\"></a>老年代收集器</h5><p>老年代收集器有Serial Old，Parallel Old和CMS三种。</p>\n<ul>\n<li><p>Serial Old</p>\n<p>单线程收集器老年代版本。</p>\n</li>\n<li><p>Parallel Old</p>\n<p>PS收集器老年代版本，多线程并发收集，使用标记-整理算法。</p>\n</li>\n<li><p>CMS Concurrent Mark Sweep</p>\n<p>一种以获取最短暂停时间为目标的收集器。</p>\n<p>收集步骤：</p>\n<ul>\n<li><p>初始标记 stop</p>\n<p>标记GC Root</p>\n</li>\n<li><p>并发标记</p>\n<p>从GC Root 开始扫描</p>\n</li>\n<li><p>重新标记 stop</p>\n<p>修正因扫描而产生变动对象的记录</p>\n</li>\n<li><p>并发清除 </p>\n<p>标记-清除</p>\n</li>\n</ul>\n<p>其中<strong>并发标记</strong>和<strong>并发清除</strong>可以和用户程序并发执行，<strong>初始标记</strong>和<strong>重新标记</strong>需要stop the world。</p>\n<p>缺点：</p>\n<ul>\n<li>对CPU资源敏感，因为需要多线程。</li>\n<li>无法处理浮动垃圾，指的是标记完成后产生的垃圾。</li>\n<li>基于 标记-清除 算法实现，可能产生内存碎片。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"G1-收集器\"><a href=\"#G1-收集器\" class=\"headerlink\" title=\"G1 收集器\"></a>G1 收集器</h5><p>最前沿的收集器，范围是整个新生代和老年代。</p>\n<p>新生代和老年代不再是物理隔离，他们都是一部分Region(不需要连续)的集合。</p>\n<p>把对内存分为多个Region空间。每个Region可以单独回收。</p>\n<p>特点：</p>\n<ul>\n<li>并行与并发</li>\n<li>分代收集</li>\n<li>空间整合</li>\n<li>可预测的停顿</li>\n</ul>\n<h5 id=\"根据Region划分的内存区域，如何判断对象存活？\"><a href=\"#根据Region划分的内存区域，如何判断对象存活？\" class=\"headerlink\" title=\"根据Region划分的内存区域，如何判断对象存活？\"></a>根据Region划分的内存区域，如何判断对象存活？</h5><p>各个Region中的对象互相引用，如何判断关系？</p>\n<p>为了避免全堆扫描，G1中的每个Region都有一个Remembered Set。</p>\n<p>当发生对Reference类型数据进行写操作时，产生一个Write Barrier中断，检查引用的对象是否处于不同Region，如果是则通过CardTable把相关引用信息记录到所属Region的Remembered Set之中。</p>\n<p>这样一来，就不必进行全堆扫描，也不会造成遗漏。</p>\n<h5 id=\"运作流程\"><a href=\"#运作流程\" class=\"headerlink\" title=\"运作流程\"></a>运作流程</h5><p>和CMS的流程很相似。</p>\n<ul>\n<li>初始标记 GC Root 扫描标记 stop</li>\n<li>并发标记 GC Root 可达性分析</li>\n<li>最终标记 微调，修正因并发标记期间程序继续运作改变的标记 stop</li>\n<li>筛选回收 回收，根据各个Region的回收价值和成本进行排序回收 stop</li>\n</ul>\n<h3 id=\"方法区-永久代Perm收集\"><a href=\"#方法区-永久代Perm收集\" class=\"headerlink\" title=\"方法区/永久代Perm收集\"></a>方法区/永久代Perm收集</h3><p>主要回收废弃常量和无用的类。</p>\n<p>主要发生在类卸载。</p>\n<ol>\n<li><p>废弃常量</p>\n<p>从一系列GC Root不可达常量池的某个常量引用，那么这个常量就会被清理。</p>\n</li>\n<li><p>无用的类</p>\n<p>三个条件：</p>\n<ul>\n<li>该类所有实例已经被回收。</li>\n<li>加载该类的ClassLoader已经被回收。</li>\n<li>该类的Class对象没有在任何地方被引用。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"内存分配与回收策略\"><a href=\"#内存分配与回收策略\" class=\"headerlink\" title=\"内存分配与回收策略\"></a>内存分配与回收策略</h3><ul>\n<li>Minor GC：新生代回收</li>\n<li>Major GC/Full GC: 新生代和老年代一起回收。</li>\n</ul>\n<h4 id=\"分配\"><a href=\"#分配\" class=\"headerlink\" title=\"分配\"></a>分配</h4><ol>\n<li><p>对象优先在Eden分配</p>\n</li>\n<li><p>大对象直接进入老年代</p>\n</li>\n<li><p>长期存活对象将进入老年代</p>\n<p>对象每熬过一次Minor GC年龄增加1岁。默认15岁会到老年代。</p>\n</li>\n</ol>\n<h4 id=\"年龄判定\"><a href=\"#年龄判定\" class=\"headerlink\" title=\"年龄判定\"></a>年龄判定</h4><p>如果Survivor空间中相同年龄的对象大小大于Survivor的一半，那么年龄大于等于该年龄的对象就进入老年代。</p>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><h3 id=\"堆溢出OutOfMemoryError异常\"><a href=\"#堆溢出OutOfMemoryError异常\" class=\"headerlink\" title=\"堆溢出OutOfMemoryError异常\"></a>堆溢出OutOfMemoryError异常</h3><p>创建尽可能多的对象并维持对象的GC root，造成堆内存溢出。</p>\n<p>VM参数：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</p>\n<h3 id=\"栈溢出StackOverflowError-异常\"><a href=\"#栈溢出StackOverflowError-异常\" class=\"headerlink\" title=\"栈溢出StackOverflowError 异常\"></a>栈溢出StackOverflowError 异常</h3><ol>\n<li>请求栈的深度大于虚拟机允许的深度——栈溢出</li>\n<li>创建多个线程，线程所用的空间太大，导致进程空间溢出——内存溢出</li>\n</ol>\n<p>VM参数：-Xss256k</p>\n<h2 id=\"虚拟机参数-1\"><a href=\"#虚拟机参数-1\" class=\"headerlink\" title=\"虚拟机参数\"></a>虚拟机参数</h2><p>-Xms:设置堆最小值</p>\n<p>-Xmx:设置堆最大值</p>\n<p>-Xss:设置虚拟机栈大小。</p>\n<p>-XX:MaxMetaspaceSize 设置元空间大小。</p>\n<p>-XX:+HeapDumpOnOutOfMemoryError: OutOfMemoryError异常时，Dump出堆储存快照。</p>\n<p>-XX:+PrintGCDetails 打印GC日志。</p>\n<h2 id=\"Java类与类加载机制\"><a href=\"#Java类与类加载机制\" class=\"headerlink\" title=\"Java类与类加载机制\"></a>Java类与类加载机制</h2><p>每个java程序都是一个JVM进程（不同的main运行在不同JVM中）。</p>\n<h4 id=\"如何确定一个类和另一个类相同？\"><a href=\"#如何确定一个类和另一个类相同？\" class=\"headerlink\" title=\"如何确定一个类和另一个类相同？\"></a>如何确定一个类和另一个类相同？</h4><ul>\n<li><p>该类的全限定名 </p>\n<p>查看该类的全限定名：xxx.getClass().getName()</p>\n</li>\n<li><p>该类的类加载器 </p>\n<p>查看该类是哪个类加载器加载的：clazz.getClassLoader()</p>\n</li>\n</ul>\n<h3 id=\"类加载时机\"><a href=\"#类加载时机\" class=\"headerlink\" title=\"类加载时机\"></a>类加载时机</h3><ul>\n<li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令。</li>\n<li>反射，通过java.lang.reflect包对类进行反射调用时。</li>\n<li>初始化一个类，发现父类未被初始化时。</li>\n<li>虚拟机启动时，包含main的那个启动类。</li>\n</ul>\n<h3 id=\"双亲委派机制（并不是强制约束，是一种思想）\"><a href=\"#双亲委派机制（并不是强制约束，是一种思想）\" class=\"headerlink\" title=\"双亲委派机制（并不是强制约束，是一种思想）\"></a>双亲委派机制（并不是强制约束，是一种思想）</h3><h4 id=\"核心思想\"><a href=\"#核心思想\" class=\"headerlink\" title=\"核心思想\"></a>核心思想</h4><p>类加载器自己拿到类名后，先交给父类加载，当父类不能加载时，自己才尝试去加载这个类。</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>Java中的类随着它的类加载器一起具备了一种带优先级的层次关系。</p>\n<p>如：就算自己编写的类名和系统类的类名一模一样，那么JVM也能正确加载系统类。</p>\n<ul>\n<li>保证了系统类的唯一</li>\n<li>保证了已经加载的类不会重复加载</li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>如果系统类要回调用户类怎么办？（高层调用低层）</p>\n<h4 id=\"什么时候需要打破双亲委派机制\"><a href=\"#什么时候需要打破双亲委派机制\" class=\"headerlink\" title=\"什么时候需要打破双亲委派机制\"></a>什么时候需要打破双亲委派机制</h4><ul>\n<li>包的版本冲突。</li>\n<li>层级高的类需要使用层级低的类。</li>\n</ul>\n<h3 id=\"三大类加载器\"><a href=\"#三大类加载器\" class=\"headerlink\" title=\"三大类加载器\"></a>三大类加载器</h3><p>这三大类加载器都是ClassLoader实例。</p>\n<ol>\n<li><p>Bootstrap ClassLoader：启动类加载器，负责加载JAVA_HOME/lib中的东东。</p>\n<p>由于此加载器是C++/C实现的，所以Java中可能返回null。</p>\n</li>\n<li><p>Extension ClassLoader：扩展类加载器，负责加载JAVA_HOME/lib/ext目录中的东东。</p>\n</li>\n<li><p>Application ClassLoader：应用程序类加载器/系统类加载器，负责加载用户类路径ClassPath下的东东（就是自己写的程序）。</p>\n</li>\n</ol>\n<h4 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h4><p>通过父加载器parent可以看出，双亲委派机制的实现采用组合，而不是继承。</p>\n<p>关键类：</p>\n<ul>\n<li>ClassLoader ：一个负责加载类的类。需要自定义类加载器的时候，继承它，里面有许多内置方法可用。</li>\n</ul>\n<p>关键方法：</p>\n<ul>\n<li>findLoadedClass 查看该类有没有被加载</li>\n<li>findClass 通过某种方式（用户自定义的关键），找到class文件，并转换成Class</li>\n<li>defineClass 把class文件转换成Class（实际的加载方法，是native的）</li>\n</ul>\n<p>分析完后发现，自定义一个UserClassLoader需要：</p>\n<ul>\n<li>继承ClassLoader</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; loadClass(String name, <span class=\"keyword\">boolean</span> resolve)</span><br><span class=\"line\">        <span class=\"keyword\">throws</span> ClassNotFoundException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 首先，查看该类有没有被加载。</span></span><br><span class=\"line\">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> t0 = System.nanoTime();</span><br><span class=\"line\">              <span class=\"comment\">// 尝试委派给父类加载器parent</span></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        c = parent.loadClass(name, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        c = findBootstrapClassOrNull(name);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 父类加载器不能加载此类</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果父类加载不了，自己加载</span></span><br><span class=\"line\">                    <span class=\"keyword\">long</span> t1 = System.nanoTime();</span><br><span class=\"line\">                    c = findClass(name); <span class=\"comment\">// 用户类加载器重写关键方法，如何find</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// this is the defining class loader; record the stats</span></span><br><span class=\"line\">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class=\"line\">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class=\"line\">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (resolve) &#123;</span><br><span class=\"line\">                resolveClass(c);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"当自定义一个类加载器的时候，我们在自定义什么？\"><a href=\"#当自定义一个类加载器的时候，我们在自定义什么？\" class=\"headerlink\" title=\"当自定义一个类加载器的时候，我们在自定义什么？\"></a>当自定义一个类加载器的时候，我们在自定义什么？</h4><p>简单地说，其实是为了自定义findClass方法，为了能自定义寻找类的方法。</p>\n<p>比如Tomcat，有一大堆类加载器。</p>\n<p>Tomcat本是别人写好的程序，不知道用户编写的逻辑实现类放在哪。</p>\n<p>所以，Tomcat自定义一些类加载器，规定一些路径。只要用户按照规定放置类，Tomcat就能找到并加载用户的类。</p>\n<h4 id=\"自定义类加载器的正确姿势！\"><a href=\"#自定义类加载器的正确姿势！\" class=\"headerlink\" title=\"自定义类加载器的正确姿势！\"></a>自定义类加载器的正确姿势！</h4><p>委派模型（更上层省略）：LoaderChild -&gt; LoaderFather -&gt; Application ClassLoader</p>\n<p>核心：组合而不是继承。</p>\n<p>自定义一个类加载器方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; findClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;Parent:&quot;</span> + <span class=\"keyword\">this</span>.getParent());</span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;name = &quot;</span> + name);</span><br><span class=\"line\">  <span class=\"comment\">// 双亲委派</span></span><br><span class=\"line\">  <span class=\"keyword\">byte</span>[] classData = getClassData(name);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (classData == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 父类加载器不能加载，自己加载</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> defineClass(name, classData, <span class=\"number\">0</span>, classData.length);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>自定义父子类加载器方法：</p>\n<ol>\n<li><p>LoaderFather 继承 ClassLoader，重写findClass方法，在findClass方法里加入defineClass()。</p>\n<p>关键：继承ClassLoader，这样一来，LoaderFather的parent就是 Application ClassLoader了（前面有分析）。</p>\n</li>\n<li><p>LoaderChild 继承 ClassLoader，但是！<strong>构造函数</strong>要填<strong>LoaderFather</strong>，这样就成功地组合了父类加载器。</p>\n<p>剩下部分和前者一样。</p>\n</li>\n</ol>\n<h4 id=\"自定义ClassLoader-Demo\"><a href=\"#自定义ClassLoader-Demo\" class=\"headerlink\" title=\"自定义ClassLoader Demo\"></a>自定义ClassLoader Demo</h4><blockquote>\n<p>直接看Demo吧，这上下文意识流样的废话太多了</p>\n</blockquote>\n<p><a href=\"https://github.com/sawyerRick/MyClassContainer\">https://github.com/sawyerRick/MyClassContainer</a></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><h4 id=\"如果想打破双亲委派机制：\"><a href=\"#如果想打破双亲委派机制：\" class=\"headerlink\" title=\"如果想打破双亲委派机制：\"></a>如果想打破双亲委派机制：</h4><p>重写loadClass方法</p>\n<h4 id=\"如果想不想打破双亲委派机制：\"><a href=\"#如果想不想打破双亲委派机制：\" class=\"headerlink\" title=\"如果想不想打破双亲委派机制：\"></a>如果想不想打破双亲委派机制：</h4><p>重写findClass方法</p>\n<h4 id=\"如何优雅地defineClass？\"><a href=\"#如何优雅地defineClass？\" class=\"headerlink\" title=\"如何优雅地defineClass？\"></a>如何优雅地defineClass？</h4><p>使用javaassist</p>\n<h4 id=\"问题：ClassLoader此抽象类的parent从哪来？\"><a href=\"#问题：ClassLoader此抽象类的parent从哪来？\" class=\"headerlink\" title=\"问题：ClassLoader此抽象类的parent从哪来？\"></a>问题：ClassLoader此抽象类的parent从哪来？</h4><p>自给自足，如果不给它添加parent，它就自己添加**getSystemClassLoader()**，也就是应用程序类加载器/系统类加载器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">ClassLoader</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(checkCreateClassLoader(), getSystemClassLoader());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"杂谈\"><a href=\"#杂谈\" class=\"headerlink\" title=\"杂谈\"></a>杂谈</h2><h4 id=\"如何判断程序内存泄漏？\"><a href=\"#如何判断程序内存泄漏？\" class=\"headerlink\" title=\"如何判断程序内存泄漏？\"></a>如何判断程序内存泄漏？</h4><ul>\n<li><p>使用jvisualvm分析工具，查看Visual GC标签（插件，默认没有，需要安装）。</p>\n<p>分析堆内存情况，如果老年代内存不足，GC发生频繁（GC频率可以通过jconsole工具分析）那么很可能发生了内存泄漏。</p>\n</li>\n</ul>\n<h4 id=\"如何定位内存泄漏？\"><a href=\"#如何定位内存泄漏？\" class=\"headerlink\" title=\"如何定位内存泄漏？\"></a>如何定位内存泄漏？</h4><ul>\n<li>使用jvisualvm分析工具，转储堆内存快照（dump堆），分析堆中实例数量，如果某个实例数量很多，很可能就是此实例泄漏。</li>\n</ul>\n<h4 id=\"如何合理设置线程数量？\"><a href=\"#如何合理设置线程数量？\" class=\"headerlink\" title=\"如何合理设置线程数量？\"></a>如何合理设置线程数量？</h4><ul>\n<li><p>线程数量不能太多，也不能太少，不需要计算出精确的数量。</p>\n</li>\n<li><p>根据公式：cpu数量 * 期望cpu使用率 * (1 + 等待时间/ 计算时间)</p>\n<p>公式分析：如果任务是IO密集型，应该开较多的线程；如果任务是计算密集型，开再多线程也没用，反而会因上下文的切换耗费更多的资源，所以应该开较少的线程。</p>\n<p>一般来说，开和cpu逻辑核心数相同的线程数量即够用。</p>\n</li>\n</ul>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><h3 id=\"Jdk自带\"><a href=\"#Jdk自带\" class=\"headerlink\" title=\"Jdk自带\"></a>Jdk自带</h3><p>jvisualvm：可以查看内存快照</p>\n<p>jconsole: 查看</p>\n<p>jps: 查看正在运行的虚拟机进程。</p>\n<ul>\n<li><p>反解析字节码：javap -verbose xxxxx</p>\n<p>把字节码解析为code区</p>\n</li>\n</ul>\n<h3 id=\"JVM参数\"><a href=\"#JVM参数\" class=\"headerlink\" title=\"JVM参数\"></a>JVM参数</h3><ul>\n<li>堆大小 最大：<code>-Xmx10m</code> ；初始： <code>-Xms10m</code></li>\n<li>栈内存大小：<code>-Xss10m</code></li>\n<li>堆新生代老年代比例：<code>-XX:NewRatio</code></li>\n<li>方法区（JDK1.8以前永久代）：初始：<code>-XX: PermSize=128m</code> 最大：<code>-XX:MaxPermSize=512m</code> </li>\n<li>元数据空间：初始：<code>-XX:MetaspaceSize=128m</code> 最大： <code>-XX:MaxMetaspaceSize=512m</code></li>\n<li>输出GC日志：-XX:+PrintGC</li>\n<li>逃逸分析开启/关闭： -XX:-DoEscapeAnalysis</li>\n</ul>\n","site":{"data":{}},"cover":"/images/dota2Img.jpeg","excerpt":"","more":"<h1 id=\"Java虚拟机学习\"><a href=\"#Java虚拟机学习\" class=\"headerlink\" title=\"Java虚拟机学习\"></a>Java虚拟机学习</h1><p>[TOC]</p>\n<h2 id=\"Java内存模型\"><a href=\"#Java内存模型\" class=\"headerlink\" title=\"Java内存模型\"></a>Java内存模型</h2><h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><p>当前线程的所执行字节码行号指示器。</p>\n<h3 id=\"Java虚拟机栈\"><a href=\"#Java虚拟机栈\" class=\"headerlink\" title=\"Java虚拟机栈\"></a>Java虚拟机栈</h3><p>Java方法运行的地方</p>\n<p>每个方法运行时都有一个栈帧，<strong>栈帧</strong>保存有</p>\n<ul>\n<li>局部变量表</li>\n<li>操作数栈</li>\n<li>动态链接</li>\n<li>方法出口</li>\n</ul>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p>native方法运行的地方</p>\n<p>和Java虚拟机栈很相似</p>\n<h3 id=\"Java堆-GC年轻代和老年代\"><a href=\"#Java堆-GC年轻代和老年代\" class=\"headerlink\" title=\"Java堆 / GC年轻代和老年代\"></a>Java堆 / GC年轻代和老年代</h3><p><strong>线程共享</strong></p>\n<p>Java对象生存的地方，也是GC主要发生的地方。</p>\n<h3 id=\"Java方法区-GC永久代\"><a href=\"#Java方法区-GC永久代\" class=\"headerlink\" title=\"Java方法区 / GC永久代\"></a>Java方法区 / GC永久代</h3><p><strong>线程共享</strong></p>\n<p>用来储存已被虚拟机加载的类信息，常量，静态变量等数据。</p>\n<h4 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a>运行时常量池</h4><p>属于Java方法区的一部分（Java8以前）</p>\n<p>存放编译时期生成的各种字面量和符号引用。</p>\n<h4 id=\"String-intern\"><a href=\"#String-intern\" class=\"headerlink\" title=\"String.intern()\"></a>String.intern()</h4><p>1.6以前intern()会把首次出现的字符串复制到永久代，返回永久代对象。<br>1.6以后intern()不会把首次出现的字符串复制到永久代，直接返回对象引用。</p>\n<h4 id=\"Integer和StringBuilder-和“字符串”\"><a href=\"#Integer和StringBuilder-和“字符串”\" class=\"headerlink\" title=\"Integer和StringBuilder()和“字符串”\"></a>Integer和StringBuilder()和“字符串”</h4><p>Integer -128~127 永久代中保存。</p>\n<p>“字符串” 如果永久代中存在，直接取，否则创建对象。</p>\n<h3 id=\"元空间\"><a href=\"#元空间\" class=\"headerlink\" title=\"元空间\"></a>元空间</h3><p>Java8后 Java方法区被元空间代替。</p>\n<p>元空间使用直接内存。不受虚拟机限制。</p>\n<p>为什么要用元空间代替方法区？</p>\n<ul>\n<li>整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</li>\n<li>元空间大小可以动态调整。</li>\n<li>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</li>\n</ul>\n<h3 id=\"逃逸分析技术\"><a href=\"#逃逸分析技术\" class=\"headerlink\" title=\"逃逸分析技术\"></a>逃逸分析技术</h3><p>测试 逃逸</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// jvm参数：-Xmx10m -Xms10m -XX:+PrintGC -XX:-DoEscapeAnalysis</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            Integer integer = <span class=\"keyword\">new</span> Integer(<span class=\"number\">1111111</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"逃逸分析算法\"><a href=\"#逃逸分析算法\" class=\"headerlink\" title=\"逃逸分析算法\"></a>逃逸分析算法</h4><p>使用连通图来构建对象和对象引用之间的可达性关系，并在次基础上，提出一种组合数据流分析法。</p>\n<h4 id=\"逃逸状态\"><a href=\"#逃逸状态\" class=\"headerlink\" title=\"逃逸状态\"></a>逃逸状态</h4><ul>\n<li><p>全局逃逸：一个对象的作用范围跳出了当前方法或线程。</p>\n<p>例子：对象作为返回值，静态变量。</p>\n</li>\n<li><p>参数逃逸：一个对象被方法的参数传递</p>\n</li>\n<li><p>没有逃逸：当前方法中对象没有发送逃逸</p>\n</li>\n</ul>\n<h4 id=\"逃逸分析优化\"><a href=\"#逃逸分析优化\" class=\"headerlink\" title=\"逃逸分析优化\"></a>逃逸分析优化</h4><ul>\n<li>锁消除：如果检测到对象未逃逸，那么锁是无效的，编译器优化就会移出掉这些操作。</li>\n<li>标量替换：如果一个对象没有发生逃逸，那么根本不需要在堆中创建它，只需要在栈中创建它所用到的成员标量即可。</li>\n<li>栈上分配：同上，对象的标量分配在栈中，随方法的结束销毁，减少了GC压力。</li>\n</ul>\n<h4 id=\"虚拟机参数\"><a href=\"#虚拟机参数\" class=\"headerlink\" title=\"虚拟机参数\"></a>虚拟机参数</h4><p>在JDK1.6后才有逃逸分析的实现</p>\n<p>开启：<code>-XX:+DoEscapeAnalysis</code></p>\n<p>关闭：<code>-XX:-DoEscapeAnalysis</code></p>\n<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><h3 id=\"Java对象内存布局\"><a href=\"#Java对象内存布局\" class=\"headerlink\" title=\"Java对象内存布局\"></a>Java对象内存布局</h3><p>HotSpot虚拟机中，对象在内存的储存布局分三块区域：对象头，内容，对齐填充。</p>\n<h4 id=\"对象头\"><a href=\"#对象头\" class=\"headerlink\" title=\"对象头\"></a>对象头</h4><p>对象头有两部分，Mark Word和指针类型。</p>\n<ol>\n<li><p>对象类型指针 <strong>8/4字节</strong>（地址）</p>\n<p>当JVM开启压缩指针：4字节（默认），否则为8字节</p>\n<p>对象指向他的类元数据的指针。虚拟机通过这个指针确定这个对象属于哪个类的实例。</p>\n</li>\n<li><p>标记Mark Word <strong>8字节</strong></p>\n<p>储存对象自身运行时数据，如hashCode、GC年龄、锁状态、线程持有的锁等。</p>\n<p>储存内容(29bit) - 标志位(2) - 0(1bit)</p>\n</li>\n<li><p>数组[] <strong>4字节</strong>（如果是个数组）</p>\n<p>记录数组长度</p>\n</li>\n</ol>\n<h4 id=\"内容\"><a href=\"#内容\" class=\"headerlink\" title=\"内容\"></a>内容</h4><p>对象真正的有效信息，就是代码中定义的各个字段和字段的内容。</p>\n<h4 id=\"对齐填充\"><a href=\"#对齐填充\" class=\"headerlink\" title=\"对齐填充\"></a>对齐填充</h4><p>HotSpot虚拟机规定对象的大小必须是8字节（32位）的整数倍。</p>\n<h4 id=\"如何计算对象的大小？\"><a href=\"#如何计算对象的大小？\" class=\"headerlink\" title=\"如何计算对象的大小？\"></a>如何计算对象的大小？</h4><p>工具依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.lucene<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>lucene-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i = <span class=\"number\">1</span>;</span><br><span class=\"line\">System.out.println(RamUsageEstimator.shallowSizeOf(i)); <span class=\"comment\">// 16（4 + 8 + 4）</span></span><br></pre></td></tr></table></figure>\n\n<p>手动计算：</p>\n<ol>\n<li><p>计算头部：类型4/8 + MarkWord8，如果是数组再+4。</p>\n</li>\n<li><p>计算内容部分</p>\n<p>从父类开始寻找非静态变量。找到一个对象类型则加4/8，找到主数据类型则+4/8。</p>\n</li>\n</ol>\n<h4 id=\"new对象在堆上分配的时候，会发生线程安全问题吗？\"><a href=\"#new对象在堆上分配的时候，会发生线程安全问题吗？\" class=\"headerlink\" title=\"new对象在堆上分配的时候，会发生线程安全问题吗？\"></a>new对象在堆上分配的时候，会发生线程安全问题吗？</h4><p>会造成线程安全问题！概念上来说，需要给堆加锁。但是由于这样做效率太低，为了减小锁粒度，HotSpot用TLAB技术优雅地解决了此问题。</p>\n<p>HotSpot的实现：</p>\n<p><strong>TLAB</strong>：线程本地分配缓存</p>\n<p>Java虚拟机在新生代Eden空间分配了一小块<strong>线程私有</strong>的内存空间TLAB。</p>\n<p>新创建的对象优先在这个空间分配，他们不存在线程共享也适合快速GC。</p>\n<h3 id=\"对象的访问定位\"><a href=\"#对象的访问定位\" class=\"headerlink\" title=\"对象的访问定位\"></a>对象的访问定位</h3><ol>\n<li><p>句柄访问</p>\n<p>虚拟机栈中存在对象的引用reference，引用储存对象的句柄地址。</p>\n<p>句柄池包含<strong>到对象实例数据的指针</strong>和<strong>到对象类型数据的指针</strong></p>\n</li>\n<li><p>直接指针（HotSpot虚拟机实现）</p>\n<p>虚拟机栈中（方法栈）存在对象的引用reference，引用储存的对象的直接访问地址。</p>\n<p>对象类型指针，可以从对象头部中获取。</p>\n</li>\n</ol>\n<h2 id=\"GC垃圾收集\"><a href=\"#GC垃圾收集\" class=\"headerlink\" title=\"GC垃圾收集\"></a>GC垃圾收集</h2><h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h4><p><strong>程序计数器，虚拟机栈，本地方法栈</strong>3个区域随线程生死。</p>\n<p>当方法或线程结束，内存自然也回收了。</p>\n<p>而<strong>堆</strong>和<strong>方法区</strong>的内存都是动态回收的。</p>\n<h4 id=\"如何判断对象生死？\"><a href=\"#如何判断对象生死？\" class=\"headerlink\" title=\"如何判断对象生死？\"></a>如何判断对象生死？</h4><ol>\n<li><p>引用计数法</p>\n<p>给对象添加一个引用计数器，有地方引用它时，计数器+1；引用失败时，计数器-1；</p>\n<p>当计数器为0，判断对象死。</p>\n<p>存在问题：难以解决对象之间循环引用问题。</p>\n</li>\n<li><p>可达性分析法</p>\n<p>通过一系列<strong>GC Root</strong>对象作为起点，向下搜索，搜索路径称<strong>引用链</strong>。</p>\n<p>当一个对象从<strong>GC Root</strong>不可达，证明这个对象是不可引用的。</p>\n</li>\n</ol>\n<h4 id=\"可作为GC-Root的对象\"><a href=\"#可作为GC-Root的对象\" class=\"headerlink\" title=\"可作为GC Root的对象\"></a>可作为GC Root的对象</h4><ul>\n<li>虚拟机栈中引用的对象</li>\n<li>本地方法栈中引用的对象</li>\n<li>方法区中的静态变量、常量引用的对象</li>\n</ul>\n<h4 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h4><p>jdk1.2后，引用类型分为强引用、软引用、弱引用、虚引用四种。强度逐级减弱。</p>\n<ul>\n<li><p>强引用</p>\n<p>代码中普遍存在的，<code>Object o = new Object()</code>，只要强引用还在，就不会回收。</p>\n</li>\n<li><p>软引用</p>\n<p>描述还有用但非必须对象。内存溢出之前，会进行第二次回收。</p>\n<p><code>SoftReference s = new SoftReference() </code></p>\n<p>用途：缓存</p>\n</li>\n<li><p>弱引用</p>\n<p>非必须对象，比软引用更弱。只能存活到下一次垃圾收集发生之前。</p>\n<p><code>WeakReference w = new WeakReference()</code></p>\n<p>用途：threadLocal</p>\n</li>\n<li><p>虚引用/幻影引用</p>\n<p>最弱的引用，存在目的：能在这个对象被垃圾收集器回收时收到一个系统通知。</p>\n<p><code>PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj, null);</code></p>\n<p>用途：通知</p>\n</li>\n</ul>\n<h3 id=\"堆的收集\"><a href=\"#堆的收集\" class=\"headerlink\" title=\"堆的收集\"></a>堆的收集</h3><h4 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h4><ul>\n<li><p>标记-清除</p>\n<p>用GC Root进行可达性分析，标记，清除对象。</p>\n<p>缺点：标记和清除的效率都不高，容易产生不连续内存碎片。</p>\n</li>\n<li><p>标记-整理</p>\n<p>让存活的对象都向一端移动，然后清理掉端边界以外的内存。</p>\n<p>缺点：大量移动对象，效率不高。</p>\n</li>\n<li><p>复制</p>\n<p>把内存分为两块，一块内存用完了，就把存活的复制到另一块。</p>\n<p>HotSpot实现：一块较大的Eden和两块较小的Survivor。8：1的比例。</p>\n<p>每次使用Eden和一块Survivor，回收时，把存活的复制到另一块Survivor上。清理原来的Eden和Survivor。</p>\n</li>\n</ul>\n<h4 id=\"分代收集\"><a href=\"#分代收集\" class=\"headerlink\" title=\"分代收集\"></a>分代收集</h4><ul>\n<li><p>新生代Young：<strong>复制</strong></p>\n</li>\n<li><p>老年代Tenured：标记-清除，标记-整理</p>\n</li>\n</ul>\n<h4 id=\"何时收集？什么时候Full-GC-什么时候Minor-GC\"><a href=\"#何时收集？什么时候Full-GC-什么时候Minor-GC\" class=\"headerlink\" title=\"何时收集？什么时候Full GC 什么时候Minor GC\"></a>何时收集？什么时候Full GC 什么时候Minor GC</h4><p>在SafePoint，程序可以进入GC。</p>\n<p>老年代不足时，Full GC，伴随一次Minor GC</p>\n<p>新生代不足时，Minor GC</p>\n<h4 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h4><h5 id=\"新生代收集器\"><a href=\"#新生代收集器\" class=\"headerlink\" title=\"新生代收集器\"></a>新生代收集器</h5><p>新生代收集器有Serial，ParNew和PS三种。</p>\n<ul>\n<li><p>Serial</p>\n<p>单线程收集器。</p>\n</li>\n<li><p>ParNew</p>\n<p>Serial的多线程版本。</p>\n</li>\n<li><p>PS Parallel Scavenge （客户端常用）</p>\n<p>注重吞吐量的垃圾收集器，意味着GC的平均时间短</p>\n<p>吞吐量 = 代码运行时间/(代码运行时间 + 垃圾收集时间)</p>\n</li>\n</ul>\n<h5 id=\"老年代收集器\"><a href=\"#老年代收集器\" class=\"headerlink\" title=\"老年代收集器\"></a>老年代收集器</h5><p>老年代收集器有Serial Old，Parallel Old和CMS三种。</p>\n<ul>\n<li><p>Serial Old</p>\n<p>单线程收集器老年代版本。</p>\n</li>\n<li><p>Parallel Old</p>\n<p>PS收集器老年代版本，多线程并发收集，使用标记-整理算法。</p>\n</li>\n<li><p>CMS Concurrent Mark Sweep</p>\n<p>一种以获取最短暂停时间为目标的收集器。</p>\n<p>收集步骤：</p>\n<ul>\n<li><p>初始标记 stop</p>\n<p>标记GC Root</p>\n</li>\n<li><p>并发标记</p>\n<p>从GC Root 开始扫描</p>\n</li>\n<li><p>重新标记 stop</p>\n<p>修正因扫描而产生变动对象的记录</p>\n</li>\n<li><p>并发清除 </p>\n<p>标记-清除</p>\n</li>\n</ul>\n<p>其中<strong>并发标记</strong>和<strong>并发清除</strong>可以和用户程序并发执行，<strong>初始标记</strong>和<strong>重新标记</strong>需要stop the world。</p>\n<p>缺点：</p>\n<ul>\n<li>对CPU资源敏感，因为需要多线程。</li>\n<li>无法处理浮动垃圾，指的是标记完成后产生的垃圾。</li>\n<li>基于 标记-清除 算法实现，可能产生内存碎片。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"G1-收集器\"><a href=\"#G1-收集器\" class=\"headerlink\" title=\"G1 收集器\"></a>G1 收集器</h5><p>最前沿的收集器，范围是整个新生代和老年代。</p>\n<p>新生代和老年代不再是物理隔离，他们都是一部分Region(不需要连续)的集合。</p>\n<p>把对内存分为多个Region空间。每个Region可以单独回收。</p>\n<p>特点：</p>\n<ul>\n<li>并行与并发</li>\n<li>分代收集</li>\n<li>空间整合</li>\n<li>可预测的停顿</li>\n</ul>\n<h5 id=\"根据Region划分的内存区域，如何判断对象存活？\"><a href=\"#根据Region划分的内存区域，如何判断对象存活？\" class=\"headerlink\" title=\"根据Region划分的内存区域，如何判断对象存活？\"></a>根据Region划分的内存区域，如何判断对象存活？</h5><p>各个Region中的对象互相引用，如何判断关系？</p>\n<p>为了避免全堆扫描，G1中的每个Region都有一个Remembered Set。</p>\n<p>当发生对Reference类型数据进行写操作时，产生一个Write Barrier中断，检查引用的对象是否处于不同Region，如果是则通过CardTable把相关引用信息记录到所属Region的Remembered Set之中。</p>\n<p>这样一来，就不必进行全堆扫描，也不会造成遗漏。</p>\n<h5 id=\"运作流程\"><a href=\"#运作流程\" class=\"headerlink\" title=\"运作流程\"></a>运作流程</h5><p>和CMS的流程很相似。</p>\n<ul>\n<li>初始标记 GC Root 扫描标记 stop</li>\n<li>并发标记 GC Root 可达性分析</li>\n<li>最终标记 微调，修正因并发标记期间程序继续运作改变的标记 stop</li>\n<li>筛选回收 回收，根据各个Region的回收价值和成本进行排序回收 stop</li>\n</ul>\n<h3 id=\"方法区-永久代Perm收集\"><a href=\"#方法区-永久代Perm收集\" class=\"headerlink\" title=\"方法区/永久代Perm收集\"></a>方法区/永久代Perm收集</h3><p>主要回收废弃常量和无用的类。</p>\n<p>主要发生在类卸载。</p>\n<ol>\n<li><p>废弃常量</p>\n<p>从一系列GC Root不可达常量池的某个常量引用，那么这个常量就会被清理。</p>\n</li>\n<li><p>无用的类</p>\n<p>三个条件：</p>\n<ul>\n<li>该类所有实例已经被回收。</li>\n<li>加载该类的ClassLoader已经被回收。</li>\n<li>该类的Class对象没有在任何地方被引用。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"内存分配与回收策略\"><a href=\"#内存分配与回收策略\" class=\"headerlink\" title=\"内存分配与回收策略\"></a>内存分配与回收策略</h3><ul>\n<li>Minor GC：新生代回收</li>\n<li>Major GC/Full GC: 新生代和老年代一起回收。</li>\n</ul>\n<h4 id=\"分配\"><a href=\"#分配\" class=\"headerlink\" title=\"分配\"></a>分配</h4><ol>\n<li><p>对象优先在Eden分配</p>\n</li>\n<li><p>大对象直接进入老年代</p>\n</li>\n<li><p>长期存活对象将进入老年代</p>\n<p>对象每熬过一次Minor GC年龄增加1岁。默认15岁会到老年代。</p>\n</li>\n</ol>\n<h4 id=\"年龄判定\"><a href=\"#年龄判定\" class=\"headerlink\" title=\"年龄判定\"></a>年龄判定</h4><p>如果Survivor空间中相同年龄的对象大小大于Survivor的一半，那么年龄大于等于该年龄的对象就进入老年代。</p>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><h3 id=\"堆溢出OutOfMemoryError异常\"><a href=\"#堆溢出OutOfMemoryError异常\" class=\"headerlink\" title=\"堆溢出OutOfMemoryError异常\"></a>堆溢出OutOfMemoryError异常</h3><p>创建尽可能多的对象并维持对象的GC root，造成堆内存溢出。</p>\n<p>VM参数：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</p>\n<h3 id=\"栈溢出StackOverflowError-异常\"><a href=\"#栈溢出StackOverflowError-异常\" class=\"headerlink\" title=\"栈溢出StackOverflowError 异常\"></a>栈溢出StackOverflowError 异常</h3><ol>\n<li>请求栈的深度大于虚拟机允许的深度——栈溢出</li>\n<li>创建多个线程，线程所用的空间太大，导致进程空间溢出——内存溢出</li>\n</ol>\n<p>VM参数：-Xss256k</p>\n<h2 id=\"虚拟机参数-1\"><a href=\"#虚拟机参数-1\" class=\"headerlink\" title=\"虚拟机参数\"></a>虚拟机参数</h2><p>-Xms:设置堆最小值</p>\n<p>-Xmx:设置堆最大值</p>\n<p>-Xss:设置虚拟机栈大小。</p>\n<p>-XX:MaxMetaspaceSize 设置元空间大小。</p>\n<p>-XX:+HeapDumpOnOutOfMemoryError: OutOfMemoryError异常时，Dump出堆储存快照。</p>\n<p>-XX:+PrintGCDetails 打印GC日志。</p>\n<h2 id=\"Java类与类加载机制\"><a href=\"#Java类与类加载机制\" class=\"headerlink\" title=\"Java类与类加载机制\"></a>Java类与类加载机制</h2><p>每个java程序都是一个JVM进程（不同的main运行在不同JVM中）。</p>\n<h4 id=\"如何确定一个类和另一个类相同？\"><a href=\"#如何确定一个类和另一个类相同？\" class=\"headerlink\" title=\"如何确定一个类和另一个类相同？\"></a>如何确定一个类和另一个类相同？</h4><ul>\n<li><p>该类的全限定名 </p>\n<p>查看该类的全限定名：xxx.getClass().getName()</p>\n</li>\n<li><p>该类的类加载器 </p>\n<p>查看该类是哪个类加载器加载的：clazz.getClassLoader()</p>\n</li>\n</ul>\n<h3 id=\"类加载时机\"><a href=\"#类加载时机\" class=\"headerlink\" title=\"类加载时机\"></a>类加载时机</h3><ul>\n<li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令。</li>\n<li>反射，通过java.lang.reflect包对类进行反射调用时。</li>\n<li>初始化一个类，发现父类未被初始化时。</li>\n<li>虚拟机启动时，包含main的那个启动类。</li>\n</ul>\n<h3 id=\"双亲委派机制（并不是强制约束，是一种思想）\"><a href=\"#双亲委派机制（并不是强制约束，是一种思想）\" class=\"headerlink\" title=\"双亲委派机制（并不是强制约束，是一种思想）\"></a>双亲委派机制（并不是强制约束，是一种思想）</h3><h4 id=\"核心思想\"><a href=\"#核心思想\" class=\"headerlink\" title=\"核心思想\"></a>核心思想</h4><p>类加载器自己拿到类名后，先交给父类加载，当父类不能加载时，自己才尝试去加载这个类。</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>Java中的类随着它的类加载器一起具备了一种带优先级的层次关系。</p>\n<p>如：就算自己编写的类名和系统类的类名一模一样，那么JVM也能正确加载系统类。</p>\n<ul>\n<li>保证了系统类的唯一</li>\n<li>保证了已经加载的类不会重复加载</li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>如果系统类要回调用户类怎么办？（高层调用低层）</p>\n<h4 id=\"什么时候需要打破双亲委派机制\"><a href=\"#什么时候需要打破双亲委派机制\" class=\"headerlink\" title=\"什么时候需要打破双亲委派机制\"></a>什么时候需要打破双亲委派机制</h4><ul>\n<li>包的版本冲突。</li>\n<li>层级高的类需要使用层级低的类。</li>\n</ul>\n<h3 id=\"三大类加载器\"><a href=\"#三大类加载器\" class=\"headerlink\" title=\"三大类加载器\"></a>三大类加载器</h3><p>这三大类加载器都是ClassLoader实例。</p>\n<ol>\n<li><p>Bootstrap ClassLoader：启动类加载器，负责加载JAVA_HOME/lib中的东东。</p>\n<p>由于此加载器是C++/C实现的，所以Java中可能返回null。</p>\n</li>\n<li><p>Extension ClassLoader：扩展类加载器，负责加载JAVA_HOME/lib/ext目录中的东东。</p>\n</li>\n<li><p>Application ClassLoader：应用程序类加载器/系统类加载器，负责加载用户类路径ClassPath下的东东（就是自己写的程序）。</p>\n</li>\n</ol>\n<h4 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h4><p>通过父加载器parent可以看出，双亲委派机制的实现采用组合，而不是继承。</p>\n<p>关键类：</p>\n<ul>\n<li>ClassLoader ：一个负责加载类的类。需要自定义类加载器的时候，继承它，里面有许多内置方法可用。</li>\n</ul>\n<p>关键方法：</p>\n<ul>\n<li>findLoadedClass 查看该类有没有被加载</li>\n<li>findClass 通过某种方式（用户自定义的关键），找到class文件，并转换成Class</li>\n<li>defineClass 把class文件转换成Class（实际的加载方法，是native的）</li>\n</ul>\n<p>分析完后发现，自定义一个UserClassLoader需要：</p>\n<ul>\n<li>继承ClassLoader</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; loadClass(String name, <span class=\"keyword\">boolean</span> resolve)</span><br><span class=\"line\">        <span class=\"keyword\">throws</span> ClassNotFoundException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 首先，查看该类有没有被加载。</span></span><br><span class=\"line\">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> t0 = System.nanoTime();</span><br><span class=\"line\">              <span class=\"comment\">// 尝试委派给父类加载器parent</span></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        c = parent.loadClass(name, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        c = findBootstrapClassOrNull(name);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 父类加载器不能加载此类</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果父类加载不了，自己加载</span></span><br><span class=\"line\">                    <span class=\"keyword\">long</span> t1 = System.nanoTime();</span><br><span class=\"line\">                    c = findClass(name); <span class=\"comment\">// 用户类加载器重写关键方法，如何find</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// this is the defining class loader; record the stats</span></span><br><span class=\"line\">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class=\"line\">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class=\"line\">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (resolve) &#123;</span><br><span class=\"line\">                resolveClass(c);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"当自定义一个类加载器的时候，我们在自定义什么？\"><a href=\"#当自定义一个类加载器的时候，我们在自定义什么？\" class=\"headerlink\" title=\"当自定义一个类加载器的时候，我们在自定义什么？\"></a>当自定义一个类加载器的时候，我们在自定义什么？</h4><p>简单地说，其实是为了自定义findClass方法，为了能自定义寻找类的方法。</p>\n<p>比如Tomcat，有一大堆类加载器。</p>\n<p>Tomcat本是别人写好的程序，不知道用户编写的逻辑实现类放在哪。</p>\n<p>所以，Tomcat自定义一些类加载器，规定一些路径。只要用户按照规定放置类，Tomcat就能找到并加载用户的类。</p>\n<h4 id=\"自定义类加载器的正确姿势！\"><a href=\"#自定义类加载器的正确姿势！\" class=\"headerlink\" title=\"自定义类加载器的正确姿势！\"></a>自定义类加载器的正确姿势！</h4><p>委派模型（更上层省略）：LoaderChild -&gt; LoaderFather -&gt; Application ClassLoader</p>\n<p>核心：组合而不是继承。</p>\n<p>自定义一个类加载器方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; findClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;Parent:&quot;</span> + <span class=\"keyword\">this</span>.getParent());</span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;name = &quot;</span> + name);</span><br><span class=\"line\">  <span class=\"comment\">// 双亲委派</span></span><br><span class=\"line\">  <span class=\"keyword\">byte</span>[] classData = getClassData(name);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (classData == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 父类加载器不能加载，自己加载</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> defineClass(name, classData, <span class=\"number\">0</span>, classData.length);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>自定义父子类加载器方法：</p>\n<ol>\n<li><p>LoaderFather 继承 ClassLoader，重写findClass方法，在findClass方法里加入defineClass()。</p>\n<p>关键：继承ClassLoader，这样一来，LoaderFather的parent就是 Application ClassLoader了（前面有分析）。</p>\n</li>\n<li><p>LoaderChild 继承 ClassLoader，但是！<strong>构造函数</strong>要填<strong>LoaderFather</strong>，这样就成功地组合了父类加载器。</p>\n<p>剩下部分和前者一样。</p>\n</li>\n</ol>\n<h4 id=\"自定义ClassLoader-Demo\"><a href=\"#自定义ClassLoader-Demo\" class=\"headerlink\" title=\"自定义ClassLoader Demo\"></a>自定义ClassLoader Demo</h4><blockquote>\n<p>直接看Demo吧，这上下文意识流样的废话太多了</p>\n</blockquote>\n<p><a href=\"https://github.com/sawyerRick/MyClassContainer\">https://github.com/sawyerRick/MyClassContainer</a></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><h4 id=\"如果想打破双亲委派机制：\"><a href=\"#如果想打破双亲委派机制：\" class=\"headerlink\" title=\"如果想打破双亲委派机制：\"></a>如果想打破双亲委派机制：</h4><p>重写loadClass方法</p>\n<h4 id=\"如果想不想打破双亲委派机制：\"><a href=\"#如果想不想打破双亲委派机制：\" class=\"headerlink\" title=\"如果想不想打破双亲委派机制：\"></a>如果想不想打破双亲委派机制：</h4><p>重写findClass方法</p>\n<h4 id=\"如何优雅地defineClass？\"><a href=\"#如何优雅地defineClass？\" class=\"headerlink\" title=\"如何优雅地defineClass？\"></a>如何优雅地defineClass？</h4><p>使用javaassist</p>\n<h4 id=\"问题：ClassLoader此抽象类的parent从哪来？\"><a href=\"#问题：ClassLoader此抽象类的parent从哪来？\" class=\"headerlink\" title=\"问题：ClassLoader此抽象类的parent从哪来？\"></a>问题：ClassLoader此抽象类的parent从哪来？</h4><p>自给自足，如果不给它添加parent，它就自己添加**getSystemClassLoader()**，也就是应用程序类加载器/系统类加载器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">ClassLoader</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(checkCreateClassLoader(), getSystemClassLoader());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"杂谈\"><a href=\"#杂谈\" class=\"headerlink\" title=\"杂谈\"></a>杂谈</h2><h4 id=\"如何判断程序内存泄漏？\"><a href=\"#如何判断程序内存泄漏？\" class=\"headerlink\" title=\"如何判断程序内存泄漏？\"></a>如何判断程序内存泄漏？</h4><ul>\n<li><p>使用jvisualvm分析工具，查看Visual GC标签（插件，默认没有，需要安装）。</p>\n<p>分析堆内存情况，如果老年代内存不足，GC发生频繁（GC频率可以通过jconsole工具分析）那么很可能发生了内存泄漏。</p>\n</li>\n</ul>\n<h4 id=\"如何定位内存泄漏？\"><a href=\"#如何定位内存泄漏？\" class=\"headerlink\" title=\"如何定位内存泄漏？\"></a>如何定位内存泄漏？</h4><ul>\n<li>使用jvisualvm分析工具，转储堆内存快照（dump堆），分析堆中实例数量，如果某个实例数量很多，很可能就是此实例泄漏。</li>\n</ul>\n<h4 id=\"如何合理设置线程数量？\"><a href=\"#如何合理设置线程数量？\" class=\"headerlink\" title=\"如何合理设置线程数量？\"></a>如何合理设置线程数量？</h4><ul>\n<li><p>线程数量不能太多，也不能太少，不需要计算出精确的数量。</p>\n</li>\n<li><p>根据公式：cpu数量 * 期望cpu使用率 * (1 + 等待时间/ 计算时间)</p>\n<p>公式分析：如果任务是IO密集型，应该开较多的线程；如果任务是计算密集型，开再多线程也没用，反而会因上下文的切换耗费更多的资源，所以应该开较少的线程。</p>\n<p>一般来说，开和cpu逻辑核心数相同的线程数量即够用。</p>\n</li>\n</ul>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><h3 id=\"Jdk自带\"><a href=\"#Jdk自带\" class=\"headerlink\" title=\"Jdk自带\"></a>Jdk自带</h3><p>jvisualvm：可以查看内存快照</p>\n<p>jconsole: 查看</p>\n<p>jps: 查看正在运行的虚拟机进程。</p>\n<ul>\n<li><p>反解析字节码：javap -verbose xxxxx</p>\n<p>把字节码解析为code区</p>\n</li>\n</ul>\n<h3 id=\"JVM参数\"><a href=\"#JVM参数\" class=\"headerlink\" title=\"JVM参数\"></a>JVM参数</h3><ul>\n<li>堆大小 最大：<code>-Xmx10m</code> ；初始： <code>-Xms10m</code></li>\n<li>栈内存大小：<code>-Xss10m</code></li>\n<li>堆新生代老年代比例：<code>-XX:NewRatio</code></li>\n<li>方法区（JDK1.8以前永久代）：初始：<code>-XX: PermSize=128m</code> 最大：<code>-XX:MaxPermSize=512m</code> </li>\n<li>元数据空间：初始：<code>-XX:MetaspaceSize=128m</code> 最大： <code>-XX:MaxMetaspaceSize=512m</code></li>\n<li>输出GC日志：-XX:+PrintGC</li>\n<li>逃逸分析开启/关闭： -XX:-DoEscapeAnalysis</li>\n</ul>\n"},{"title":"打造高效写作环境","date":"2022-01-04T10:50:19.000Z","cover":"https://raw.githubusercontent.com/sawyerRick/Assets/main/chaoxi.jpeg","_content":"\n# 打造高效写作环境\n\n[toc]\n\n2022零成本打造高效写作环境。\n\n此tutorial只对部分关键词和解决方案作记录，不搬运官方教程。\n\n关键词：\n\n1. Github Pages\n2. Hexo\n3. PicGo\n4. Typora\n\n## Blog搭建\n\n使用Github Pages和Hexo作为Blog搭建解决方案，好处是零成本，缺点是由于Github域名主键被ban，访问速度会受限（或者完全访问不了）。\n\n### Github Pages\n\n按Github Pages官方教程，搭建好后会得到一个 username.github.io 的地址。直接访问这个地址就能打开你的页面了，这时我们使用Hexo生成静态页面。\n\n### Hexo\n\nHexo一种是无服务器Blog部署的解决方案，具体教程见官网。\n\n下载好Hexo后熟悉几个常见命令：\n\n1. hexo new [title]，新建文章后，我们用Typora打开对文章进行编辑\n2. hexo server，本地调试\n3. hexo clean，清理hexo生成的静态页面和db.json\n4. hexo g，生成静态页面\n5. hexo d，部署到Github Pages（建议配置默认分支gh-pages）\n\n#### Back up\n\n备分推荐的解决方案是checkout一个新的分支，如hexo分支。\n\n使用hexo分支做.yml配置文件和.md文章文件的备分处理。\n\n使用gh-pages分支发布Github Pages。\n\n这样每次写文章，只需要（在hexo分支）：\n\n1. 新建文章：hexo new aNewPost\n2. 生成和部署：hexo clean && hexo g && hexo d（自动部署到gh-pages分支）\n3. 备分配置文件：git push\n\n#### Hexo主题\n\n推荐以下几款主题：\n\n1. Next\n2. Butterfly\n\n## 一键发布文章\n\n> 通过alias写一个小型脚本实现一键发布文章\n\nmacOS：vim ~/.zshrc，添加这样一条alias\n\n`alias dhexo=hexo clean && hexo g && hexo d && git commit -am 'backup' && git push`\n\n## 域名\n\nusername.github.io Github给出这样的域名肯定不够看，所以我们可以自己使用喜欢的域名。\n\n推荐：https://www.namesilo.com/\n\n买好域名后，可以在Github repo的setting里配置Github Pages的跳转域名。\n\n配置后，需要去买域名的管理页面，为自己域名配置一个A类地址（由Github Pages给出/可以直接Ping username.github.io获得）\n\n这样一来就完成了username.github.io和[自己的域名]的双向绑定。\n\n## 加速\n\n由于本站资源目前都在外网，考虑使用CDN进行访问加速。\n\n但是国内CDN需要域名备案，暂时搁置。\n\n## 图床\n\n折腾了半天本地图片，发现Typora和Hexo还是无法完美配合处理本地图片。\n\n于是直接选择图床作为文章的图片解决方案。\n\n图床：Github repo\n\n上传工具：PicGo\n","source":"_posts/打造高效写作环境.md","raw":"---\ntitle: 打造高效写作环境\ndate: 2022-01-04 18:50:19\ntags: tutorial\ncover: https://raw.githubusercontent.com/sawyerRick/Assets/main/chaoxi.jpeg\n---\n\n# 打造高效写作环境\n\n[toc]\n\n2022零成本打造高效写作环境。\n\n此tutorial只对部分关键词和解决方案作记录，不搬运官方教程。\n\n关键词：\n\n1. Github Pages\n2. Hexo\n3. PicGo\n4. Typora\n\n## Blog搭建\n\n使用Github Pages和Hexo作为Blog搭建解决方案，好处是零成本，缺点是由于Github域名主键被ban，访问速度会受限（或者完全访问不了）。\n\n### Github Pages\n\n按Github Pages官方教程，搭建好后会得到一个 username.github.io 的地址。直接访问这个地址就能打开你的页面了，这时我们使用Hexo生成静态页面。\n\n### Hexo\n\nHexo一种是无服务器Blog部署的解决方案，具体教程见官网。\n\n下载好Hexo后熟悉几个常见命令：\n\n1. hexo new [title]，新建文章后，我们用Typora打开对文章进行编辑\n2. hexo server，本地调试\n3. hexo clean，清理hexo生成的静态页面和db.json\n4. hexo g，生成静态页面\n5. hexo d，部署到Github Pages（建议配置默认分支gh-pages）\n\n#### Back up\n\n备分推荐的解决方案是checkout一个新的分支，如hexo分支。\n\n使用hexo分支做.yml配置文件和.md文章文件的备分处理。\n\n使用gh-pages分支发布Github Pages。\n\n这样每次写文章，只需要（在hexo分支）：\n\n1. 新建文章：hexo new aNewPost\n2. 生成和部署：hexo clean && hexo g && hexo d（自动部署到gh-pages分支）\n3. 备分配置文件：git push\n\n#### Hexo主题\n\n推荐以下几款主题：\n\n1. Next\n2. Butterfly\n\n## 一键发布文章\n\n> 通过alias写一个小型脚本实现一键发布文章\n\nmacOS：vim ~/.zshrc，添加这样一条alias\n\n`alias dhexo=hexo clean && hexo g && hexo d && git commit -am 'backup' && git push`\n\n## 域名\n\nusername.github.io Github给出这样的域名肯定不够看，所以我们可以自己使用喜欢的域名。\n\n推荐：https://www.namesilo.com/\n\n买好域名后，可以在Github repo的setting里配置Github Pages的跳转域名。\n\n配置后，需要去买域名的管理页面，为自己域名配置一个A类地址（由Github Pages给出/可以直接Ping username.github.io获得）\n\n这样一来就完成了username.github.io和[自己的域名]的双向绑定。\n\n## 加速\n\n由于本站资源目前都在外网，考虑使用CDN进行访问加速。\n\n但是国内CDN需要域名备案，暂时搁置。\n\n## 图床\n\n折腾了半天本地图片，发现Typora和Hexo还是无法完美配合处理本地图片。\n\n于是直接选择图床作为文章的图片解决方案。\n\n图床：Github repo\n\n上传工具：PicGo\n","slug":"打造高效写作环境","published":1,"updated":"2022-01-08T07:51:14.325Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky5j9fdy000lw3xwe2cqds8d","content":"<h1 id=\"打造高效写作环境\"><a href=\"#打造高效写作环境\" class=\"headerlink\" title=\"打造高效写作环境\"></a>打造高效写作环境</h1><p>[toc]</p>\n<p>2022零成本打造高效写作环境。</p>\n<p>此tutorial只对部分关键词和解决方案作记录，不搬运官方教程。</p>\n<p>关键词：</p>\n<ol>\n<li>Github Pages</li>\n<li>Hexo</li>\n<li>PicGo</li>\n<li>Typora</li>\n</ol>\n<h2 id=\"Blog搭建\"><a href=\"#Blog搭建\" class=\"headerlink\" title=\"Blog搭建\"></a>Blog搭建</h2><p>使用Github Pages和Hexo作为Blog搭建解决方案，好处是零成本，缺点是由于Github域名主键被ban，访问速度会受限（或者完全访问不了）。</p>\n<h3 id=\"Github-Pages\"><a href=\"#Github-Pages\" class=\"headerlink\" title=\"Github Pages\"></a>Github Pages</h3><p>按Github Pages官方教程，搭建好后会得到一个 username.github.io 的地址。直接访问这个地址就能打开你的页面了，这时我们使用Hexo生成静态页面。</p>\n<h3 id=\"Hexo\"><a href=\"#Hexo\" class=\"headerlink\" title=\"Hexo\"></a>Hexo</h3><p>Hexo一种是无服务器Blog部署的解决方案，具体教程见官网。</p>\n<p>下载好Hexo后熟悉几个常见命令：</p>\n<ol>\n<li>hexo new [title]，新建文章后，我们用Typora打开对文章进行编辑</li>\n<li>hexo server，本地调试</li>\n<li>hexo clean，清理hexo生成的静态页面和db.json</li>\n<li>hexo g，生成静态页面</li>\n<li>hexo d，部署到Github Pages（建议配置默认分支gh-pages）</li>\n</ol>\n<h4 id=\"Back-up\"><a href=\"#Back-up\" class=\"headerlink\" title=\"Back up\"></a>Back up</h4><p>备分推荐的解决方案是checkout一个新的分支，如hexo分支。</p>\n<p>使用hexo分支做.yml配置文件和.md文章文件的备分处理。</p>\n<p>使用gh-pages分支发布Github Pages。</p>\n<p>这样每次写文章，只需要（在hexo分支）：</p>\n<ol>\n<li>新建文章：hexo new aNewPost</li>\n<li>生成和部署：hexo clean &amp;&amp; hexo g &amp;&amp; hexo d（自动部署到gh-pages分支）</li>\n<li>备分配置文件：git push</li>\n</ol>\n<h4 id=\"Hexo主题\"><a href=\"#Hexo主题\" class=\"headerlink\" title=\"Hexo主题\"></a>Hexo主题</h4><p>推荐以下几款主题：</p>\n<ol>\n<li>Next</li>\n<li>Butterfly</li>\n</ol>\n<h2 id=\"一键发布文章\"><a href=\"#一键发布文章\" class=\"headerlink\" title=\"一键发布文章\"></a>一键发布文章</h2><blockquote>\n<p>通过alias写一个小型脚本实现一键发布文章</p>\n</blockquote>\n<p>macOS：vim ~/.zshrc，添加这样一条alias</p>\n<p><code>alias dhexo=hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; git commit -am &#39;backup&#39; &amp;&amp; git push</code></p>\n<h2 id=\"域名\"><a href=\"#域名\" class=\"headerlink\" title=\"域名\"></a>域名</h2><p>username.github.io Github给出这样的域名肯定不够看，所以我们可以自己使用喜欢的域名。</p>\n<p>推荐：<a href=\"https://www.namesilo.com/\">https://www.namesilo.com/</a></p>\n<p>买好域名后，可以在Github repo的setting里配置Github Pages的跳转域名。</p>\n<p>配置后，需要去买域名的管理页面，为自己域名配置一个A类地址（由Github Pages给出/可以直接Ping username.github.io获得）</p>\n<p>这样一来就完成了username.github.io和[自己的域名]的双向绑定。</p>\n<h2 id=\"加速\"><a href=\"#加速\" class=\"headerlink\" title=\"加速\"></a>加速</h2><p>由于本站资源目前都在外网，考虑使用CDN进行访问加速。</p>\n<p>但是国内CDN需要域名备案，暂时搁置。</p>\n<h2 id=\"图床\"><a href=\"#图床\" class=\"headerlink\" title=\"图床\"></a>图床</h2><p>折腾了半天本地图片，发现Typora和Hexo还是无法完美配合处理本地图片。</p>\n<p>于是直接选择图床作为文章的图片解决方案。</p>\n<p>图床：Github repo</p>\n<p>上传工具：PicGo</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"打造高效写作环境\"><a href=\"#打造高效写作环境\" class=\"headerlink\" title=\"打造高效写作环境\"></a>打造高效写作环境</h1><p>[toc]</p>\n<p>2022零成本打造高效写作环境。</p>\n<p>此tutorial只对部分关键词和解决方案作记录，不搬运官方教程。</p>\n<p>关键词：</p>\n<ol>\n<li>Github Pages</li>\n<li>Hexo</li>\n<li>PicGo</li>\n<li>Typora</li>\n</ol>\n<h2 id=\"Blog搭建\"><a href=\"#Blog搭建\" class=\"headerlink\" title=\"Blog搭建\"></a>Blog搭建</h2><p>使用Github Pages和Hexo作为Blog搭建解决方案，好处是零成本，缺点是由于Github域名主键被ban，访问速度会受限（或者完全访问不了）。</p>\n<h3 id=\"Github-Pages\"><a href=\"#Github-Pages\" class=\"headerlink\" title=\"Github Pages\"></a>Github Pages</h3><p>按Github Pages官方教程，搭建好后会得到一个 username.github.io 的地址。直接访问这个地址就能打开你的页面了，这时我们使用Hexo生成静态页面。</p>\n<h3 id=\"Hexo\"><a href=\"#Hexo\" class=\"headerlink\" title=\"Hexo\"></a>Hexo</h3><p>Hexo一种是无服务器Blog部署的解决方案，具体教程见官网。</p>\n<p>下载好Hexo后熟悉几个常见命令：</p>\n<ol>\n<li>hexo new [title]，新建文章后，我们用Typora打开对文章进行编辑</li>\n<li>hexo server，本地调试</li>\n<li>hexo clean，清理hexo生成的静态页面和db.json</li>\n<li>hexo g，生成静态页面</li>\n<li>hexo d，部署到Github Pages（建议配置默认分支gh-pages）</li>\n</ol>\n<h4 id=\"Back-up\"><a href=\"#Back-up\" class=\"headerlink\" title=\"Back up\"></a>Back up</h4><p>备分推荐的解决方案是checkout一个新的分支，如hexo分支。</p>\n<p>使用hexo分支做.yml配置文件和.md文章文件的备分处理。</p>\n<p>使用gh-pages分支发布Github Pages。</p>\n<p>这样每次写文章，只需要（在hexo分支）：</p>\n<ol>\n<li>新建文章：hexo new aNewPost</li>\n<li>生成和部署：hexo clean &amp;&amp; hexo g &amp;&amp; hexo d（自动部署到gh-pages分支）</li>\n<li>备分配置文件：git push</li>\n</ol>\n<h4 id=\"Hexo主题\"><a href=\"#Hexo主题\" class=\"headerlink\" title=\"Hexo主题\"></a>Hexo主题</h4><p>推荐以下几款主题：</p>\n<ol>\n<li>Next</li>\n<li>Butterfly</li>\n</ol>\n<h2 id=\"一键发布文章\"><a href=\"#一键发布文章\" class=\"headerlink\" title=\"一键发布文章\"></a>一键发布文章</h2><blockquote>\n<p>通过alias写一个小型脚本实现一键发布文章</p>\n</blockquote>\n<p>macOS：vim ~/.zshrc，添加这样一条alias</p>\n<p><code>alias dhexo=hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; git commit -am &#39;backup&#39; &amp;&amp; git push</code></p>\n<h2 id=\"域名\"><a href=\"#域名\" class=\"headerlink\" title=\"域名\"></a>域名</h2><p>username.github.io Github给出这样的域名肯定不够看，所以我们可以自己使用喜欢的域名。</p>\n<p>推荐：<a href=\"https://www.namesilo.com/\">https://www.namesilo.com/</a></p>\n<p>买好域名后，可以在Github repo的setting里配置Github Pages的跳转域名。</p>\n<p>配置后，需要去买域名的管理页面，为自己域名配置一个A类地址（由Github Pages给出/可以直接Ping username.github.io获得）</p>\n<p>这样一来就完成了username.github.io和[自己的域名]的双向绑定。</p>\n<h2 id=\"加速\"><a href=\"#加速\" class=\"headerlink\" title=\"加速\"></a>加速</h2><p>由于本站资源目前都在外网，考虑使用CDN进行访问加速。</p>\n<p>但是国内CDN需要域名备案，暂时搁置。</p>\n<h2 id=\"图床\"><a href=\"#图床\" class=\"headerlink\" title=\"图床\"></a>图床</h2><p>折腾了半天本地图片，发现Typora和Hexo还是无法完美配合处理本地图片。</p>\n<p>于是直接选择图床作为文章的图片解决方案。</p>\n<p>图床：Github repo</p>\n<p>上传工具：PicGo</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cky5j9fdv000hw3xw5m9fbd77","category_id":"cky5j9fdx000kw3xw10ql4m3m","_id":"cky5j9fe1000pw3xwgf322gc2"}],"PostTag":[{"post_id":"cky5j9fdg0001w3xwgzun2zsv","tag_id":"cky5j9fdl0004w3xw8rnhf65x","_id":"cky5j9fdq0008w3xw7l8wdcm7"},{"post_id":"cky5j9fdj0003w3xwhfa3b2xg","tag_id":"cky5j9fdl0004w3xw8rnhf65x","_id":"cky5j9fdr000aw3xw3ezygygs"},{"post_id":"cky5j9fdn0006w3xweu9b1mur","tag_id":"cky5j9fdl0004w3xw8rnhf65x","_id":"cky5j9fdr000bw3xwh8p893u0"},{"post_id":"cky5j9fdt000cw3xw6i876lqu","tag_id":"cky5j9fdl0004w3xw8rnhf65x","_id":"cky5j9fdu000ew3xweo97c7aa"},{"post_id":"cky5j9fdu000dw3xwe6f50h4j","tag_id":"cky5j9fdl0004w3xw8rnhf65x","_id":"cky5j9fdv000gw3xwa0qd2fdf"},{"post_id":"cky5j9fdv000fw3xwcqun1ljm","tag_id":"cky5j9fdw000iw3xwhka1g26c","_id":"cky5j9fdz000nw3xwgutvb1mh"},{"post_id":"cky5j9fdv000hw3xw5m9fbd77","tag_id":"cky5j9fdz000mw3xw4c3s9r01","_id":"cky5j9fe1000qw3xw2zfleu1e"},{"post_id":"cky5j9fdw000jw3xw1ja47ans","tag_id":"cky5j9fdw000iw3xwhka1g26c","_id":"cky5j9fe2000sw3xwc9sc3qpt"},{"post_id":"cky5j9fdy000lw3xwe2cqds8d","tag_id":"cky5j9fe1000rw3xwglp33n7a","_id":"cky5j9fe2000tw3xw44r507ow"}],"Tag":[{"name":"Docker","_id":"cky5j9fdl0004w3xw8rnhf65x"},{"name":"Java","_id":"cky5j9fdw000iw3xwhka1g26c"},{"name":"init_commit","_id":"cky5j9fdz000mw3xw4c3s9r01"},{"name":"tutorial","_id":"cky5j9fe1000rw3xwglp33n7a"}]}}