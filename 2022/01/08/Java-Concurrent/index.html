<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java-Concurrent | Windy Place</title><meta name="keywords" content="Java"><meta name="author" content="Serial"><meta name="copyright" content="Serial"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java高并发学习[TOC] 基本概念并发：多个任务交替执行 并行：同时执行 临界区：一种公共资源，但是同一时间只能被一个线程访问。 饥饿：线程缺少资源，一直无法执行。 活锁：互相谦让，但还是不能满足执行条件。 并发级别阻塞：得到锁之前，无法执行。 无饥饿：  公平锁 不会出现饥饿。  非公平锁 可能出现饥饿。  无障碍 乐观，并发程度低 线程之间不会因为临界区的问题被挂起，但检测到冲突就回滚。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java-Concurrent">
<meta property="og:url" content="https://www.serialrick.top/2022/01/08/Java-Concurrent/index.html">
<meta property="og:site_name" content="Windy Place">
<meta property="og:description" content="Java高并发学习[TOC] 基本概念并发：多个任务交替执行 并行：同时执行 临界区：一种公共资源，但是同一时间只能被一个线程访问。 饥饿：线程缺少资源，一直无法执行。 活锁：互相谦让，但还是不能满足执行条件。 并发级别阻塞：得到锁之前，无法执行。 无饥饿：  公平锁 不会出现饥饿。  非公平锁 可能出现饥饿。  无障碍 乐观，并发程度低 线程之间不会因为临界区的问题被挂起，但检测到冲突就回滚。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://www.serialrick.top/images/JavaLogo.png">
<meta property="article:published_time" content="2022-01-08T07:45:18.000Z">
<meta property="article:modified_time" content="2022-08-12T16:45:54.838Z">
<meta property="article:author" content="Serial">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.serialrick.top/images/JavaLogo.png"><link rel="shortcut icon" href="/images/avt.png"><link rel="canonical" href="https://www.serialrick.top/2022/01/08/Java-Concurrent/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java-Concurrent',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2022-08-13 00:45:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avt.png" onerror="onerror=null;src='/images/tenor.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">10</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/Introspection/"><i class="fa-fw fas fa-archive"></i><span> Introspection</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/JavaLogo.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Windy Place</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/Introspection/"><i class="fa-fw fas fa-archive"></i><span> Introspection</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java-Concurrent</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-01-08T07:45:18.000Z" title="Created 2022-01-08 15:45:18">2022-01-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-08-12T16:45:54.838Z" title="Updated 2022-08-13 00:45:54">2022-08-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java-Concurrent"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Java高并发学习"><a href="#Java高并发学习" class="headerlink" title="Java高并发学习"></a>Java高并发学习</h1><p>[TOC]</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>并发：多个任务交替执行</p>
<p>并行：同时执行</p>
<p>临界区：一种公共资源，但是同一时间只能被一个线程访问。</p>
<p>饥饿：线程缺少资源，一直无法执行。</p>
<p>活锁：互相谦让，但还是不能满足执行条件。</p>
<h3 id="并发级别"><a href="#并发级别" class="headerlink" title="并发级别"></a>并发级别</h3><p>阻塞：得到锁之前，无法执行。</p>
<p>无饥饿：</p>
<ol>
<li><p>公平锁</p>
<p>不会出现饥饿。</p>
</li>
<li><p>非公平锁</p>
<p>可能出现饥饿。</p>
</li>
<li><p>无障碍</p>
<p>乐观，并发程度低</p>
<p>线程之间不会因为临界区的问题被挂起，但检测到冲突就回滚。</p>
</li>
<li><p>无锁</p>
<p>所有的线程都能访问临界区。cas</p>
</li>
</ol>
<h3 id="JMM-Java内存模型"><a href="#JMM-Java内存模型" class="headerlink" title="JMM Java内存模型"></a>JMM Java内存模型</h3><p>并发三大特性：</p>
<ol>
<li><p>原子性</p>
<p>一个最小的操作，不会被其他线程干扰。</p>
</li>
<li><p>可见性</p>
<p>当一个线程修改了共享变量的值，其他线程立即可见。如果不使用volatile，变量则暂存在Java工作内存中，不会立即刷新主存。</p>
</li>
<li><p>有序性</p>
<p>总结为：在本线程内观察，所有的操作都是有序的；但在一个线程中观察另一个线程，所有的操作都是无序的。</p>
<p>无序主要体现在<strong>指令重排序</strong>和<strong>工作内存和主存同步延迟</strong>现象。</p>
</li>
</ol>
<p>volatile关键字保证了有序性，可见性。</p>
<p>synchronized保证了全部特性。</p>
<h2 id="线程的基本操作"><a href="#线程的基本操作" class="headerlink" title="线程的基本操作"></a>线程的基本操作</h2><ol>
<li>新建</li>
<li>终止 stop</li>
<li>中断 interrupt</li>
<li>等待 wait 和通知 notify</li>
<li>（废弃）挂起 suspend和继续执行 resume</li>
<li>等待线程结束 join 和让出cpu yeild</li>
</ol>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><ol>
<li>初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。</li>
<li>运行(RUNNABLE)：可运行的，由CPU进行调度运行。</li>
<li>阻塞(BLOCKED)：synchronized请求锁monitor阻塞。</li>
<li>等待(WAITING)：object.wati()阻塞等待，需要object.notify()来唤醒。IO。</li>
<li>超时等待(TIMED_WAITING)：Thread.Sleep()睡眠，超时唤醒，或中断唤醒。</li>
<li>终止(TERMINATED)：表示该线程已经执行完毕。</li>
</ol>
<h2 id="驻守后台-守护线程Deamon"><a href="#驻守后台-守护线程Deamon" class="headerlink" title="驻守后台-守护线程Deamon"></a>驻守后台-守护线程Deamon</h2><p>线程有两种：守护线程，用户线程</p>
<p>正如名字一样，是系统的守护者，在后台守护用户线程。</p>
<p>如果所有用户线程都结束了，那么守护线程会默默退出。</p>
<p>默认创建的是用户线程，不会因main线程的结束而退出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeamonThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>); <span class="comment">// 设置守护线程后，主线程结束，守护线程默默退出</span></span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java并发工具"><a href="#Java并发工具" class="headerlink" title="Java并发工具"></a>Java并发工具</h2><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><ul>
<li>同步类</li>
<li>同步对象</li>
<li>同步方法</li>
<li>同步静态方法/相当于同步类</li>
<li>同步静态变量/相当于同步类</li>
</ul>
<h3 id="Object-属于管程的实现"><a href="#Object-属于管程的实现" class="headerlink" title="Object / 属于管程的实现"></a>Object / 属于管程的实现</h3><p>只能与Synchronized配合使用</p>
<ul>
<li>obj.wait(); 释放锁monitor，阻塞等待notify和获得锁。</li>
<li>obj.notify(); 唤醒随机一个因wait()阻塞的对象。</li>
<li>obj.notifyAll(); 唤醒所有因wait()阻塞的对象。</li>
</ul>
<h2 id="JUT-同步工具"><a href="#JUT-同步工具" class="headerlink" title="JUT 同步工具"></a>JUT 同步工具</h2><h3 id="可重入锁ReentrantLock"><a href="#可重入锁ReentrantLock" class="headerlink" title="可重入锁ReentrantLock"></a>可重入锁ReentrantLock</h3><p>可以反复进入的锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line">lock.lock();</span><br><span class="line">lock.unlock();</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>

<h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><ol>
<li>lock(); 锁</li>
<li>tryLock(); 请求锁，失败返回false</li>
<li>tryLock(time, unit) 请求锁，time unit后超时，返回false</li>
<li>lockInterruptibly(); 可中断锁，请求锁时优先响应中断，中断后会放弃请求，并释放已有的锁。</li>
<li>unlock() ; 释放锁</li>
</ol>
<h3 id="可重入锁的好搭档Condition-管程实现"><a href="#可重入锁的好搭档Condition-管程实现" class="headerlink" title="可重入锁的好搭档Condition/管程实现"></a>可重入锁的好搭档Condition/管程实现</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>与Object的类似。</p>
<ul>
<li>await();</li>
<li>signal();</li>
<li>signalAll();</li>
</ul>
<h3 id="倒计数器CountDownLatch"><a href="#倒计数器CountDownLatch" class="headerlink" title="倒计数器CountDownLatch"></a>倒计数器CountDownLatch</h3><p>倒数计数器latch，数到0释放。</p>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul>
<li>await();阻塞等待count为0</li>
<li>countDown()，count–;</li>
</ul>
<h3 id="循环屏障CyclicBarrier"><a href="#循环屏障CyclicBarrier" class="headerlink" title="循环屏障CyclicBarrier"></a>循环屏障CyclicBarrier</h3><p>把线程阻止到屏障外。</p>
<h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><ul>
<li>await(); 当n个线程都达到屏障后，各个线程才会继续运行。</li>
</ul>
<h3 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h3><p>表示可进入临界区/可获得资源的线程数量。</p>
<p>达到0时，阻塞请求的线程。</p>
<h4 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h4><ul>
<li>acquire(): 获取，数量-1</li>
<li>release(): 释放，数量+1</li>
</ul>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>为了避免系统频繁的创建和销毁线程浪费资源，让创建的线程复用。用空间换时间。</p>
<p>创建线程==》从线程池中获取活跃线程，销毁线程==》把线程还回去。</p>
<h4 id="线程池如何重用？"><a href="#线程池如何重用？" class="headerlink" title="线程池如何重用？"></a>线程池如何重用？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池核心代码：</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Runnable task;</span><br><span class="line">  <span class="keyword">final</span> T result;</span><br><span class="line">  RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">    <span class="keyword">this</span>.task = task;</span><br><span class="line">    <span class="keyword">this</span>.result = result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    task.run(); <span class="comment">// *调用run()方法</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="创建多少线程？"><a href="#创建多少线程？" class="headerlink" title="创建多少线程？"></a>创建多少线程？</h4><p>不需要太精确，但是不能过大或过小。需要考虑CPU数量，内存大小等因素。</p>
<p>一般来说，公式：threads = Ncpu * Ucpu * (1 + W / C)</p>
<p><strong>公式解读：</strong> 重点在于区分任务是IO密集型（W）还是计算密集型（C）：如果是IO密集型，则W很大，所以应该开更多线程；如果是计算密集型，则C很大，所以开更多的线程也没用。</p>
<ul>
<li>Ncpu：Cpu数量</li>
<li>Ucpu：期望的Cpu使用率</li>
<li>W / C： 等待时间与计算时间的比值</li>
</ul>
<h3 id="JDK的Executor框架"><a href="#JDK的Executor框架" class="headerlink" title="JDK的Executor框架"></a>JDK的Executor框架</h3><p>Executors是一个线程工厂。通过Executors可以取得一个拥有特定功能的线程池。</p>
<h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>newFixedThreadPool() ：返回一个固定数量的线程池。有任务提交时，若线程池有空闲线程，立即执行。若无，任务放在队列中，空闲时执行。</li>
<li>newSingleThreadExecutor()：只有一个线程的线程池。也有任务队列。</li>
<li>newCachedThreadPool()：一个可根据实际情况调整线程数量的线程池。如果全部线程都在工作，有新任务提交时，就创建新线程处理任务。</li>
<li>newSingleThreadScheduledExecutor()：线程池大小为1，扩展了延时任务功能。</li>
<li>newScheduledThreadPool()：同上，但是可以指定线程池数量</li>
</ul>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li>execute()：无返回值的提交</li>
<li>submit()：有返回值的提交（异步的概念）</li>
<li>shutdown()：不允许提交任务，会立即返回。可以用awaitTermination等待全部任务执行完毕。</li>
<li>shutdownNow()：会调用每个线程的interrupt。</li>
<li>isTeminated()：是否执行完毕</li>
</ul>
<h4 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这两类属于计划任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span></span><br><span class="line"><span class="function">  <span class="comment">// 测试</span></span></span><br><span class="line"><span class="function">ScheduledExecutorService executor </span>= Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>计划任务的三个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在给定时间对任务进行调度</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                       <span class="keyword">long</span> delay, TimeUnit unit);</span><br><span class="line"><span class="comment">// 周期性调度，以开始时间为起点，固定频率。</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                                  <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                  <span class="keyword">long</span> period,</span><br><span class="line">                                                  TimeUnit unit);</span><br><span class="line"><span class="comment">// 周期性调度，以上一个任务结束时间为起点，固定频率。</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                     <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                     <span class="keyword">long</span> delay,</span><br><span class="line">                                                     TimeUnit unit);</span><br></pre></td></tr></table></figure>

<h4 id="计划任务特例"><a href="#计划任务特例" class="headerlink" title="计划任务特例"></a>计划任务特例</h4><p>执行时间超过调度时间会发生什么？</p>
<ul>
<li>scheduleAtFixedRate(): 立即执行</li>
<li>scheduleWithFixedDelay()：等待调度时间才执行</li>
</ul>
<h3 id="线程池内部实现-ThreadPoolExecutor"><a href="#线程池内部实现-ThreadPoolExecutor" class="headerlink" title="线程池内部实现 ThreadPoolExecutor"></a>线程池内部实现 ThreadPoolExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数解析：</p>
<ol>
<li>corePoolSize 线程数量</li>
<li>maximumPoolSize 最大线程数量</li>
<li>keepAliveTime 当<strong>线程数量</strong>超过<strong>corePoolSize数量</strong>，在多长时间后会被摧毁</li>
<li>unit <strong>keepAliveTime</strong>的时间单位</li>
<li><strong>workQueue</strong> 任务队列，被提交但尚未执行的任务，使用<strong>BlockingQueue</strong>接口对象</li>
<li>threadFactory 用于创建线程的工厂</li>
<li><strong>handler</strong> 拒绝策略。任务太多来不及处理，如何拒绝任务</li>
</ol>
<h4 id="核心参数之间的关系"><a href="#核心参数之间的关系" class="headerlink" title="核心参数之间的关系"></a>核心参数之间的关系</h4><p>添加线程：</p>
<p>​    小于corePoolSize：分配执行</p>
<p>​    大于corePoolSize：加入任务队列，等待执行</p>
<p>加入任务队列：</p>
<p>​    看具体任务队列处理办法。</p>
<p>任务队列满了，提交线程池：</p>
<p>​    创建新线程执行，如果线程总数大于Max，执行拒绝策略。</p>
<h4 id="线程池何时创建线程？"><a href="#线程池何时创建线程？" class="headerlink" title="线程池何时创建线程？"></a>线程池何时创建线程？</h4><ul>
<li>线程池创建后，无任何线程，此时每提交一个任务，就会根据线程工厂创建一个线程，直到线程数量等于核心线程数量，提交任务队列处理。</li>
<li>任务队列提交失败后，会创建线程或执行拒绝策略。</li>
</ul>
<h4 id="任务队列-workQueue"><a href="#任务队列-workQueue" class="headerlink" title="任务队列 workQueue"></a>任务队列 workQueue</h4><ul>
<li>直接提交的队列：使用<strong>SynchronousQueue</strong>，新的任务直接提交给线程池。</li>
<li>有界的任务队列：使用<strong>ArrayBlockingQueue</strong>，如果超过队列大小，提交线程池。</li>
<li>无界的任务队列：使用<strong>LinkedBlockingQueue</strong>，除非系统资源耗尽，否则无限入队。</li>
<li>优先任务队列：使用<strong>PriorityBlockingQueue</strong>，可以控制任务的先后执行顺序，是一个特殊的无界队列。</li>
</ul>
<h4 id="任务队列对应实现"><a href="#任务队列对应实现" class="headerlink" title="任务队列对应实现"></a>任务队列对应实现</h4><ul>
<li><p>newFixedThreadPool(int nThreads)</p>
<p>使用<strong>无界任务队列LinkedBlockingQueue</strong>，corePoolSize可以和maximumPoolSize相等。当线程数到达max时且任务提交非常频繁，任务队列迅速膨胀耗尽资源。</p>
</li>
<li><p>newSingleThreadExecutor()</p>
<p>同上，不过max大小为1。</p>
</li>
<li><p>newCachedThreadPool()</p>
<p>使用<strong>直接提交队列SynchronousQueue</strong>，corePoolSize为0，为了能直接提交到任务队列，put任务后会立即被take去创建新线程执行。60秒内回收新线程。</p>
<p>同样，也可能因为大量任务耗尽资源。</p>
</li>
</ul>
<h4 id="拒绝策略-handler"><a href="#拒绝策略-handler" class="headerlink" title="拒绝策略 handler"></a>拒绝策略 handler</h4><p>应对超负载。拒绝策略如下：</p>
<ul>
<li><strong>AbortPolicy策略</strong>：直接抛异常，阻止系统正常工作。</li>
<li><strong>CallerRunsPolicy</strong>：在调用者栈中运行当前被丢弃的任务。</li>
<li><strong>DiscardOldestPolicy策略</strong>：丢弃最老的一个任务，并再次提交该任务。</li>
<li><strong>DiscardPolicy</strong>：默默丢弃无法处理的任务。</li>
</ul>
<h4 id="自定义线程创建：ThreadFactory"><a href="#自定义线程创建：ThreadFactory" class="headerlink" title="自定义线程创建：ThreadFactory"></a>自定义线程创建：ThreadFactory</h4><p>线程池是为了线程复用，那么开始的线程从哪来？ThreadFactory</p>
<p>主要用处：设置线程名字、组、优先级、守护线程等信息。</p>
<h2 id="JDK并发容器"><a href="#JDK并发容器" class="headerlink" title="JDK并发容器"></a>JDK并发容器</h2><p>jdk提供了一系列线程安全的并发容器。</p>
<h4 id="高并发容器"><a href="#高并发容器" class="headerlink" title="高并发容器"></a>高并发容器</h4><ul>
<li>ConcurrentHashMap : 线程安全的HashMap</li>
<li>CopyOnWriteArrayList: 线程安全的ArrayList，适合读多写少。</li>
<li>ConcurrentLinkedListQueue：线程安全的LinkedList</li>
<li>BlockingQueue：ArrayBlockingQueue阻塞队列。</li>
<li>ConcurrentSkipListMap: 线程安全跳表。</li>
</ul>
<h4 id="普通线程安全容器"><a href="#普通线程安全容器" class="headerlink" title="普通线程安全容器"></a>普通线程安全容器</h4><ul>
<li><p>HashTable</p>
</li>
<li><p>Vector</p>
</li>
<li><p>Collections.synchronizedXXX(List/Map)包装的容器</p>
<p>此方法与HashTable、Vector的线程安全原理相似，都是一律使用Synchronized关键字来实现。</p>
</li>
</ul>
<h3 id="阻塞队列-BlockingQueue"><a href="#阻塞队列-BlockingQueue" class="headerlink" title="阻塞队列 BlockingQueue"></a>阻塞队列 BlockingQueue</h3><p>阻塞队列接口有许多不同的实现。</p>
<ul>
<li><p><strong>ArrayBlockingQueue</strong></p>
<p>数组实现的阻塞队列。不能扩容。</p>
</li>
<li><p><strong>SynchronousQueue</strong></p>
<p>一个特殊的阻塞队列，其实并不存放任何数据。put操作要等待take操作，take操作要等待put操作。</p>
</li>
<li><p><strong>LinkedBlockingQueue</strong></p>
<p>链表实现的阻塞队列。</p>
</li>
<li><p><strong>PriorityBlockingQueue</strong></p>
<p>带优先级的阻塞队列</p>
</li>
</ul>
<h2 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h2><ol>
<li><p>减少锁持有时间</p>
<p>只有在必要时进行同步。</p>
</li>
<li><p>减少锁粒度</p>
<p>分段锁，如ConcurrentHashMap被分为16个段</p>
<p>运气好的情况下，可以并发16个线程。</p>
<p>缺点，系统需要全局锁时，消耗增大。如需要取得size()，就要取得所有是分段锁。</p>
</li>
<li><p>用读写分离锁来替换独占锁</p>
<p>写的时候不能写，读的时候可以读写。如CopyOnWriteArrayList</p>
</li>
<li><p>锁分离</p>
<p>如LinkedBlockingQueue中，take()操作和put()操作可以并发。只有take()和take()/put()和put()之间存在竞争，所以可以把take()和put()分离。</p>
</li>
<li><p>锁粗化</p>
<p>如果对同一个锁不停地请求，同步和释放。会浪费宝贵的资源，不利于性能优化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    <span class="comment">// do sth.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该改成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock) &#123;  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;      <span class="comment">// do sth.  &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>把synchronized，锁粗化。</p>
</li>
</ol>
<h3 id="Java虚拟机锁优化"><a href="#Java虚拟机锁优化" class="headerlink" title="Java虚拟机锁优化"></a>Java虚拟机锁优化</h3><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>核心思想：如果一个线程获得一个锁，那么再次请求时，如果锁没有被其他线程获取，就不需要任何同步操作。</p>
<ul>
<li>原理：尝试使用CAS把获取到这个锁的线程ID记录到<strong>锁对象头的标记字段</strong>中，如果锁没有被其他线程获取，那么获取过的线程再次请求锁时，不需要进行任何同步操作。</li>
<li>锁对象头的标记字段：偏向线程ID，偏向时间戳，GC年龄–01</li>
</ul>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>如果偏向锁失败，虚拟机不会立即挂起线程，会尝试轻量级锁。</p>
<ul>
<li><p>原理：尝试用CAS将<strong>锁对象头的标记字段</strong>指向一个线程栈中的<strong>锁记录空间</strong></p>
<p>如果操作成功，那么该线程获得了锁。</p>
</li>
<li><p>锁对象头的标记字段：指向锁记录的指针–00</p>
</li>
</ul>
<p>如果有，顺利进入临界区，否则说明其他线程获得了锁。膨胀为重量级锁。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>锁膨胀后，为了避免线程真实地挂起，虚拟机还会做一次努力-自旋。</p>
<p>虚拟会会让当前线程做几个空循环（默认10），循环后如果可以得到锁，那么就进入临界区，否则挂起。</p>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p>
<p>Mutex Lock也是通过CAS和挂起等待的操作来实现的，不过这部分由内核处理，Java的锁大部分在用户态实现。</p>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>Java虚拟机在JIT编译时，会除去不可能存在共享资源竞争的锁。</p>
<p>根据<code>逃逸分析</code>技术，判断一个变量是否会逃出某一个作用域。</p>
<p>如果不会，那就不必要加锁。</p>
<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>ThreadLocal:针对某一个线程的全局变量</p>
<p>stacic:全部线程的全局变量</p>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>多线程环境中。有一个处理流程，每个流程都需要操作同一个上下文。</p>
<p>最简单的做法是:doSth1(x,x,x,ctx),doSth2(x,x,x,ctx),doSth3(x,x,x,ctx)… 使用参数传递上下文。</p>
<p>错误的做法是：使用static ctx来使ctx变成全局变量。</p>
<p>正确的做法：使用LocalMap使ctx线程隔离。</p>
<h4 id="引用分析"><a href="#引用分析" class="headerlink" title="引用分析"></a>引用分析</h4><p><img src="../../../Notes/Java/assets/%25E6%2588%25AA%25E5%25B1%258F2020-03-10%25E4%25B8%258B%25E5%258D%25884.52.01.png" alt="截屏2020-03-10下午4.52.01"></p>
<h4 id="Thread原理"><a href="#Thread原理" class="headerlink" title="Thread原理"></a>Thread原理</h4><p><code>ThreadLocal</code>的实现是这样的：每个<code>Thread</code> 维护一个 <code>ThreadLocalMap</code> ，这个map的 <code>key</code> 是 <code>ThreadLocal</code>实例本身，<code>value</code> 是真正需要存储的对象。</p>
<p>也就是说 <code>ThreadLocal</code> 本身并不存储值，它只是作为一个 <code>key</code> 来让线程从 <code>ThreadLocalMap</code> 获取 <code>value</code>。值得注意的是图中的虚线，表示 <code>ThreadLocalMap</code> 是使用 <code>ThreadLocal</code> 的弱引用作为 <code>Key</code> 的，弱引用的对象在 GC 时会被回收。</p>
<h4 id="Thread内存泄漏"><a href="#Thread内存泄漏" class="headerlink" title="Thread内存泄漏"></a>Thread内存泄漏</h4><p><code>ThreadLocalMap</code>使用<code>ThreadLocal</code>的弱引用作为<code>key</code>，如果一个<code>ThreadLocal</code>没有外部强引用来引用它，那么系统 GC 的时候，这个<code>ThreadLocal</code>势必会被回收，这样一来，<code>ThreadLocalMap</code>中就会出现<code>key</code>为<code>null</code>的<code>Entry</code>，就没有办法访问这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>，如果当前线程再迟迟不结束的话，这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>就会一直存在一条强引用链：<code>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</code>永远无法回收，造成内存泄漏。</p>
<p>其实，<code>ThreadLocalMap</code>的设计中已经考虑到这种情况，也加上了一些防护措施：在<code>ThreadLocal</code>的<code>get()</code>,<code>set()</code>,<code>remove()</code>的时候都会清除线程<code>ThreadLocalMap</code>里所有<code>key</code>为<code>null</code>的<code>value</code>。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>set方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// threadLocal的set方法public void set(T value) &#123;  Thread t = Thread.currentThread(); // 获取当前线程  ThreadLocalMap map = getMap(t); // 从当前线程里获取map(这个map是线程私有的)  if (map != null)    map.set(this, value); // 关键点，调用线程私有的map的set方法  else    createMap(t, value);&#125;// 线程私有的map的set方法的关键步骤int i = key.threadLocalHashCode &amp; (len-1); // 除留余数法// 发生hash冲突（原因：一个线程中的ThreadLocal变量太多）// 开地址法，和HashMap相比，HashMap采用的是链地址法for (Entry e = tab[i];     e != null;     e = tab[i = nextIndex(i, len)]) &#123;  ThreadLocal&lt;?&gt; k = e.get();  if (k == key) &#123;    e.value = value;    return;  &#125;  if (k == null) &#123;    replaceStaleEntry(key, value, i);    return;  &#125;&#125;// 最关键的赋值步骤：tab[i] = new Entry(key, value); // key为threadLocal，value是自定义值</span></span><br></pre></td></tr></table></figure>

<h4 id="常见使用"><a href="#常见使用" class="headerlink" title="常见使用"></a>常见使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;SimpleDateFormat&gt; t = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>因为SimpleDateFormat.parse()方法不是线程安全的。</p>
<p>因为SimpleDateFormat中的Calendar是线程不安全的。</p>
<p>多个线程之间共享变量calendar，并修改calendar。因此在多线程环境下，当多个线程同时使用相同的SimpleDateFormat对象（如static修饰）的话，如调用format方法时，多个线程会同时调用calender.setTime方法，导致time被别的线程修改，因此线程是不安全的。</p>
<h4 id="ThreadLocal原理与实现"><a href="#ThreadLocal原理与实现" class="headerlink" title="ThreadLocal原理与实现"></a>ThreadLocal原理与实现</h4><p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。</p>
<p>当调用一个 ThreadLocal 的set方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。</p>
<h4 id="ThreadLocal-业务"><a href="#ThreadLocal-业务" class="headerlink" title="ThreadLocal 业务"></a>ThreadLocal 业务</h4><p>…</p>
<h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><h3 id="CAS-Compare-And-Set"><a href="#CAS-Compare-And-Set" class="headerlink" title="CAS Compare And Set"></a>CAS Compare And Set</h3><p>原子操作。</p>
<p>比较然后设置。</p>
<p>三个参数:</p>
<ul>
<li>变量V</li>
<li>预期值E</li>
<li>新值N</li>
</ul>
<p>仅当V等于E时，把V更新为N。否则失败。</p>
<p>这样就保证了只有一个线程可以操作成功。</p>
<h3 id="无锁的线程安全整数-AtomicInteger"><a href="#无锁的线程安全整数-AtomicInteger" class="headerlink" title="无锁的线程安全整数: AtomicInteger"></a>无锁的线程安全整数: AtomicInteger</h3><p>核心字段：value，valueOffset</p>
<ul>
<li>value 保存值</li>
<li>valueOffset 保存偏移量，变量在内存中的地址。</li>
</ul>
<p>通过死循环CAS实现线程安全。</p>
<h3 id="无锁的对象引用-AtomicReference"><a href="#无锁的对象引用-AtomicReference" class="headerlink" title="无锁的对象引用:AtomicReference"></a>无锁的对象引用:AtomicReference</h3><h3 id="带有时间戳的对象引用：AtomicStampedReference"><a href="#带有时间戳的对象引用：AtomicStampedReference" class="headerlink" title="带有时间戳的对象引用：AtomicStampedReference"></a>带有时间戳的对象引用：AtomicStampedReference</h3><p>解决了CAS中不能判断ABA的问题。</p>
<p>加入时间戳参数，只有时间戳也匹配时才更改新值。</p>
<h3 id="数组也能无锁：AtomicIntegerArray"><a href="#数组也能无锁：AtomicIntegerArray" class="headerlink" title="数组也能无锁：AtomicIntegerArray"></a>数组也能无锁：AtomicIntegerArray</h3><h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h2><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><ul>
<li>synchronized</li>
<li>ReentrantLock</li>
</ul>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><ul>
<li>CAS实现</li>
<li>版本号机制实现（MVCC）</li>
</ul>
<h2 id="synchronized的使用细节"><a href="#synchronized的使用细节" class="headerlink" title="synchronized的使用细节"></a>synchronized的使用细节</h2><ul>
<li>修饰方法：锁实例</li>
<li>修饰静态方法：锁类</li>
<li>修饰对象：锁对象</li>
</ul>
<h2 id="Syn和Lock实现原理"><a href="#Syn和Lock实现原理" class="headerlink" title="Syn和Lock实现原理"></a>Syn和Lock实现原理</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>使用synchronized，JVM会有相应的锁优化，（偏向，轻量级，自旋）</li>
<li>lock可以是公平锁，synchronized不是公平锁</li>
<li>lock有许多好用的特性：trylock、可中断，公平，配合Condition使用。</li>
</ul>
<h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul>
<li>可重入</li>
</ul>
<h3 id="1-synchronized-syn-原理"><a href="#1-synchronized-syn-原理" class="headerlink" title="1.synchronized(syn)原理"></a>1.synchronized(syn)原理</h3><ul>
<li>被synchronized修饰的代码块，编译的字节码中会被monitorenter和monitorexit包围。</li>
<li>执行monitorenter时，首先要尝试获取对象的锁。如果获得成功，把锁的计数器加1。相应的，monitorexit会把锁的计数器减1.</li>
</ul>
<h3 id="2-ReentrantLock原理"><a href="#2-ReentrantLock原理" class="headerlink" title="2. ReentrantLock原理"></a>2. ReentrantLock原理</h3><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">美团AQS分析</a>仅供参考，内容有误（非公平锁图解出错）</p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e4f3cede51d4526c80e99cf">JUC必知必会</a></p>
<ul>
<li>通过AQS实现</li>
<li>双向链表实现的同步队列</li>
<li>Node的waitStatus</li>
<li>state操作</li>
</ul>
<h3 id="AQS-AbstractQueuedSynchronizer"><a href="#AQS-AbstractQueuedSynchronizer" class="headerlink" title="AQS AbstractQueuedSynchronizer"></a>AQS AbstractQueuedSynchronizer</h3><p>同步队列，JUC工具几乎都是通过<strong>组合AQS</strong>，重写某些方法实现的。</p>
<h4 id="AQS核心思想"><a href="#AQS核心思想" class="headerlink" title="AQS核心思想"></a>AQS核心思想</h4><ol>
<li>用CAS尝试改变state，如果成功则获得锁</li>
<li>CAS失败，就加入同步队列，通过同步机制来有序请求锁。</li>
</ol>
<h4 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h4><h3 id="锁的维度"><a href="#锁的维度" class="headerlink" title="锁的维度"></a>锁的维度</h3><ul>
<li>是否公平</li>
</ul>
<h3 id="AQS的三个维度"><a href="#AQS的三个维度" class="headerlink" title="AQS的三个维度"></a>AQS的三个维度</h3><ul>
<li>是否<strong>可中断</strong></li>
<li>是否<strong>超时</strong></li>
<li>是否<strong>共享</strong></li>
</ul>
<h4 id="AQS是否可共享：共享模式shareMode，独占模式exclusiveMode"><a href="#AQS是否可共享：共享模式shareMode，独占模式exclusiveMode" class="headerlink" title="AQS是否可共享：共享模式shareMode，独占模式exclusiveMode"></a>AQS是否可共享：共享模式shareMode，独占模式exclusiveMode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state; <span class="comment">// 同步状态state</span></span><br></pre></td></tr></table></figure>

<p>独占模式：state初始为0, state为0时，CAS操作+1，成功则获得锁。</p>
<p>共享模式：state初始为n，每当一个线程获得锁-1，当state为0时阻塞。</p>
<h4 id="state操作"><a href="#state操作" class="headerlink" title="state操作"></a>state操作</h4><ul>
<li>getState</li>
<li>setState</li>
<li>compareAndSetState</li>
</ul>
<h4 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h4><p>尝试获取锁：lock</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;  <span class="comment">// CAS操作state  if (compareAndSetState(0, 1))    // CAS成功，设置独占锁    setExclusiveOwnerThread(Thread.currentThread());   else    // CAS设置state失败，加入同步队列    acquire(1); // 模板方法&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// acquire模板public final void acquire(int arg) &#123;    if (!tryAcquire(arg) // 再次尝试获取，标记1        &amp;&amp;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) // 加入队列, 标记2        selfInterrupt();&#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>再次尝试获取锁，tryAcquire标记1导读：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tryAcquire 标记1protected final boolean tryAcquire(int acquires) &#123;  return nonfairTryAcquire(acquires); // 标记1&#125;// 非公平锁的尝试获取//  nonfairTryAcquire 标记1final boolean nonfairTryAcquire(int acquires) &#123;  final Thread current = Thread.currentThread();  int c = getState();  // 如果state为0，再尝试一次CAS获取锁  if (c == 0) &#123;    if (compareAndSetState(0, acquires)) &#123;      setExclusiveOwnerThread(current);      return true; // CAS成功，获得锁    &#125;  &#125;  // 如果自己是当前锁的持有者，重入操作，state++  else if (current == getExclusiveOwnerThread()) &#123;    int nextc = c + acquires;    if (nextc &lt; 0) // overflow      throw new Error(&quot;Maximum lock count exceeded&quot;);    setState(nextc);    return true;  &#125;  return false; // CAS失败，自己也不是持有者，失败&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>加入同步队列，标记2导读</li>
</ol>
<p>添加到队尾：addWaiter：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要思想：CAS操作添加节点到同步队列队尾private Node addWaiter(Node mode) &#123;  Node node = new Node(Thread.currentThread(), mode);  Node pred = tail;  if (pred != null) &#123;    node.prev = pred;    // CAS    if (compareAndSetTail(pred, node)) &#123;      pred.next = node;      return node;    &#125;  &#125;  enq(node);  return node;&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>在同步队列中自旋请求锁，标记2导读</p>
<p>在队列中自旋请求锁：acquireQueued：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;  <span class="keyword">try</span> &#123;    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;    <span class="comment">// 自旋操作，要么获得锁，要么阻塞（防止自旋浪费资源）    for (;;) &#123;      // 获取当前node的前驱      final Node p = node.predecessor();      // 1.如果自己在队列头部，尝试CAS请求锁（和之前一样）      if (p == head &amp;&amp; tryAcquire(arg)) &#123;        // 请求锁成功，设置自己为队头        setHead(node);         p.next = null; // help GC，删除自己（因为已经获得锁了）        failed = false;        return interrupted; // 返回      &#125;      // 2. 判断是否需要阻塞（根据waitStatus）      if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;          parkAndCheckInterrupt())        interrupted = true;    &#125;  &#125; finally &#123;    if (failed)      cancelAcquire(node);  &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</code>分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 靠前驱节点判断是否需要阻塞private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;  int ws = pred.waitStatus; // 前驱节点状态  // 前驱处于唤醒状态  if (ws == Node.SIGNAL)    return true;  // 前驱处于取消状态  if (ws &gt; 0) &#123;    // 把 队列从自己往队头遍历，删除处于取消状态的节点    do &#123;      node.prev = pred = pred.prev;    &#125; while (pred.waitStatus &gt; 0);    pred.next = node;  &#125; else &#123;    // 设置前驱唤醒    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);  &#125;  return false;&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻塞当前线程private final boolean parkAndCheckInterrupt() &#123;    LockSupport.park(this);    return Thread.interrupted();&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="waitStatus枚举表"><a href="#waitStatus枚举表" class="headerlink" title="waitStatus枚举表"></a>waitStatus枚举表</h4><table>
<thead>
<tr>
<th align="left">枚举</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">初始化值</td>
</tr>
<tr>
<td align="left">CANCELLED</td>
<td align="left">1，表示线程获取锁的请求已经取消了</td>
</tr>
<tr>
<td align="left">SIGNAL</td>
<td align="left">-1，等待被唤醒了，准备请求锁</td>
</tr>
<tr>
<td align="left">CONDITION</td>
<td align="left">-2，在队列中等待</td>
</tr>
<tr>
<td align="left">PROPAGATE</td>
<td align="left">-3，当前线程节点的后续节点的acquireShare方法能够被无条件执行</td>
</tr>
</tbody></table>
<h4 id="AQS的公平锁与非公平锁实现"><a href="#AQS的公平锁与非公平锁实现" class="headerlink" title="AQS的公平锁与非公平锁实现"></a>AQS的公平锁与非公平锁实现</h4><p>主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</p>
<p>非公平锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;  <span class="comment">// 直接CAS操作上锁  if (compareAndSetState(0, 1))    setExclusiveOwnerThread(Thread.currentThread());  else    acquire(1);&#125;</span></span><br></pre></td></tr></table></figure>

</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="/images/JavaLogo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/08/Java-JVM/"><img class="prev-cover" src="/images/JavaLogo.png" onerror="onerror=null;src='/images/tenor.gif'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Java-JVM</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/08/Docker-Compose/"><img class="next-cover" src="/images/Moby-logo.png" onerror="onerror=null;src='/images/tenor.gif'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Docker-Compose</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/01/08/Java-JVM/" title="Java-JVM"><img class="cover" src="/images/JavaLogo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-08</div><div class="title">Java-JVM</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">Java高并发学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BA%A7%E5%88%AB"><span class="toc-number">1.1.1.</span> <span class="toc-text">并发级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMM-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">JMM Java内存模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.</span> <span class="toc-text">线程的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.1.</span> <span class="toc-text">线程的状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A9%BB%E5%AE%88%E5%90%8E%E5%8F%B0-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8BDeamon"><span class="toc-number">1.3.</span> <span class="toc-text">驻守后台-守护线程Deamon</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="toc-number">1.4.</span> <span class="toc-text">Java并发工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized"><span class="toc-number">1.4.1.</span> <span class="toc-text">Synchronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-%E5%B1%9E%E4%BA%8E%E7%AE%A1%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.2.</span> <span class="toc-text">Object &#x2F; 属于管程的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JUT-%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7"><span class="toc-number">1.5.</span> <span class="toc-text">JUT 同步工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81ReentrantLock"><span class="toc-number">1.5.1.</span> <span class="toc-text">可重入锁ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">方法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E5%A5%BD%E6%90%AD%E6%A1%A3Condition-%E7%AE%A1%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.2.</span> <span class="toc-text">可重入锁的好搭档Condition&#x2F;管程实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%92%E8%AE%A1%E6%95%B0%E5%99%A8CountDownLatch"><span class="toc-number">1.5.3.</span> <span class="toc-text">倒计数器CountDownLatch</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-1"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%B1%8F%E9%9A%9CCyclicBarrier"><span class="toc-number">1.5.4.</span> <span class="toc-text">循环屏障CyclicBarrier</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-2"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore"><span class="toc-number">1.5.5.</span> <span class="toc-text">信号量Semaphore</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-3"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.6.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E9%87%8D%E7%94%A8%EF%BC%9F"><span class="toc-number">1.6.0.1.</span> <span class="toc-text">线程池如何重用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.6.0.2.</span> <span class="toc-text">创建多少线程？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK%E7%9A%84Executor%E6%A1%86%E6%9E%B6"><span class="toc-number">1.6.1.</span> <span class="toc-text">JDK的Executor框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">工厂方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">计划任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E7%89%B9%E4%BE%8B"><span class="toc-number">1.6.1.4.</span> <span class="toc-text">计划任务特例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-ThreadPoolExecutor"><span class="toc-number">1.6.2.</span> <span class="toc-text">线程池内部实现 ThreadPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">核心参数之间的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%95%E6%97%B6%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">线程池何时创建线程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97-workQueue"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">任务队列 workQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E5%AF%B9%E5%BA%94%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">任务队列对应实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5-handler"><span class="toc-number">1.6.2.5.</span> <span class="toc-text">拒绝策略 handler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%EF%BC%9AThreadFactory"><span class="toc-number">1.6.2.6.</span> <span class="toc-text">自定义线程创建：ThreadFactory</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="toc-number">1.7.</span> <span class="toc-text">JDK并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="toc-number">1.7.0.1.</span> <span class="toc-text">高并发容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%AE%B9%E5%99%A8"><span class="toc-number">1.7.0.2.</span> <span class="toc-text">普通线程安全容器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97-BlockingQueue"><span class="toc-number">1.7.1.</span> <span class="toc-text">阻塞队列 BlockingQueue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.8.</span> <span class="toc-text">锁的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%94%81%E4%BC%98%E5%8C%96"><span class="toc-number">1.8.1.</span> <span class="toc-text">Java虚拟机锁优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">偏向锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">轻量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">自旋锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">1.8.1.4.</span> <span class="toc-text">重量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-number">1.8.1.5.</span> <span class="toc-text">锁消除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">1.8.1.6.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.8.1.7.</span> <span class="toc-text">最佳实践</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%88%86%E6%9E%90"><span class="toc-number">1.8.1.8.</span> <span class="toc-text">引用分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Thread%E5%8E%9F%E7%90%86"><span class="toc-number">1.8.1.9.</span> <span class="toc-text">Thread原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Thread%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">1.8.1.10.</span> <span class="toc-text">Thread内存泄漏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.8.1.11.</span> <span class="toc-text">源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8"><span class="toc-number">1.8.1.12.</span> <span class="toc-text">常见使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.8.1.13.</span> <span class="toc-text">ThreadLocal原理与实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal-%E4%B8%9A%E5%8A%A1"><span class="toc-number">1.8.1.14.</span> <span class="toc-text">ThreadLocal 业务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E9%94%81"><span class="toc-number">1.9.</span> <span class="toc-text">无锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS-Compare-And-Set"><span class="toc-number">1.9.1.</span> <span class="toc-text">CAS Compare And Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E9%94%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%95%B4%E6%95%B0-AtomicInteger"><span class="toc-number">1.9.2.</span> <span class="toc-text">无锁的线程安全整数: AtomicInteger</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E9%94%81%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8-AtomicReference"><span class="toc-number">1.9.3.</span> <span class="toc-text">无锁的对象引用:AtomicReference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E6%9C%89%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%EF%BC%9AAtomicStampedReference"><span class="toc-number">1.9.4.</span> <span class="toc-text">带有时间戳的对象引用：AtomicStampedReference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B9%9F%E8%83%BD%E6%97%A0%E9%94%81%EF%BC%9AAtomicIntegerArray"><span class="toc-number">1.9.5.</span> <span class="toc-text">数组也能无锁：AtomicIntegerArray</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">1.10.</span> <span class="toc-text">乐观锁与悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">1.10.0.1.</span> <span class="toc-text">悲观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">1.10.0.2.</span> <span class="toc-text">乐观锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-number">1.11.</span> <span class="toc-text">synchronized的使用细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Syn%E5%92%8CLock%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.12.</span> <span class="toc-text">Syn和Lock实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">1.12.1.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="toc-number">1.12.2.</span> <span class="toc-text">相同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-synchronized-syn-%E5%8E%9F%E7%90%86"><span class="toc-number">1.12.3.</span> <span class="toc-text">1.synchronized(syn)原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-ReentrantLock%E5%8E%9F%E7%90%86"><span class="toc-number">1.12.4.</span> <span class="toc-text">2. ReentrantLock原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS-AbstractQueuedSynchronizer"><span class="toc-number">1.12.5.</span> <span class="toc-text">AQS AbstractQueuedSynchronizer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AQS%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">1.12.5.1.</span> <span class="toc-text">AQS核心思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.12.5.2.</span> <span class="toc-text">同步机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E7%BB%B4%E5%BA%A6"><span class="toc-number">1.12.6.</span> <span class="toc-text">锁的维度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%E7%9A%84%E4%B8%89%E4%B8%AA%E7%BB%B4%E5%BA%A6"><span class="toc-number">1.12.7.</span> <span class="toc-text">AQS的三个维度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AQS%E6%98%AF%E5%90%A6%E5%8F%AF%E5%85%B1%E4%BA%AB%EF%BC%9A%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8FshareMode%EF%BC%8C%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8FexclusiveMode"><span class="toc-number">1.12.7.1.</span> <span class="toc-text">AQS是否可共享：共享模式shareMode，独占模式exclusiveMode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#state%E6%93%8D%E4%BD%9C"><span class="toc-number">1.12.7.2.</span> <span class="toc-text">state操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="toc-number">1.12.7.3.</span> <span class="toc-text">源码解读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#waitStatus%E6%9E%9A%E4%B8%BE%E8%A1%A8"><span class="toc-number">1.12.7.4.</span> <span class="toc-text">waitStatus枚举表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AQS%E7%9A%84%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.12.7.5.</span> <span class="toc-text">AQS的公平锁与非公平锁实现</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/images/JavaLogo.png')"><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    const waline = new Waline(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://windyplace-valine.vercel.app/',
      avatar: 'monsterid',
      avatarCDN: 'https://sdn.geekzu.org/avatar/',
      path: location.pathname,
      visitor: false,
      dark: 'html[data-theme="dark"]'
    }, null))
  }

  if (typeof Waline === 'function') initWaline() 
  else getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js').then(initWaline)
}

if ('Waline' === 'Waline' || !false) {
  if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>